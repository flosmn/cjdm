\section{Concept}
\label{sec:Concept}
The basic concept behind ogre4j is to provide one-to-one bindings for each 
public interface of the OGRE library. The JNI wrapper should not hide any 
features of the underlaying API and should not contain any black magic. 
Therefore the JNI bindings do nothing else than calling the corresponding 
native function.

\subsection{Memory Allocation}
\label{sec:MemoryAllocation}
If a developer creates a new ogre4j object he will create a native OGRE object 
as well and all data will be kept in it. The Java object is only the interface 
to access this data through JNI. Creating a native object means to call the 
constructor and allocate memory for it on the native heap (new). The problem of 
this memory allocation is that Javas garbage collector doesn't know anything 
about it and on the native side doesn't exist an equivalent system. Accounting 
to that the developer has to be sure to deallocate everything he allocated on 
his own! The result of this is a major rule that every developer must remember 
when using ogre4j:
\begin{quote}
	\textbf{If you create a ogre4j object with 'new' you have to delete it!}
\end{quote}
Objects created by OGRE are in the responsibility of the native library and 
should be never deleted by a Java program. To strictly adhere to the mentioned 
rule we decided to introduce some API changes to the bindings which should help 
to make it clear which objects should be deleted. C/C++ has three different 
ways to pass variables:
\begin{itemize}
\item by value\\A copy of the variable on the stack.
\item by reference\\A copy of the reference of the variable on the stack.
\item by pointer\\A copy of the pointer to the variable on the stack.
\end{itemize}
By contrast Java passes variables by reference\footnote{Except for primitive 
variables.} only. For primitive variables like integers this problem is 
irrelevant because primitives can be passed by value in JNI calls without loss 
of performance. Non primitive objects should never be passed by value through 
JNI calls because the size of the data that must be copied exceeds the size of 
the corresponding reference which is sufficient to access the native data. 
Because of that ogre4j passes heavy weight objects by reference only. This 
behavior has one big disadvantage. If a OGRE function returns a non-primitive 
object by value this object is only valid in the scope of the JNI call because 
it is copied on the stack and will be removed if the scope is left. To be able 
to return the reference to such an object the wrapper has to copy the object to 
the heap and returns the reference of the copy which will be valid until it is 
deleted. On Java side the wrapper does not know when to delete the returned 
object because the wrapper doesn't include a smart pointer or garbage collector 
implementation. Because of that the developer which calls the corresponding 
function has to delete the returned object if not longer needed. This conflicts 
with the ``new'' rule and can lead to misunderstandings. To put straight that 
the developer assumes responsibility for the returned object the API is changed 
so that the developer has to pass a previously created object to receive the 
return value. Now the ``new'' rule applies and the developers knows that he has 
to delete object.

\subsection{JNI Code Generation}
\label{sec:JNICodeGeneration}
One big point for every project that implements wrapper(s) for a library in 
different programming languages is the effort to maintain the wrapper code. The 
target library has their own release cycles and most major releases introduce 
API breaking changes. Most of the projects deal with this issue by using code 
generators which create the necessary bindings automatically. We evaluated the 
application of several code generators such as SWIG\footnote{Simplified Wrapper 
and Interface Generator} and NoddleGlue but none of the tested tools met our 
requirements. SWIG needs very much effort beforehand because every interface 
that should be wrapped needs a interface description file. Both tools miss full 
support of C/C++ templates which are used quite often in OGRE. For this and 
other reasons we decided in autumn 2005 to implement our own generator based on 
the same technologies as NoodleGlue. Since autumn 2006 the JNI code generator 
project is forked from ogre4j under the name XBiG\footnote{XSLT Bindings 
Generator} and got its own project space on Sourceforge.net.

NoodleGlue is the wrapper generation tool of ``noodle heaven'' and uses doxygen 
to extract the API information from the library's source code. This approach 
had the advantage that parsing and analyzing is done by a tool that is 
widely-used and tested with different input languages. So the first step to our 
generator was already available for free. Besides the usual outputs like a HTML 
documentation Doxygen provides a XML output of the analysed source code. This 
output is specialized for the Doxygen task to generate documentation, contains 
a lot of information that isn't necessary to generate wrapper code and is 
structured in a flat\footnote{E.g. name spaces are not nested as child XML 
elements.} hierarchy. For these reasons and to have the possibility to replace 
Doxygen with another tool, we decided to implement a meta layer that is 
represented in XML too.

To convert the Doxygen output to our meta layer we're using 
XSLT\footnote{Extensible Stylesheet Language Transformations} which is designed 
to describe conversions or transformations of XML code with XML code. One big 
advantage of XSLT is that it is an interpreted language and therefore 
OS\footnote{Operation System} independent. The generation of the meta layer and 
the layer itself should be independent from any OS or platform to make it 
possible to generate bindings for ``every'' language on every platform. To have 
a consistent tool chain the generation of the wrapper code is done with XSLT 
too. This reduces the usage of different tools and technologies to one major 
aspect: XML/XSLT. As mentioned before, Doxygen could be replaced with another 
tool that is capable of parsing source code and generating a XML representation 
of the parsed input.

\subsubsection{Meta Description of  APIs}
\label{sec:MetaDescriptionOfAPIs}
The meta XML layer should be independent from any OS or platform and 
additional to this requirement the goal was to create a meta description of 
programming interfaces that is independent from the input language. To reach 
this goal the meta layer must be able to describe features of the most common 
programming languages in an abstract and common way.

The meta layer is a XML tree of name spaces, classes, functions and
includes the support for the description of templates. These basic features should
fulfill the requirements of most modern programming languages.

\subsubsection{Doxygen}
\label{sec:Doxygen}
Doxygen is a documentation generator for C++, C, Java, Objective-C, Python, IDL 
\footnote{Corba and Microsoft flavors} and to some extent PHP, C\#, D and ActionScript. 
It runs on most Unix-like systems as well as on Windows and Mac OS X. Most of 
the Doxygen code was written by Dimitri van Heesch. Like Javadoc, Doxygen 
extracts documentation from source file comments. In addition to the Javadoc 
syntax it supports the documentation tags used in the Qt toolkit and can 
generate output in HTML as well as in CHM, RTF, PDF, LaTeX, PostScript or man 
pages.

\subsubsection{XSLT}
\label{sec:XSLT}
Extensible Stylesheet Language Transformations is an XML-based language used 
for the transformation of XML documents. XSLT is designed to transform XML 
documents into other XML or "human-readable" documents. The original document 
is not changed; rather, a new document is created based on the content of an 
existing one. The new document may be serialized (output) by the processor in 
standard XML syntax or in another format, such as HTML or plain text. XSLT is 
most often used to convert data between different XML schemes or to convert XML 
data into HTML or XHTML documents for web pages, creating a Dynamic web page, 
or into an intermediate XML format that can be converted to PDF documents.

As a language, XSLT is influenced by functional languages, and by text-based 
pattern matching languages like SNOBOL and awk. Its most direct predecessor was 
DSSSL, a language that performed the same function for SGML that XSLT performs 
for XML. XSLT can also be considered as a template processor.

\subsection{Advantages}
\label{sec:Advantages}
\begin{itemize}
  	\item ogre4j provides all features of OGRE.
  	\item ogre4j is faster than Java3D. 
	\item Development with Java is platform independent\footnote{Only if
	platform and OS independent libraries are used.}.
	\item Java has rich and clean APIs.
	\item Eclipse can be used as application platform.
	\item Eclipse is one of the most powerful IDEs.
\end{itemize}
