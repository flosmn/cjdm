\section{Alternative 3D APIs}
\label{sec:Alternative3DAPIs}

\subsection{Java3D}
\label{sec:Java3D}
Java 3D is a scene graph-based 3D application programming interface for the 
Java platform. It runs on top of either OpenGL or Direct3D. Since version 1.2, 
Java 3D is developed under the Java Community Process. JSR 926 specifies Java 
3D 1.4; as of 2007, the current version is 1.5.1 (released in June 2007).

Compared to other solutions, Java 3D is not only a wrapper around these 
graphics APIs, but an interface that encapsulates the graphics programming 
using a real, object-oriented concept. Here a scene is constructed using a 
scene graph that is a representation of the objects that have to be shown. This 
scene graph is structured as a tree containing several elements that are 
necessary to display the objects. Additionally, Java 3D offers extensive 
specialized sound support.

Java 3D and its documentation are available for download separately. They are 
not part of the JDK 6. However future versions of the JDK are expected to 
include a API package for Java 3D.

\subsection{JOGL}
\label{sec:JOGL}
Java OpenGL is a wrapper library that allows OpenGL\footnote{Open 
Graphics Library} to be used in the Java programming language. It is currently 
being developed by the Game Technology Group at Sun Microsystems, and is the 
reference implementation for JSR-231\footnote{Java Bindings for OpenGL}.

JOGL allows access to most features available to C programming language 
programmers, with the notable exception of window-system related calls in 
GLUT\footnote{OpenGL Utility Toolkit}, and some extensions.

\subsection{LWJGL}
\label{sec:LWJGL}
The Lightweight Java Game Library is a solution aimed directly at 
professional and amateur Java programmers alike to enable commercial quality 
games to be written in Java. LWJGL provides developers access to high 
performance cross-platform libraries such as OpenGL and OpenAL\footnote{Open 
Audio Library} allowing for state of the art 3D games and 3D sound. 
Additionally LWJGL provides access to controllers such as Gamepads, Steering 
wheel and Joysticks. All in a simple and straight forward API. The LWJGL 
project also has bindings for FMOD and DevIL, formerly known as OpenIL. LWJGL 
1.0 was released February 4th, 2007.

LWJGL is not meant to make writing games particularly easy; it is primarily an 
enabling technology which allows developers to get at resources that are simply 
otherwise unavailable or poorly implemented on the existing Java platform. It 
is anticipated that the LWJGL will, through evolution and extension, become the 
foundation for more complete game libraries and "game engines" as they have 
popularly become known, and hide some of the new evils have had to been exposed 
in the APIs. One such example is the jMonkey Engine.

LWJGL is available under a BSD license, which means it's open source and freely 
available.

\subsection{Xith3D}
\label{sec:Xith3D}
Xith3D is a scene graph based 3D engine written in Java. It uses JOGL or LWJGL for rendering, but it is designed to be not tied up with any underlying API. Sound is designed independetly of any API as well and there is support for OpenAL and JavaSound.

Like Java3D it is not only a wrapper. The Contents of a 3D scene are described as a tree-like structure of Java-objects. Xith3D can be considered an alternative solution to Java3D as both use the same basic architecture.

Xith3D is released under the BSD license allowing commercial and non-commercial projects.

\subsection{jME}
\label{sec:jME}
jMonkeyEngine is also a scene graph based 3D engine written in Java. Due to an abstraction layer, any rendering system can be plugged in but currently (Version 0.11) there is only LWJGL supported. It supports OpenAL and FMOD.

Based on a 3D game engine design it is apparently more oriented to game development.

Like Xith3D, jME is under BSD license.

\subsection{Jirr}
\label{sec:Jirr}
Jirr is a JNI wrapper for the Irrlicht Engine. 

The wrapper code is generated by SWIG\footnote{Simplified Wrapper and Interface Generator, see also \ref{sec:JNICodeGeneration}}.
Irrlicht is an open source 3D engine written in C++. For rendering it uses Direct3D, OpenGL and its own software renderer. Compared to Ogre the Irrlich Engine is generally considered more beginner-friendly but less feature-rich. For example Irrlicht has:
\begin{itemize}
	\item no multipass rendering
	\item no unified file format
	\item no advanced animation system
\end{itemize}
Furthermore, some features of the Irrlicht Engine are not accessible by Jirr.

\subsection{Summary}
\label{sec:AltSummary}
JOGL and LWJGL are or contain simple JNI wrappers of 
OpenGL. OpenGL is a standard specification defining a cross-language 
cross-platform API for writing applications that produce 2D and 3D computer 
graphics. The interface consists of over 250 different function calls which can 
be used to draw complex three-dimensional scenes from simple primitives. OpenGL 
was designed to be graphic output-only: it provides only rendering functions to 
draw 3D lines, vertices and bodies. E.g. scene graph based handling of 3D data 
is not supported. Because of that OpenGL is in comparison with OGRE a low level 
render API which leaves a lot of work to the application developer.

Java3D, Xith3D and jME are high level render APIs too but their high level functionalities are 
implemented in Java and because of that they lag performance in comparison to 
OGRE. E.g. the implementation of the rendering pipeline. The Java3D rendering 
pipeline must process the scene graph for each frame and invokes JNI calls to 
draw every single vertex, line and geometry. Xith3D and jME have even more overhead 
as they pass calls first to JOGL or LWJGL which in turn invoke JNI calls to draw every single 
vertex, line and geometry.
OGRE does this all without the JNI  bottleneck and should be faster accordingly. Even 
if the render loop is implemented in Java using ogre4j there is just one JNI call 
necessary to trigger the rendering of a frame.

Jirr and ogre4j have the same approach but Jirr has some drawbacks: It uses SWIG for code generation which causes several problems as explained in \ref{sec:JNICodeGeneration}. Jirr also supports fewer rendering and animation features than ogre4j due to the use of the Irrlicht Engine.

So what do we get from the OGRE - ogre4j bundle? We get a high level feature-rich 3D render 
API in Java with nearly same performance as the native variant.