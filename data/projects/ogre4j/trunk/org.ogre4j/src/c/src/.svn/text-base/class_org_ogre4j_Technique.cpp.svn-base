///////////////////////////////////////////////////////////////////////////////
/// This source file is generated by XBiG (The XSLT Bindings Generator)
/// For the latest info, see http://sourceforge.net/projects/xbig/
///
/// Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
/// Also see acknowledgements in Readme.html
///
/// This program is free software; you can redistribute it and/or modify it under
/// the terms of the GNU Lesser General Public License as published by the Free Software
/// Foundation; either version 2 of the License, or (at your option) any later
/// version.
///
/// This program is distributed in the hope that it will be useful, but WITHOUT
/// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
/// FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
///
/// You should have received a copy of the GNU Lesser General Public License along with
/// this program; if not, write to the Free Software Foundation, Inc., 59 Temple
/// Place - Suite 330, Boston, MA 02111-1307, USA, or go to
/// http://www.gnu.org/copyleft/lesser.txt.
///
/// Machine generated file
///////////////////////////////////////////////////////////////////////////////



#ifdef WIN32
	// disable warnings
	#pragma warning (disable : 4267) // conversion from 'size_t' to 'jint'
#else

#endif


// includes from config
#include <Ogre4JStableHeaders.h>

// use base library for cpp2j
#include "jni_base_all.h"

// import declaration of all functions
#include "class_org_ogre4j_Technique.h"

// import header files of original library
#include <OgreTechnique.h>



/*
 * Class:      org.ogre4j.Technique
 * Method:     Technique()
 * Type:       constructor
 * Definition: Ogre::Technique::Technique
 * Signature:  (Ogre_Material)V
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Technique__1_1createTechnique_1_1Materialp (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong parent
)
{
   // constructor of class Ogre::Technique 
   
   // parameter conversions 
  Ogre::Material* _cpp_parent = reinterpret_cast< Ogre::Material* >(parent); 
   
   // create new instance of class Ogre::Technique 
   Ogre::Technique* _cpp_this = new Ogre::Technique(_cpp_parent); 
   
   // return casted pointer 
   jlong _jni_pointer_ = reinterpret_cast<jlong>(_cpp_this); 
   return _jni_pointer_;
} /* Ogre::Technique::Technique */


/*
 * Class:      org.ogre4j.Technique
 * Method:     Technique()
 * Type:       constructor
 * Definition: Ogre::Technique::Technique
 * Signature:  (Ogre_MaterialOgre_Technique)V
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Technique__1_1createTechnique_1_1MaterialpTechniqueR (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong parent, 
  jlong oth
)
{
   // constructor of class Ogre::Technique 
   
   // parameter conversions 
  Ogre::Material* _cpp_parent = reinterpret_cast< Ogre::Material* >(parent);
  const Ogre::Technique* _cpp_oth = reinterpret_cast< const Ogre::Technique* >(oth); 
   
   // create new instance of class Ogre::Technique 
   Ogre::Technique* _cpp_this = new Ogre::Technique(_cpp_parent, *_cpp_oth); 
   
   // return casted pointer 
   jlong _jni_pointer_ = reinterpret_cast<jlong>(_cpp_this); 
   return _jni_pointer_;
} /* Ogre::Technique::Technique */


/*
 * Class:      org.ogre4j.Technique
 * Method:     isSupported()
 * Type:       non-virtual method
 * Definition: bool Ogre::Technique::isSupported
 * Signature:  ()Z
 */

JNIEXPORT jboolean JNICALL Java_org_ogre4j_Technique__1isSupported_1const (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   const Ogre::Technique* _cpp_this = reinterpret_cast<const Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const bool _cpp_result = _cpp_this->isSupported() ; 
   return _cpp_result ? 1 : 0;
} /* bool Ogre::Technique::isSupported */


/*
 * Class:      org.ogre4j.Technique
 * Method:     _compile()
 * Type:       non-virtual method
 * Definition: String Ogre::Technique::_compile
 * Signature:  (Z)std_string
 */

JNIEXPORT jstring JNICALL Java_org_ogre4j_Technique__1_1compile_1_1bv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jboolean autoManageTextureUnits
)
{
   // parameter conversions 
  bool _cpp_autoManageTextureUnits = autoManageTextureUnits ? true : false; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const std::string _cpp_result = _cpp_this->_compile(_cpp_autoManageTextureUnits) ; 
   return org::xbig::jni::to_jstring(_jni_env_, _cpp_result);
} /* String Ogre::Technique::_compile */


/*
 * Class:      org.ogre4j.Technique
 * Method:     checkGPURules()
 * Type:       non-virtual method
 * Definition: bool Ogre::Technique::checkGPURules
 * Signature:  (std_ostringstream)Z
 */

JNIEXPORT jboolean JNICALL Java_org_ogre4j_Technique__1checkGPURules_1_1StringUtil_1StrStreamTyper (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jlong errors
)
{
   // parameter conversions 
  std::ostringstream* _cpp_errors = reinterpret_cast< std::ostringstream* >(errors); 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const bool _cpp_result = _cpp_this->checkGPURules(*_cpp_errors) ; 
   return _cpp_result ? 1 : 0;
} /* bool Ogre::Technique::checkGPURules */


/*
 * Class:      org.ogre4j.Technique
 * Method:     checkHardwareSupport()
 * Type:       non-virtual method
 * Definition: bool Ogre::Technique::checkHardwareSupport
 * Signature:  (Zstd_ostringstream)Z
 */

JNIEXPORT jboolean JNICALL Java_org_ogre4j_Technique__1checkHardwareSupport_1_1bvStringUtil_1StrStreamTyper (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jboolean autoManageTextureUnits, 
  jlong compileErrors
)
{
   // parameter conversions 
  bool _cpp_autoManageTextureUnits = autoManageTextureUnits ? true : false;
  std::ostringstream* _cpp_compileErrors = reinterpret_cast< std::ostringstream* >(compileErrors); 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const bool _cpp_result = _cpp_this->checkHardwareSupport(_cpp_autoManageTextureUnits, *_cpp_compileErrors) ; 
   return _cpp_result ? 1 : 0;
} /* bool Ogre::Technique::checkHardwareSupport */


/*
 * Class:      org.ogre4j.Technique
 * Method:     _compileIlluminationPasses()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::_compileIlluminationPasses
 * Signature:  ()V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1_1compileIlluminationPasses (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->_compileIlluminationPasses();
} /* void Ogre::Technique::_compileIlluminationPasses */


/*
 * Class:      org.ogre4j.Technique
 * Method:     createPass()
 * Type:       non-virtual method
 * Definition: Pass* Ogre::Technique::createPass
 * Signature:  ()Ogre_Pass
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Technique__1createPass (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const Ogre::Pass* _cpp_result = _cpp_this->createPass() ; 
   return reinterpret_cast<jlong>(_cpp_result);
} /* Pass* Ogre::Technique::createPass */


/*
 * Class:      org.ogre4j.Technique
 * Method:     getPass()
 * Type:       non-virtual method
 * Definition: Pass* Ogre::Technique::getPass
 * Signature:  (S)Ogre_Pass
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Technique__1getPass_1_1Hv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jint index
)
{
   // parameter conversions 
  unsigned short _cpp_index = index; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const Ogre::Pass* _cpp_result = _cpp_this->getPass(_cpp_index) ; 
   return reinterpret_cast<jlong>(_cpp_result);
} /* Pass* Ogre::Technique::getPass */


/*
 * Class:      org.ogre4j.Technique
 * Method:     getPass()
 * Type:       non-virtual method
 * Definition: Pass* Ogre::Technique::getPass
 * Signature:  (std_string)Ogre_Pass
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Technique__1getPass_1_1StringR (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jstring name
)
{
   // parameter conversions 
  std::string _cpp_name = ""; org::xbig::jni::to_stdstring(_jni_env_, name, _cpp_name); // calls c-tor only. Not operator= .; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const Ogre::Pass* _cpp_result = _cpp_this->getPass(_cpp_name) ; 
   return reinterpret_cast<jlong>(_cpp_result);
} /* Pass* Ogre::Technique::getPass */


/*
 * Class:      org.ogre4j.Technique
 * Method:     getNumPasses()
 * Type:       non-virtual method
 * Definition: unsigned short Ogre::Technique::getNumPasses
 * Signature:  ()S
 */

JNIEXPORT jint JNICALL Java_org_ogre4j_Technique__1getNumPasses_1const (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   const Ogre::Technique* _cpp_this = reinterpret_cast<const Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const unsigned short _cpp_result = _cpp_this->getNumPasses() ; 
   return _cpp_result;
} /* unsigned short Ogre::Technique::getNumPasses */


/*
 * Class:      org.ogre4j.Technique
 * Method:     removePass()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::removePass
 * Signature:  (S)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1removePass_1_1Hv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jint index
)
{
   // parameter conversions 
  unsigned short _cpp_index = index; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->removePass(_cpp_index);
} /* void Ogre::Technique::removePass */


/*
 * Class:      org.ogre4j.Technique
 * Method:     removeAllPasses()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::removeAllPasses
 * Signature:  ()V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1removeAllPasses (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->removeAllPasses();
} /* void Ogre::Technique::removeAllPasses */


/*
 * Class:      org.ogre4j.Technique
 * Method:     movePass()
 * Type:       non-virtual method
 * Definition: bool Ogre::Technique::movePass
 * Signature:  (SS)Z
 */

JNIEXPORT jboolean JNICALL Java_org_ogre4j_Technique__1movePass_1_1HVHV (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jint sourceIndex, 
  jint destinationIndex
)
{
   // parameter conversions 
  const unsigned short _cpp_sourceIndex = sourceIndex;
  const unsigned short _cpp_destinationIndex = destinationIndex; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const bool _cpp_result = _cpp_this->movePass(_cpp_sourceIndex, _cpp_destinationIndex) ; 
   return _cpp_result ? 1 : 0;
} /* bool Ogre::Technique::movePass */


/*
 * Class:      org.ogre4j.Technique
 * Method:     getPassIterator()
 * Type:       non-virtual method
 * Definition: const PassIterator Ogre::Technique::getPassIterator
 * Signature:  ()Ogre_Technique_PassIterator
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Technique__1getPassIterator (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const Ogre::Technique::PassIterator* _cpp_result = new Ogre::Technique::PassIterator( _cpp_this->getPassIterator() ); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* const PassIterator Ogre::Technique::getPassIterator */


/*
 * Class:      org.ogre4j.Technique
 * Method:     getIlluminationPassIterator()
 * Type:       non-virtual method
 * Definition: const IlluminationPassIterator Ogre::Technique::getIlluminationPassIterator
 * Signature:  ()Ogre_Technique_IlluminationPassIterator
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Technique__1getIlluminationPassIterator (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const Ogre::Technique::IlluminationPassIterator* _cpp_result = new Ogre::Technique::IlluminationPassIterator( _cpp_this->getIlluminationPassIterator() ); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* const IlluminationPassIterator Ogre::Technique::getIlluminationPassIterator */


/*
 * Class:      org.ogre4j.Technique
 * Method:     getParent()
 * Type:       non-virtual method
 * Definition: Material* Ogre::Technique::getParent
 * Signature:  ()Ogre_Material
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Technique__1getParent_1const (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   const Ogre::Technique* _cpp_this = reinterpret_cast<const Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const Ogre::Material* _cpp_result = _cpp_this->getParent() ; 
   return reinterpret_cast<jlong>(_cpp_result);
} /* Material* Ogre::Technique::getParent */


/*
 * Class:      org.ogre4j.Technique
 * Method:     operator=()
 * Type:       non-virtual method
 * Definition: Technique& Ogre::Technique::operator=
 * Signature:  (Ogre_Technique)Ogre_Technique
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Technique__1operatorAssignment_1_1TechniqueR (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jlong rhs
)
{
   // parameter conversions 
  const Ogre::Technique* _cpp_rhs = reinterpret_cast< const Ogre::Technique* >(rhs); 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const Ogre::Technique* _cpp_result = & _cpp_this->operator=(*_cpp_rhs) ; 
   return reinterpret_cast<jlong>(_cpp_result);
} /* Technique& Ogre::Technique::operator= */


/*
 * Class:      org.ogre4j.Technique
 * Method:     getResourceGroup()
 * Type:       non-virtual method
 * Definition: const String& Ogre::Technique::getResourceGroup
 * Signature:  ()std_string
 */

JNIEXPORT jstring JNICALL Java_org_ogre4j_Technique__1getResourceGroup_1const (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   const Ogre::Technique* _cpp_this = reinterpret_cast<const Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   std::string _cpp_result = _cpp_this->getResourceGroup() ; 
   return org::xbig::jni::to_jstring(_jni_env_, _cpp_result);
} /* const String& Ogre::Technique::getResourceGroup */


/*
 * Class:      org.ogre4j.Technique
 * Method:     isTransparent()
 * Type:       non-virtual method
 * Definition: bool Ogre::Technique::isTransparent
 * Signature:  ()Z
 */

JNIEXPORT jboolean JNICALL Java_org_ogre4j_Technique__1isTransparent_1const (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   const Ogre::Technique* _cpp_this = reinterpret_cast<const Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const bool _cpp_result = _cpp_this->isTransparent() ; 
   return _cpp_result ? 1 : 0;
} /* bool Ogre::Technique::isTransparent */


/*
 * Class:      org.ogre4j.Technique
 * Method:     isTransparentSortingEnabled()
 * Type:       non-virtual method
 * Definition: bool Ogre::Technique::isTransparentSortingEnabled
 * Signature:  ()Z
 */

JNIEXPORT jboolean JNICALL Java_org_ogre4j_Technique__1isTransparentSortingEnabled_1const (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   const Ogre::Technique* _cpp_this = reinterpret_cast<const Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const bool _cpp_result = _cpp_this->isTransparentSortingEnabled() ; 
   return _cpp_result ? 1 : 0;
} /* bool Ogre::Technique::isTransparentSortingEnabled */


/*
 * Class:      org.ogre4j.Technique
 * Method:     _prepare()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::_prepare
 * Signature:  ()V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1_1prepare (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->_prepare();
} /* void Ogre::Technique::_prepare */


/*
 * Class:      org.ogre4j.Technique
 * Method:     _unprepare()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::_unprepare
 * Signature:  ()V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1_1unprepare (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->_unprepare();
} /* void Ogre::Technique::_unprepare */


/*
 * Class:      org.ogre4j.Technique
 * Method:     _load()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::_load
 * Signature:  ()V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1_1load (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->_load();
} /* void Ogre::Technique::_load */


/*
 * Class:      org.ogre4j.Technique
 * Method:     _unload()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::_unload
 * Signature:  ()V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1_1unload (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->_unload();
} /* void Ogre::Technique::_unload */


/*
 * Class:      org.ogre4j.Technique
 * Method:     isLoaded()
 * Type:       non-virtual method
 * Definition: bool Ogre::Technique::isLoaded
 * Signature:  ()Z
 */

JNIEXPORT jboolean JNICALL Java_org_ogre4j_Technique__1isLoaded_1const (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   const Ogre::Technique* _cpp_this = reinterpret_cast<const Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const bool _cpp_result = _cpp_this->isLoaded() ; 
   return _cpp_result ? 1 : 0;
} /* bool Ogre::Technique::isLoaded */


/*
 * Class:      org.ogre4j.Technique
 * Method:     _notifyNeedsRecompile()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::_notifyNeedsRecompile
 * Signature:  ()V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1_1notifyNeedsRecompile (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->_notifyNeedsRecompile();
} /* void Ogre::Technique::_notifyNeedsRecompile */


/*
 * Class:      org.ogre4j.Technique
 * Method:     getShadowCasterMaterial()
 * Type:       non-virtual method
 * Definition: Ogre::MaterialPtr Ogre::Technique::getShadowCasterMaterial
 * Signature:  ()Ogre_MaterialPtr
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Technique__1getShadowCasterMaterial_1const (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   const Ogre::Technique* _cpp_this = reinterpret_cast<const Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const Ogre::MaterialPtr* _cpp_result = new Ogre::MaterialPtr( _cpp_this->getShadowCasterMaterial() ); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* Ogre::MaterialPtr Ogre::Technique::getShadowCasterMaterial */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setShadowCasterMaterial()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setShadowCasterMaterial
 * Signature:  (Ogre_MaterialPtr)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setShadowCasterMaterial_1_1Ogre_1MaterialPtrv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jlong val
)
{
   // parameter conversions 
  Ogre::MaterialPtr* _cpp_val = reinterpret_cast< Ogre::MaterialPtr* >(val); 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setShadowCasterMaterial(*_cpp_val);
} /* void Ogre::Technique::setShadowCasterMaterial */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setShadowCasterMaterial()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setShadowCasterMaterial
 * Signature:  (std_string)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setShadowCasterMaterial_1_1Ogre_1StringR (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jstring name
)
{
   // parameter conversions 
  std::string _cpp_name = ""; org::xbig::jni::to_stdstring(_jni_env_, name, _cpp_name); // calls c-tor only. Not operator= .; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setShadowCasterMaterial(_cpp_name);
} /* void Ogre::Technique::setShadowCasterMaterial */


/*
 * Class:      org.ogre4j.Technique
 * Method:     getShadowReceiverMaterial()
 * Type:       non-virtual method
 * Definition: Ogre::MaterialPtr Ogre::Technique::getShadowReceiverMaterial
 * Signature:  ()Ogre_MaterialPtr
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Technique__1getShadowReceiverMaterial_1const (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   const Ogre::Technique* _cpp_this = reinterpret_cast<const Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const Ogre::MaterialPtr* _cpp_result = new Ogre::MaterialPtr( _cpp_this->getShadowReceiverMaterial() ); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* Ogre::MaterialPtr Ogre::Technique::getShadowReceiverMaterial */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setShadowReceiverMaterial()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setShadowReceiverMaterial
 * Signature:  (Ogre_MaterialPtr)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setShadowReceiverMaterial_1_1Ogre_1MaterialPtrv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jlong val
)
{
   // parameter conversions 
  Ogre::MaterialPtr* _cpp_val = reinterpret_cast< Ogre::MaterialPtr* >(val); 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setShadowReceiverMaterial(*_cpp_val);
} /* void Ogre::Technique::setShadowReceiverMaterial */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setShadowReceiverMaterial()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setShadowReceiverMaterial
 * Signature:  (std_string)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setShadowReceiverMaterial_1_1Ogre_1StringR (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jstring name
)
{
   // parameter conversions 
  std::string _cpp_name = ""; org::xbig::jni::to_stdstring(_jni_env_, name, _cpp_name); // calls c-tor only. Not operator= .; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setShadowReceiverMaterial(_cpp_name);
} /* void Ogre::Technique::setShadowReceiverMaterial */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setPointSize()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setPointSize
 * Signature:  (float)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setPointSize_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jfloat ps
)
{
   // parameter conversions 
  float _cpp_ps = ps; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setPointSize(_cpp_ps);
} /* void Ogre::Technique::setPointSize */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setAmbient()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setAmbient
 * Signature:  (floatfloatfloat)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setAmbient_1_1RealvRealvRealv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jfloat red, 
  jfloat green, 
  jfloat blue
)
{
   // parameter conversions 
  float _cpp_red = red;
  float _cpp_green = green;
  float _cpp_blue = blue; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setAmbient(_cpp_red, _cpp_green, _cpp_blue);
} /* void Ogre::Technique::setAmbient */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setAmbient()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setAmbient
 * Signature:  (Ogre_ColourValue)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setAmbient_1_1ColourValueR (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jlong ambient
)
{
   // parameter conversions 
  const Ogre::ColourValue* _cpp_ambient = reinterpret_cast< const Ogre::ColourValue* >(ambient); 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setAmbient(*_cpp_ambient);
} /* void Ogre::Technique::setAmbient */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setDiffuse()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setDiffuse
 * Signature:  (floatfloatfloatfloat)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setDiffuse_1_1RealvRealvRealvRealv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jfloat red, 
  jfloat green, 
  jfloat blue, 
  jfloat alpha
)
{
   // parameter conversions 
  float _cpp_red = red;
  float _cpp_green = green;
  float _cpp_blue = blue;
  float _cpp_alpha = alpha; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setDiffuse(_cpp_red, _cpp_green, _cpp_blue, _cpp_alpha);
} /* void Ogre::Technique::setDiffuse */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setDiffuse()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setDiffuse
 * Signature:  (Ogre_ColourValue)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setDiffuse_1_1ColourValueR (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jlong diffuse
)
{
   // parameter conversions 
  const Ogre::ColourValue* _cpp_diffuse = reinterpret_cast< const Ogre::ColourValue* >(diffuse); 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setDiffuse(*_cpp_diffuse);
} /* void Ogre::Technique::setDiffuse */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setSpecular()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setSpecular
 * Signature:  (floatfloatfloatfloat)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setSpecular_1_1RealvRealvRealvRealv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jfloat red, 
  jfloat green, 
  jfloat blue, 
  jfloat alpha
)
{
   // parameter conversions 
  float _cpp_red = red;
  float _cpp_green = green;
  float _cpp_blue = blue;
  float _cpp_alpha = alpha; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setSpecular(_cpp_red, _cpp_green, _cpp_blue, _cpp_alpha);
} /* void Ogre::Technique::setSpecular */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setSpecular()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setSpecular
 * Signature:  (Ogre_ColourValue)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setSpecular_1_1ColourValueR (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jlong specular
)
{
   // parameter conversions 
  const Ogre::ColourValue* _cpp_specular = reinterpret_cast< const Ogre::ColourValue* >(specular); 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setSpecular(*_cpp_specular);
} /* void Ogre::Technique::setSpecular */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setShininess()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setShininess
 * Signature:  (float)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setShininess_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jfloat val
)
{
   // parameter conversions 
  float _cpp_val = val; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setShininess(_cpp_val);
} /* void Ogre::Technique::setShininess */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setSelfIllumination()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setSelfIllumination
 * Signature:  (floatfloatfloat)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setSelfIllumination_1_1RealvRealvRealv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jfloat red, 
  jfloat green, 
  jfloat blue
)
{
   // parameter conversions 
  float _cpp_red = red;
  float _cpp_green = green;
  float _cpp_blue = blue; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setSelfIllumination(_cpp_red, _cpp_green, _cpp_blue);
} /* void Ogre::Technique::setSelfIllumination */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setSelfIllumination()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setSelfIllumination
 * Signature:  (Ogre_ColourValue)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setSelfIllumination_1_1ColourValueR (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jlong selfIllum
)
{
   // parameter conversions 
  const Ogre::ColourValue* _cpp_selfIllum = reinterpret_cast< const Ogre::ColourValue* >(selfIllum); 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setSelfIllumination(*_cpp_selfIllum);
} /* void Ogre::Technique::setSelfIllumination */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setDepthCheckEnabled()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setDepthCheckEnabled
 * Signature:  (Z)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setDepthCheckEnabled_1_1bv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jboolean enabled
)
{
   // parameter conversions 
  bool _cpp_enabled = enabled ? true : false; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setDepthCheckEnabled(_cpp_enabled);
} /* void Ogre::Technique::setDepthCheckEnabled */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setDepthWriteEnabled()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setDepthWriteEnabled
 * Signature:  (Z)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setDepthWriteEnabled_1_1bv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jboolean enabled
)
{
   // parameter conversions 
  bool _cpp_enabled = enabled ? true : false; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setDepthWriteEnabled(_cpp_enabled);
} /* void Ogre::Technique::setDepthWriteEnabled */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setDepthFunction()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setDepthFunction
 * Signature:  (Ogre_CompareFunction)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setDepthFunction_1_1CompareFunctionv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jint func
)
{
   // parameter conversions 
  Ogre::CompareFunction _cpp_func = (Ogre::CompareFunction)func; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setDepthFunction(_cpp_func);
} /* void Ogre::Technique::setDepthFunction */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setColourWriteEnabled()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setColourWriteEnabled
 * Signature:  (Z)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setColourWriteEnabled_1_1bv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jboolean enabled
)
{
   // parameter conversions 
  bool _cpp_enabled = enabled ? true : false; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setColourWriteEnabled(_cpp_enabled);
} /* void Ogre::Technique::setColourWriteEnabled */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setCullingMode()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setCullingMode
 * Signature:  (Ogre_CullingMode)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setCullingMode_1_1CullingModev (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jint mode
)
{
   // parameter conversions 
  Ogre::CullingMode _cpp_mode = (Ogre::CullingMode)mode; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setCullingMode(_cpp_mode);
} /* void Ogre::Technique::setCullingMode */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setManualCullingMode()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setManualCullingMode
 * Signature:  (Ogre_ManualCullingMode)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setManualCullingMode_1_1ManualCullingModev (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jint mode
)
{
   // parameter conversions 
  Ogre::ManualCullingMode _cpp_mode = (Ogre::ManualCullingMode)mode; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setManualCullingMode(_cpp_mode);
} /* void Ogre::Technique::setManualCullingMode */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setLightingEnabled()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setLightingEnabled
 * Signature:  (Z)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setLightingEnabled_1_1bv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jboolean enabled
)
{
   // parameter conversions 
  bool _cpp_enabled = enabled ? true : false; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setLightingEnabled(_cpp_enabled);
} /* void Ogre::Technique::setLightingEnabled */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setShadingMode()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setShadingMode
 * Signature:  (Ogre_ShadeOptions)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setShadingMode_1_1ShadeOptionsv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jint mode
)
{
   // parameter conversions 
  Ogre::ShadeOptions _cpp_mode = (Ogre::ShadeOptions)mode; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setShadingMode(_cpp_mode);
} /* void Ogre::Technique::setShadingMode */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setFog()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setFog
 * Signature:  (ZOgre_FogModeOgre_ColourValuefloatfloatfloat)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setFog_1_1bvFogModevColourValueRRealvRealvRealv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jboolean overrideScene, 
  jint mode, 
  jlong colour, 
  jfloat expDensity, 
  jfloat linearStart, 
  jfloat linearEnd
)
{
   // parameter conversions 
  bool _cpp_overrideScene = overrideScene ? true : false;
  Ogre::FogMode _cpp_mode = (Ogre::FogMode)mode;
  const Ogre::ColourValue* _cpp_colour = reinterpret_cast< const Ogre::ColourValue* >(colour);
  float _cpp_expDensity = expDensity;
  float _cpp_linearStart = linearStart;
  float _cpp_linearEnd = linearEnd; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setFog(_cpp_overrideScene, _cpp_mode, *_cpp_colour, _cpp_expDensity, _cpp_linearStart, _cpp_linearEnd);
} /* void Ogre::Technique::setFog */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setDepthBias()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setDepthBias
 * Signature:  (FF)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setDepthBias_1_1FvFv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jfloat constantBias, 
  jfloat slopeScaleBias
)
{
   // parameter conversions 
  float _cpp_constantBias = constantBias;
  float _cpp_slopeScaleBias = slopeScaleBias; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setDepthBias(_cpp_constantBias, _cpp_slopeScaleBias);
} /* void Ogre::Technique::setDepthBias */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setTextureFiltering()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setTextureFiltering
 * Signature:  (Ogre_TextureFilterOptions)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setTextureFiltering_1_1TextureFilterOptionsv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jint filterType
)
{
   // parameter conversions 
  Ogre::TextureFilterOptions _cpp_filterType = (Ogre::TextureFilterOptions)filterType; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setTextureFiltering(_cpp_filterType);
} /* void Ogre::Technique::setTextureFiltering */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setTextureAnisotropy()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setTextureAnisotropy
 * Signature:  (I)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setTextureAnisotropy_1_1Iv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jlong maxAniso
)
{
   // parameter conversions 
  unsigned int _cpp_maxAniso = maxAniso; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setTextureAnisotropy(_cpp_maxAniso);
} /* void Ogre::Technique::setTextureAnisotropy */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setSceneBlending()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setSceneBlending
 * Signature:  (Ogre_SceneBlendType)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setSceneBlending_1_1SceneBlendTypeV (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jint sbt
)
{
   // parameter conversions 
  const Ogre::SceneBlendType _cpp_sbt = (Ogre::SceneBlendType)sbt; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setSceneBlending(_cpp_sbt);
} /* void Ogre::Technique::setSceneBlending */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setSeparateSceneBlending()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setSeparateSceneBlending
 * Signature:  (Ogre_SceneBlendTypeOgre_SceneBlendType)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setSeparateSceneBlending_1_1SceneBlendTypeVSceneBlendTypeV (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jint sbt, 
  jint sbta
)
{
   // parameter conversions 
  const Ogre::SceneBlendType _cpp_sbt = (Ogre::SceneBlendType)sbt;
  const Ogre::SceneBlendType _cpp_sbta = (Ogre::SceneBlendType)sbta; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setSeparateSceneBlending(_cpp_sbt, _cpp_sbta);
} /* void Ogre::Technique::setSeparateSceneBlending */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setSceneBlending()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setSceneBlending
 * Signature:  (Ogre_SceneBlendFactorOgre_SceneBlendFactor)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setSceneBlending_1_1SceneBlendFactorVSceneBlendFactorV (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jint sourceFactor, 
  jint destFactor
)
{
   // parameter conversions 
  const Ogre::SceneBlendFactor _cpp_sourceFactor = (Ogre::SceneBlendFactor)sourceFactor;
  const Ogre::SceneBlendFactor _cpp_destFactor = (Ogre::SceneBlendFactor)destFactor; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setSceneBlending(_cpp_sourceFactor, _cpp_destFactor);
} /* void Ogre::Technique::setSceneBlending */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setSeparateSceneBlending()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setSeparateSceneBlending
 * Signature:  (Ogre_SceneBlendFactorOgre_SceneBlendFactorOgre_SceneBlendFactorOgre_SceneBlendFactor)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setSeparateSceneBlending_1_1SceneBlendFactorVSceneBlendFactorVSceneBlendFactorVSceneBlendFactorV (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jint sourceFactor, 
  jint destFactor, 
  jint sourceFactorAlpha, 
  jint destFactorAlpha
)
{
   // parameter conversions 
  const Ogre::SceneBlendFactor _cpp_sourceFactor = (Ogre::SceneBlendFactor)sourceFactor;
  const Ogre::SceneBlendFactor _cpp_destFactor = (Ogre::SceneBlendFactor)destFactor;
  const Ogre::SceneBlendFactor _cpp_sourceFactorAlpha = (Ogre::SceneBlendFactor)sourceFactorAlpha;
  const Ogre::SceneBlendFactor _cpp_destFactorAlpha = (Ogre::SceneBlendFactor)destFactorAlpha; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setSeparateSceneBlending(_cpp_sourceFactor, _cpp_destFactor, _cpp_sourceFactorAlpha, _cpp_destFactorAlpha);
} /* void Ogre::Technique::setSeparateSceneBlending */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setLodIndex()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setLodIndex
 * Signature:  (S)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setLodIndex_1_1Hv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jint index
)
{
   // parameter conversions 
  unsigned short _cpp_index = index; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setLodIndex(_cpp_index);
} /* void Ogre::Technique::setLodIndex */


/*
 * Class:      org.ogre4j.Technique
 * Method:     getLodIndex()
 * Type:       non-virtual method
 * Definition: unsigned short Ogre::Technique::getLodIndex
 * Signature:  ()S
 */

JNIEXPORT jint JNICALL Java_org_ogre4j_Technique__1getLodIndex_1const (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   const Ogre::Technique* _cpp_this = reinterpret_cast<const Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const unsigned short _cpp_result = _cpp_this->getLodIndex() ; 
   return _cpp_result;
} /* unsigned short Ogre::Technique::getLodIndex */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setSchemeName()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setSchemeName
 * Signature:  (std_string)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setSchemeName_1_1StringR (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jstring schemeName
)
{
   // parameter conversions 
  std::string _cpp_schemeName = ""; org::xbig::jni::to_stdstring(_jni_env_, schemeName, _cpp_schemeName); // calls c-tor only. Not operator= .; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setSchemeName(_cpp_schemeName);
} /* void Ogre::Technique::setSchemeName */


/*
 * Class:      org.ogre4j.Technique
 * Method:     getSchemeName()
 * Type:       non-virtual method
 * Definition: const String& Ogre::Technique::getSchemeName
 * Signature:  ()std_string
 */

JNIEXPORT jstring JNICALL Java_org_ogre4j_Technique__1getSchemeName_1const (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   const Ogre::Technique* _cpp_this = reinterpret_cast<const Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   std::string _cpp_result = _cpp_this->getSchemeName() ; 
   return org::xbig::jni::to_jstring(_jni_env_, _cpp_result);
} /* const String& Ogre::Technique::getSchemeName */


/*
 * Class:      org.ogre4j.Technique
 * Method:     _getSchemeIndex()
 * Type:       non-virtual method
 * Definition: unsigned short Ogre::Technique::_getSchemeIndex
 * Signature:  ()S
 */

JNIEXPORT jint JNICALL Java_org_ogre4j_Technique__1_1getSchemeIndex_1const (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   const Ogre::Technique* _cpp_this = reinterpret_cast<const Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const unsigned short _cpp_result = _cpp_this->_getSchemeIndex() ; 
   return _cpp_result;
} /* unsigned short Ogre::Technique::_getSchemeIndex */


/*
 * Class:      org.ogre4j.Technique
 * Method:     isDepthWriteEnabled()
 * Type:       non-virtual method
 * Definition: bool Ogre::Technique::isDepthWriteEnabled
 * Signature:  ()Z
 */

JNIEXPORT jboolean JNICALL Java_org_ogre4j_Technique__1isDepthWriteEnabled_1const (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   const Ogre::Technique* _cpp_this = reinterpret_cast<const Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const bool _cpp_result = _cpp_this->isDepthWriteEnabled() ; 
   return _cpp_result ? 1 : 0;
} /* bool Ogre::Technique::isDepthWriteEnabled */


/*
 * Class:      org.ogre4j.Technique
 * Method:     isDepthCheckEnabled()
 * Type:       non-virtual method
 * Definition: bool Ogre::Technique::isDepthCheckEnabled
 * Signature:  ()Z
 */

JNIEXPORT jboolean JNICALL Java_org_ogre4j_Technique__1isDepthCheckEnabled_1const (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   const Ogre::Technique* _cpp_this = reinterpret_cast<const Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const bool _cpp_result = _cpp_this->isDepthCheckEnabled() ; 
   return _cpp_result ? 1 : 0;
} /* bool Ogre::Technique::isDepthCheckEnabled */


/*
 * Class:      org.ogre4j.Technique
 * Method:     hasColourWriteDisabled()
 * Type:       non-virtual method
 * Definition: bool Ogre::Technique::hasColourWriteDisabled
 * Signature:  ()Z
 */

JNIEXPORT jboolean JNICALL Java_org_ogre4j_Technique__1hasColourWriteDisabled_1const (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   const Ogre::Technique* _cpp_this = reinterpret_cast<const Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const bool _cpp_result = _cpp_this->hasColourWriteDisabled() ; 
   return _cpp_result ? 1 : 0;
} /* bool Ogre::Technique::hasColourWriteDisabled */


/*
 * Class:      org.ogre4j.Technique
 * Method:     setName()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::setName
 * Signature:  (std_string)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1setName_1_1StringR (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jstring name
)
{
   // parameter conversions 
  std::string _cpp_name = ""; org::xbig::jni::to_stdstring(_jni_env_, name, _cpp_name); // calls c-tor only. Not operator= .; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->setName(_cpp_name);
} /* void Ogre::Technique::setName */


/*
 * Class:      org.ogre4j.Technique
 * Method:     getName()
 * Type:       non-virtual method
 * Definition: const String& Ogre::Technique::getName
 * Signature:  ()std_string
 */

JNIEXPORT jstring JNICALL Java_org_ogre4j_Technique__1getName_1const (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   const Ogre::Technique* _cpp_this = reinterpret_cast<const Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   std::string _cpp_result = _cpp_this->getName() ; 
   return org::xbig::jni::to_jstring(_jni_env_, _cpp_result);
} /* const String& Ogre::Technique::getName */


/*
 * Class:      org.ogre4j.Technique
 * Method:     applyTextureAliases()
 * Type:       non-virtual method
 * Definition: bool Ogre::Technique::applyTextureAliases
 * Signature:  (Ogre_AliasTextureNamePairListZ)Z
 */

JNIEXPORT jboolean JNICALL Java_org_ogre4j_Technique__1applyTextureAliases_1_1AliasTextureNamePairListRbV_1const (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jlong aliasList, 
  jboolean apply
)
{
   // parameter conversions 
  const Ogre::AliasTextureNamePairList* _cpp_aliasList = reinterpret_cast< const Ogre::AliasTextureNamePairList* >(aliasList);
  const bool _cpp_apply = apply ? true : false; 
   
   // cast pointer to C++ object 
   const Ogre::Technique* _cpp_this = reinterpret_cast<const Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const bool _cpp_result = _cpp_this->applyTextureAliases(*_cpp_aliasList, _cpp_apply) ; 
   return _cpp_result ? 1 : 0;
} /* bool Ogre::Technique::applyTextureAliases */


/*
 * Class:      org.ogre4j.Technique
 * Method:     addGPUVendorRule()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::addGPUVendorRule
 * Signature:  (Ogre_GPUVendorOgre_Technique_IncludeOrExclude)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1addGPUVendorRule_1_1GPUVendorvIncludeOrExcludev (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jint vendor, 
  jint includeOrExclude
)
{
   // parameter conversions 
  Ogre::GPUVendor _cpp_vendor = (Ogre::GPUVendor)vendor;
  Ogre::Technique::IncludeOrExclude _cpp_includeOrExclude = (Ogre::Technique::IncludeOrExclude)includeOrExclude; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->addGPUVendorRule(_cpp_vendor, _cpp_includeOrExclude);
} /* void Ogre::Technique::addGPUVendorRule */


/*
 * Class:      org.ogre4j.Technique
 * Method:     addGPUVendorRule()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::addGPUVendorRule
 * Signature:  (Ogre_Technique_GPUVendorRule)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1addGPUVendorRule_1_1GPUVendorRuleR (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jlong rule
)
{
   // parameter conversions 
  const Ogre::Technique::GPUVendorRule* _cpp_rule = reinterpret_cast< const Ogre::Technique::GPUVendorRule* >(rule); 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->addGPUVendorRule(*_cpp_rule);
} /* void Ogre::Technique::addGPUVendorRule */


/*
 * Class:      org.ogre4j.Technique
 * Method:     removeGPUVendorRule()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::removeGPUVendorRule
 * Signature:  (Ogre_GPUVendor)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1removeGPUVendorRule_1_1GPUVendorv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jint vendor
)
{
   // parameter conversions 
  Ogre::GPUVendor _cpp_vendor = (Ogre::GPUVendor)vendor; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->removeGPUVendorRule(_cpp_vendor);
} /* void Ogre::Technique::removeGPUVendorRule */


/*
 * Class:      org.ogre4j.Technique
 * Method:     getGPUVendorRuleIterator()
 * Type:       non-virtual method
 * Definition: GPUVendorRuleIterator Ogre::Technique::getGPUVendorRuleIterator
 * Signature:  ()Ogre_Technique_GPUVendorRuleIterator
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Technique__1getGPUVendorRuleIterator_1const (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   const Ogre::Technique* _cpp_this = reinterpret_cast<const Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const Ogre::Technique::GPUVendorRuleIterator* _cpp_result = new Ogre::Technique::GPUVendorRuleIterator( _cpp_this->getGPUVendorRuleIterator() ); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* GPUVendorRuleIterator Ogre::Technique::getGPUVendorRuleIterator */


/*
 * Class:      org.ogre4j.Technique
 * Method:     addGPUDeviceNameRule()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::addGPUDeviceNameRule
 * Signature:  (std_stringOgre_Technique_IncludeOrExcludeZ)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1addGPUDeviceNameRule_1_1StringRIncludeOrExcludevbv (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jstring devicePattern, 
  jint includeOrExclude, 
  jboolean caseSensitive
)
{
   // parameter conversions 
  std::string _cpp_devicePattern = ""; org::xbig::jni::to_stdstring(_jni_env_, devicePattern, _cpp_devicePattern); // calls c-tor only. Not operator= .;
  Ogre::Technique::IncludeOrExclude _cpp_includeOrExclude = (Ogre::Technique::IncludeOrExclude)includeOrExclude;
  bool _cpp_caseSensitive = caseSensitive ? true : false; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->addGPUDeviceNameRule(_cpp_devicePattern, _cpp_includeOrExclude, _cpp_caseSensitive);
} /* void Ogre::Technique::addGPUDeviceNameRule */


/*
 * Class:      org.ogre4j.Technique
 * Method:     addGPUDeviceNameRule()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::addGPUDeviceNameRule
 * Signature:  (Ogre_Technique_GPUDeviceNameRule)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1addGPUDeviceNameRule_1_1GPUDeviceNameRuleR (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jlong rule
)
{
   // parameter conversions 
  const Ogre::Technique::GPUDeviceNameRule* _cpp_rule = reinterpret_cast< const Ogre::Technique::GPUDeviceNameRule* >(rule); 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->addGPUDeviceNameRule(*_cpp_rule);
} /* void Ogre::Technique::addGPUDeviceNameRule */


/*
 * Class:      org.ogre4j.Technique
 * Method:     removeGPUDeviceNameRule()
 * Type:       non-virtual method
 * Definition: void Ogre::Technique::removeGPUDeviceNameRule
 * Signature:  (std_string)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1removeGPUDeviceNameRule_1_1StringR (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_, /* C++ pointer */
  jstring devicePattern
)
{
   // parameter conversions 
  std::string _cpp_devicePattern = ""; org::xbig::jni::to_stdstring(_jni_env_, devicePattern, _cpp_devicePattern); // calls c-tor only. Not operator= .; 
   
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   _cpp_this->removeGPUDeviceNameRule(_cpp_devicePattern);
} /* void Ogre::Technique::removeGPUDeviceNameRule */


/*
 * Class:      org.ogre4j.Technique
 * Method:     getGPUDeviceNameRuleIterator()
 * Type:       non-virtual method
 * Definition: GPUDeviceNameRuleIterator Ogre::Technique::getGPUDeviceNameRuleIterator
 * Signature:  ()Ogre_Technique_GPUDeviceNameRuleIterator
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Technique__1getGPUDeviceNameRuleIterator_1const (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // parameter conversions 
   
   // cast pointer to C++ object 
   const Ogre::Technique* _cpp_this = reinterpret_cast<const Ogre::Technique*>(_jni_pointer_); 
   
   // call library method 
   const Ogre::Technique::GPUDeviceNameRuleIterator* _cpp_result = new Ogre::Technique::GPUDeviceNameRuleIterator( _cpp_this->getGPUDeviceNameRuleIterator() ); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* GPUDeviceNameRuleIterator Ogre::Technique::getGPUDeviceNameRuleIterator */


/*
 * Class:      org.ogre4j.Technique
 * Method:     __delete()
 * Type:       destructor
 * Definition: Ogre::Technique::__delete
 * Signature:  ()V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Technique__1_1delete (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // destructor of class Ogre::Technique 
   // cast pointer to C++ object 
   Ogre::Technique* _cpp_this = reinterpret_cast<Ogre::Technique*>(_jni_pointer_); 
   // delete object if it exists 
   if(_cpp_this != NULL) delete _cpp_this;
} /* Ogre::Technique::__delete */
