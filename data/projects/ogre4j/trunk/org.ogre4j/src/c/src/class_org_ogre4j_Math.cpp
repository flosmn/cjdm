///////////////////////////////////////////////////////////////////////////////
/// This source file is generated by XBiG (The XSLT Bindings Generator)
/// For the latest info, see http://sourceforge.net/projects/xbig/
///
/// Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
/// Also see acknowledgements in Readme.html
///
/// This program is free software; you can redistribute it and/or modify it under
/// the terms of the GNU Lesser General Public License as published by the Free Software
/// Foundation; either version 2 of the License, or (at your option) any later
/// version.
///
/// This program is distributed in the hope that it will be useful, but WITHOUT
/// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
/// FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
///
/// You should have received a copy of the GNU Lesser General Public License along with
/// this program; if not, write to the Free Software Foundation, Inc., 59 Temple
/// Place - Suite 330, Boston, MA 02111-1307, USA, or go to
/// http://www.gnu.org/copyleft/lesser.txt.
///
/// Machine generated file
///////////////////////////////////////////////////////////////////////////////



#ifdef WIN32
	// disable warnings
	#pragma warning (disable : 4267) // conversion from 'size_t' to 'jint'
#else

#endif


// includes from config
#include <Ogre4JStableHeaders.h>

// use base library for cpp2j
#include "jni_base_all.h"

// import declaration of all functions
#include "class_org_ogre4j_Math.h"

// import header files of original library
#include <OgreMath.h>



/*
 * Class:      org.ogre4j.Math
 * Method:     Math()
 * Type:       constructor
 * Definition: Ogre::Math::Math
 * Signature:  (I)V
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1_1createMath_1_1Iv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong trigTableSize
)
{
   // constructor of class Ogre::Math 
   
   // parameter conversions 
  unsigned int _cpp_trigTableSize = trigTableSize; 
   
   // create new instance of class Ogre::Math 
   Ogre::Math* _cpp_this = new Ogre::Math(_cpp_trigTableSize); 
   
   // return casted pointer 
   jlong _jni_pointer_ = reinterpret_cast<jlong>(_cpp_this); 
   return _jni_pointer_;
} /* Ogre::Math::Math */


/*
 * Class:      org.ogre4j.Math
 * Method:     IAbs()
 * Type:       static method
 * Definition: static int Ogre::Math::IAbs
 * Signature:  (I)I
 */

JNIEXPORT jint JNICALL Java_org_ogre4j_Math__1IAbs_1_1iv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jint iValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  int _cpp_iValue = iValue; 
   
   // call library method 
   const int _cpp_result = Ogre::Math::IAbs(_cpp_iValue); 
   return _cpp_result;
} /* static int Ogre::Math::IAbs */


/*
 * Class:      org.ogre4j.Math
 * Method:     ICeil()
 * Type:       static method
 * Definition: static int Ogre::Math::ICeil
 * Signature:  (F)I
 */

JNIEXPORT jint JNICALL Java_org_ogre4j_Math__1ICeil_1_1Fv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fValue = fValue; 
   
   // call library method 
   const int _cpp_result = Ogre::Math::ICeil(_cpp_fValue); 
   return _cpp_result;
} /* static int Ogre::Math::ICeil */


/*
 * Class:      org.ogre4j.Math
 * Method:     IFloor()
 * Type:       static method
 * Definition: static int Ogre::Math::IFloor
 * Signature:  (F)I
 */

JNIEXPORT jint JNICALL Java_org_ogre4j_Math__1IFloor_1_1Fv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fValue = fValue; 
   
   // call library method 
   const int _cpp_result = Ogre::Math::IFloor(_cpp_fValue); 
   return _cpp_result;
} /* static int Ogre::Math::IFloor */


/*
 * Class:      org.ogre4j.Math
 * Method:     ISign()
 * Type:       static method
 * Definition: static int Ogre::Math::ISign
 * Signature:  (I)I
 */

JNIEXPORT jint JNICALL Java_org_ogre4j_Math__1ISign_1_1iv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jint iValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  int _cpp_iValue = iValue; 
   
   // call library method 
   const int _cpp_result = Ogre::Math::ISign(_cpp_iValue); 
   return _cpp_result;
} /* static int Ogre::Math::ISign */


/*
 * Class:      org.ogre4j.Math
 * Method:     Abs()
 * Type:       static method
 * Definition: static Real Ogre::Math::Abs
 * Signature:  (float)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1Abs_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fValue = fValue; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::Abs(_cpp_fValue); 
   return _cpp_result;
} /* static Real Ogre::Math::Abs */


/*
 * Class:      org.ogre4j.Math
 * Method:     Abs()
 * Type:       static method
 * Definition: static Degree Ogre::Math::Abs
 * Signature:  (Ogre_Degree)Ogre_Degree
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1Abs_1_1DegreeR (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong dValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Degree* _cpp_dValue = reinterpret_cast< const Ogre::Degree* >(dValue); 
   
   // call library method 
   const Ogre::Degree* _cpp_result = new Ogre::Degree( Ogre::Math::Abs(*_cpp_dValue)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static Degree Ogre::Math::Abs */


/*
 * Class:      org.ogre4j.Math
 * Method:     Abs()
 * Type:       static method
 * Definition: static Radian Ogre::Math::Abs
 * Signature:  (Ogre_Radian)Ogre_Radian
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1Abs_1_1RadianR (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong rValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Radian* _cpp_rValue = reinterpret_cast< const Ogre::Radian* >(rValue); 
   
   // call library method 
   const Ogre::Radian* _cpp_result = new Ogre::Radian( Ogre::Math::Abs(*_cpp_rValue)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static Radian Ogre::Math::Abs */


/*
 * Class:      org.ogre4j.Math
 * Method:     ACos()
 * Type:       static method
 * Definition: static Radian Ogre::Math::ACos
 * Signature:  (float)Ogre_Radian
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1ACos_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fValue = fValue; 
   
   // call library method 
   const Ogre::Radian* _cpp_result = new Ogre::Radian( Ogre::Math::ACos(_cpp_fValue)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static Radian Ogre::Math::ACos */


/*
 * Class:      org.ogre4j.Math
 * Method:     ASin()
 * Type:       static method
 * Definition: static Radian Ogre::Math::ASin
 * Signature:  (float)Ogre_Radian
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1ASin_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fValue = fValue; 
   
   // call library method 
   const Ogre::Radian* _cpp_result = new Ogre::Radian( Ogre::Math::ASin(_cpp_fValue)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static Radian Ogre::Math::ASin */


/*
 * Class:      org.ogre4j.Math
 * Method:     ATan()
 * Type:       static method
 * Definition: static Radian Ogre::Math::ATan
 * Signature:  (float)Ogre_Radian
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1ATan_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fValue = fValue; 
   
   // call library method 
   const Ogre::Radian* _cpp_result = new Ogre::Radian( Ogre::Math::ATan(_cpp_fValue)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static Radian Ogre::Math::ATan */


/*
 * Class:      org.ogre4j.Math
 * Method:     ATan2()
 * Type:       static method
 * Definition: static Radian Ogre::Math::ATan2
 * Signature:  (floatfloat)Ogre_Radian
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1ATan2_1_1RealvRealv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fY, 
  jfloat fX
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fY = fY;
  float _cpp_fX = fX; 
   
   // call library method 
   const Ogre::Radian* _cpp_result = new Ogre::Radian( Ogre::Math::ATan2(_cpp_fY, _cpp_fX)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static Radian Ogre::Math::ATan2 */


/*
 * Class:      org.ogre4j.Math
 * Method:     Ceil()
 * Type:       static method
 * Definition: static Real Ogre::Math::Ceil
 * Signature:  (float)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1Ceil_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fValue = fValue; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::Ceil(_cpp_fValue); 
   return _cpp_result;
} /* static Real Ogre::Math::Ceil */


/*
 * Class:      org.ogre4j.Math
 * Method:     Cos()
 * Type:       static method
 * Definition: static Real Ogre::Math::Cos
 * Signature:  (Ogre_RadianZ)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1Cos_1_1RadianRbv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong fValue, 
  jboolean useTables
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Radian* _cpp_fValue = reinterpret_cast< const Ogre::Radian* >(fValue);
  bool _cpp_useTables = useTables ? true : false; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::Cos(*_cpp_fValue, _cpp_useTables); 
   return _cpp_result;
} /* static Real Ogre::Math::Cos */


/*
 * Class:      org.ogre4j.Math
 * Method:     Cos()
 * Type:       static method
 * Definition: static Real Ogre::Math::Cos
 * Signature:  (floatZ)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1Cos_1_1Realvbv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fValue, 
  jboolean useTables
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fValue = fValue;
  bool _cpp_useTables = useTables ? true : false; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::Cos(_cpp_fValue, _cpp_useTables); 
   return _cpp_result;
} /* static Real Ogre::Math::Cos */


/*
 * Class:      org.ogre4j.Math
 * Method:     Exp()
 * Type:       static method
 * Definition: static Real Ogre::Math::Exp
 * Signature:  (float)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1Exp_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fValue = fValue; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::Exp(_cpp_fValue); 
   return _cpp_result;
} /* static Real Ogre::Math::Exp */


/*
 * Class:      org.ogre4j.Math
 * Method:     Floor()
 * Type:       static method
 * Definition: static Real Ogre::Math::Floor
 * Signature:  (float)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1Floor_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fValue = fValue; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::Floor(_cpp_fValue); 
   return _cpp_result;
} /* static Real Ogre::Math::Floor */


/*
 * Class:      org.ogre4j.Math
 * Method:     Log()
 * Type:       static method
 * Definition: static Real Ogre::Math::Log
 * Signature:  (float)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1Log_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fValue = fValue; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::Log(_cpp_fValue); 
   return _cpp_result;
} /* static Real Ogre::Math::Log */


/*
 * Class:      org.ogre4j.Math
 * Method:     Pow()
 * Type:       static method
 * Definition: static Real Ogre::Math::Pow
 * Signature:  (floatfloat)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1Pow_1_1RealvRealv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fBase, 
  jfloat fExponent
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fBase = fBase;
  float _cpp_fExponent = fExponent; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::Pow(_cpp_fBase, _cpp_fExponent); 
   return _cpp_result;
} /* static Real Ogre::Math::Pow */


/*
 * Class:      org.ogre4j.Math
 * Method:     Sign()
 * Type:       static method
 * Definition: static Real Ogre::Math::Sign
 * Signature:  (float)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1Sign_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fValue = fValue; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::Sign(_cpp_fValue); 
   return _cpp_result;
} /* static Real Ogre::Math::Sign */


/*
 * Class:      org.ogre4j.Math
 * Method:     Sign()
 * Type:       static method
 * Definition: static Radian Ogre::Math::Sign
 * Signature:  (Ogre_Radian)Ogre_Radian
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1Sign_1_1RadianR (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong rValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Radian* _cpp_rValue = reinterpret_cast< const Ogre::Radian* >(rValue); 
   
   // call library method 
   const Ogre::Radian* _cpp_result = new Ogre::Radian( Ogre::Math::Sign(*_cpp_rValue)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static Radian Ogre::Math::Sign */


/*
 * Class:      org.ogre4j.Math
 * Method:     Sign()
 * Type:       static method
 * Definition: static Degree Ogre::Math::Sign
 * Signature:  (Ogre_Degree)Ogre_Degree
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1Sign_1_1DegreeR (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong dValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Degree* _cpp_dValue = reinterpret_cast< const Ogre::Degree* >(dValue); 
   
   // call library method 
   const Ogre::Degree* _cpp_result = new Ogre::Degree( Ogre::Math::Sign(*_cpp_dValue)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static Degree Ogre::Math::Sign */


/*
 * Class:      org.ogre4j.Math
 * Method:     Sin()
 * Type:       static method
 * Definition: static Real Ogre::Math::Sin
 * Signature:  (Ogre_RadianZ)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1Sin_1_1RadianRbv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong fValue, 
  jboolean useTables
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Radian* _cpp_fValue = reinterpret_cast< const Ogre::Radian* >(fValue);
  bool _cpp_useTables = useTables ? true : false; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::Sin(*_cpp_fValue, _cpp_useTables); 
   return _cpp_result;
} /* static Real Ogre::Math::Sin */


/*
 * Class:      org.ogre4j.Math
 * Method:     Sin()
 * Type:       static method
 * Definition: static Real Ogre::Math::Sin
 * Signature:  (floatZ)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1Sin_1_1Realvbv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fValue, 
  jboolean useTables
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fValue = fValue;
  bool _cpp_useTables = useTables ? true : false; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::Sin(_cpp_fValue, _cpp_useTables); 
   return _cpp_result;
} /* static Real Ogre::Math::Sin */


/*
 * Class:      org.ogre4j.Math
 * Method:     Sqr()
 * Type:       static method
 * Definition: static Real Ogre::Math::Sqr
 * Signature:  (float)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1Sqr_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fValue = fValue; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::Sqr(_cpp_fValue); 
   return _cpp_result;
} /* static Real Ogre::Math::Sqr */


/*
 * Class:      org.ogre4j.Math
 * Method:     Sqrt()
 * Type:       static method
 * Definition: static Real Ogre::Math::Sqrt
 * Signature:  (float)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1Sqrt_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fValue = fValue; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::Sqrt(_cpp_fValue); 
   return _cpp_result;
} /* static Real Ogre::Math::Sqrt */


/*
 * Class:      org.ogre4j.Math
 * Method:     Sqrt()
 * Type:       static method
 * Definition: static Radian Ogre::Math::Sqrt
 * Signature:  (Ogre_Radian)Ogre_Radian
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1Sqrt_1_1RadianR (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong fValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Radian* _cpp_fValue = reinterpret_cast< const Ogre::Radian* >(fValue); 
   
   // call library method 
   const Ogre::Radian* _cpp_result = new Ogre::Radian( Ogre::Math::Sqrt(*_cpp_fValue)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static Radian Ogre::Math::Sqrt */


/*
 * Class:      org.ogre4j.Math
 * Method:     Sqrt()
 * Type:       static method
 * Definition: static Degree Ogre::Math::Sqrt
 * Signature:  (Ogre_Degree)Ogre_Degree
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1Sqrt_1_1DegreeR (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong fValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Degree* _cpp_fValue = reinterpret_cast< const Ogre::Degree* >(fValue); 
   
   // call library method 
   const Ogre::Degree* _cpp_result = new Ogre::Degree( Ogre::Math::Sqrt(*_cpp_fValue)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static Degree Ogre::Math::Sqrt */


/*
 * Class:      org.ogre4j.Math
 * Method:     InvSqrt()
 * Type:       static method
 * Definition: static Real Ogre::Math::InvSqrt
 * Signature:  (float)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1InvSqrt_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fValue
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fValue = fValue; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::InvSqrt(_cpp_fValue); 
   return _cpp_result;
} /* static Real Ogre::Math::InvSqrt */


/*
 * Class:      org.ogre4j.Math
 * Method:     UnitRandom()
 * Type:       static method
 * Definition: static Real Ogre::Math::UnitRandom
 * Signature:  ()float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1UnitRandom (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_  /* class pointer */
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
   
   // call library method 
   const float _cpp_result = Ogre::Math::UnitRandom(); 
   return _cpp_result;
} /* static Real Ogre::Math::UnitRandom */


/*
 * Class:      org.ogre4j.Math
 * Method:     RangeRandom()
 * Type:       static method
 * Definition: static Real Ogre::Math::RangeRandom
 * Signature:  (floatfloat)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1RangeRandom_1_1RealvRealv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fLow, 
  jfloat fHigh
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fLow = fLow;
  float _cpp_fHigh = fHigh; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::RangeRandom(_cpp_fLow, _cpp_fHigh); 
   return _cpp_result;
} /* static Real Ogre::Math::RangeRandom */


/*
 * Class:      org.ogre4j.Math
 * Method:     SymmetricRandom()
 * Type:       static method
 * Definition: static Real Ogre::Math::SymmetricRandom
 * Signature:  ()float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1SymmetricRandom (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_  /* class pointer */
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
   
   // call library method 
   const float _cpp_result = Ogre::Math::SymmetricRandom(); 
   return _cpp_result;
} /* static Real Ogre::Math::SymmetricRandom */


/*
 * Class:      org.ogre4j.Math
 * Method:     Tan()
 * Type:       static method
 * Definition: static Real Ogre::Math::Tan
 * Signature:  (Ogre_RadianZ)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1Tan_1_1RadianRbv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong fValue, 
  jboolean useTables
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Radian* _cpp_fValue = reinterpret_cast< const Ogre::Radian* >(fValue);
  bool _cpp_useTables = useTables ? true : false; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::Tan(*_cpp_fValue, _cpp_useTables); 
   return _cpp_result;
} /* static Real Ogre::Math::Tan */


/*
 * Class:      org.ogre4j.Math
 * Method:     Tan()
 * Type:       static method
 * Definition: static Real Ogre::Math::Tan
 * Signature:  (floatZ)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1Tan_1_1Realvbv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat fValue, 
  jboolean useTables
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_fValue = fValue;
  bool _cpp_useTables = useTables ? true : false; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::Tan(_cpp_fValue, _cpp_useTables); 
   return _cpp_result;
} /* static Real Ogre::Math::Tan */


/*
 * Class:      org.ogre4j.Math
 * Method:     DegreesToRadians()
 * Type:       static method
 * Definition: static Real Ogre::Math::DegreesToRadians
 * Signature:  (float)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1DegreesToRadians_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat degrees
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_degrees = degrees; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::DegreesToRadians(_cpp_degrees); 
   return _cpp_result;
} /* static Real Ogre::Math::DegreesToRadians */


/*
 * Class:      org.ogre4j.Math
 * Method:     RadiansToDegrees()
 * Type:       static method
 * Definition: static Real Ogre::Math::RadiansToDegrees
 * Signature:  (float)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1RadiansToDegrees_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat radians
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_radians = radians; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::RadiansToDegrees(_cpp_radians); 
   return _cpp_result;
} /* static Real Ogre::Math::RadiansToDegrees */


/*
 * Class:      org.ogre4j.Math
 * Method:     setAngleUnit()
 * Type:       static method
 * Definition: static void Ogre::Math::setAngleUnit
 * Signature:  (Ogre_Math_AngleUnit)V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Math__1setAngleUnit_1_1AngleUnitv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jint unit
)
{
   // static method of class Ogre::Math without return value 
   // parameter conversions 
  Ogre::Math::AngleUnit _cpp_unit = (Ogre::Math::AngleUnit)unit; 
   
   // call library method 
   Ogre::Math::setAngleUnit(_cpp_unit);
} /* static void Ogre::Math::setAngleUnit */


/*
 * Class:      org.ogre4j.Math
 * Method:     getAngleUnit()
 * Type:       static method
 * Definition: static AngleUnit Ogre::Math::getAngleUnit
 * Signature:  ()Ogre_Math_AngleUnit
 */

JNIEXPORT jint JNICALL Java_org_ogre4j_Math__1getAngleUnit (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_  /* class pointer */
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
   
   // call library method 
   const Ogre::Math::AngleUnit _cpp_result = Ogre::Math::getAngleUnit(); 
   return _cpp_result;
} /* static AngleUnit Ogre::Math::getAngleUnit */


/*
 * Class:      org.ogre4j.Math
 * Method:     AngleUnitsToRadians()
 * Type:       static method
 * Definition: static Real Ogre::Math::AngleUnitsToRadians
 * Signature:  (float)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1AngleUnitsToRadians_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat units
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_units = units; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::AngleUnitsToRadians(_cpp_units); 
   return _cpp_result;
} /* static Real Ogre::Math::AngleUnitsToRadians */


/*
 * Class:      org.ogre4j.Math
 * Method:     RadiansToAngleUnits()
 * Type:       static method
 * Definition: static Real Ogre::Math::RadiansToAngleUnits
 * Signature:  (float)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1RadiansToAngleUnits_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat radians
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_radians = radians; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::RadiansToAngleUnits(_cpp_radians); 
   return _cpp_result;
} /* static Real Ogre::Math::RadiansToAngleUnits */


/*
 * Class:      org.ogre4j.Math
 * Method:     AngleUnitsToDegrees()
 * Type:       static method
 * Definition: static Real Ogre::Math::AngleUnitsToDegrees
 * Signature:  (float)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1AngleUnitsToDegrees_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat units
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_units = units; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::AngleUnitsToDegrees(_cpp_units); 
   return _cpp_result;
} /* static Real Ogre::Math::AngleUnitsToDegrees */


/*
 * Class:      org.ogre4j.Math
 * Method:     DegreesToAngleUnits()
 * Type:       static method
 * Definition: static Real Ogre::Math::DegreesToAngleUnits
 * Signature:  (float)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1DegreesToAngleUnits_1_1Realv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat degrees
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_degrees = degrees; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::DegreesToAngleUnits(_cpp_degrees); 
   return _cpp_result;
} /* static Real Ogre::Math::DegreesToAngleUnits */


/*
 * Class:      org.ogre4j.Math
 * Method:     pointInTri2D()
 * Type:       static method
 * Definition: static bool Ogre::Math::pointInTri2D
 * Signature:  (Ogre_Vector2Ogre_Vector2Ogre_Vector2Ogre_Vector2)Z
 */

JNIEXPORT jboolean JNICALL Java_org_ogre4j_Math__1pointInTri2D_1_1Vector2RVector2RVector2RVector2R (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong p, 
  jlong a, 
  jlong b, 
  jlong c
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Vector2* _cpp_p = reinterpret_cast< const Ogre::Vector2* >(p);
  const Ogre::Vector2* _cpp_a = reinterpret_cast< const Ogre::Vector2* >(a);
  const Ogre::Vector2* _cpp_b = reinterpret_cast< const Ogre::Vector2* >(b);
  const Ogre::Vector2* _cpp_c = reinterpret_cast< const Ogre::Vector2* >(c); 
   
   // call library method 
   const bool _cpp_result = Ogre::Math::pointInTri2D(*_cpp_p, *_cpp_a, *_cpp_b, *_cpp_c); 
   return _cpp_result ? 1 : 0;
} /* static bool Ogre::Math::pointInTri2D */


/*
 * Class:      org.ogre4j.Math
 * Method:     pointInTri3D()
 * Type:       static method
 * Definition: static bool Ogre::Math::pointInTri3D
 * Signature:  (Ogre_Vector3Ogre_Vector3Ogre_Vector3Ogre_Vector3Ogre_Vector3)Z
 */

JNIEXPORT jboolean JNICALL Java_org_ogre4j_Math__1pointInTri3D_1_1Vector3RVector3RVector3RVector3RVector3R (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong p, 
  jlong a, 
  jlong b, 
  jlong c, 
  jlong normal
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Vector3* _cpp_p = reinterpret_cast< const Ogre::Vector3* >(p);
  const Ogre::Vector3* _cpp_a = reinterpret_cast< const Ogre::Vector3* >(a);
  const Ogre::Vector3* _cpp_b = reinterpret_cast< const Ogre::Vector3* >(b);
  const Ogre::Vector3* _cpp_c = reinterpret_cast< const Ogre::Vector3* >(c);
  const Ogre::Vector3* _cpp_normal = reinterpret_cast< const Ogre::Vector3* >(normal); 
   
   // call library method 
   const bool _cpp_result = Ogre::Math::pointInTri3D(*_cpp_p, *_cpp_a, *_cpp_b, *_cpp_c, *_cpp_normal); 
   return _cpp_result ? 1 : 0;
} /* static bool Ogre::Math::pointInTri3D */


/*
 * Class:      org.ogre4j.Math
 * Method:     intersects()
 * Type:       static method
 * Definition: static std::pair<bool, Real> Ogre::Math::intersects
 * Signature:  (Ogre_RayOgre_Plane)std_pair__bool__Real__
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1intersects_1_1RayRPlaneR (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong ray, 
  jlong plane
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Ray* _cpp_ray = reinterpret_cast< const Ogre::Ray* >(ray);
  const Ogre::Plane* _cpp_plane = reinterpret_cast< const Ogre::Plane* >(plane); 
   
   // call library method 
   const std::pair< bool, float >* _cpp_result = new std::pair< bool, float >( Ogre::Math::intersects(*_cpp_ray, *_cpp_plane)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static std::pair<bool, Real> Ogre::Math::intersects */


/*
 * Class:      org.ogre4j.Math
 * Method:     intersects()
 * Type:       static method
 * Definition: static std::pair<bool, Real> Ogre::Math::intersects
 * Signature:  (Ogre_RayOgre_SphereZ)std_pair__bool__Real__
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1intersects_1_1RayRSphereRbv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong ray, 
  jlong sphere, 
  jboolean discardInside
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Ray* _cpp_ray = reinterpret_cast< const Ogre::Ray* >(ray);
  const Ogre::Sphere* _cpp_sphere = reinterpret_cast< const Ogre::Sphere* >(sphere);
  bool _cpp_discardInside = discardInside ? true : false; 
   
   // call library method 
   const std::pair< bool, float >* _cpp_result = new std::pair< bool, float >( Ogre::Math::intersects(*_cpp_ray, *_cpp_sphere, _cpp_discardInside)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static std::pair<bool, Real> Ogre::Math::intersects */


/*
 * Class:      org.ogre4j.Math
 * Method:     intersects()
 * Type:       static method
 * Definition: static std::pair<bool, Real> Ogre::Math::intersects
 * Signature:  (Ogre_RayOgre_AxisAlignedBox)std_pair__bool__Real__
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1intersects_1_1RayRAxisAlignedBoxR (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong ray, 
  jlong box
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Ray* _cpp_ray = reinterpret_cast< const Ogre::Ray* >(ray);
  const Ogre::AxisAlignedBox* _cpp_box = reinterpret_cast< const Ogre::AxisAlignedBox* >(box); 
   
   // call library method 
   const std::pair< bool, float >* _cpp_result = new std::pair< bool, float >( Ogre::Math::intersects(*_cpp_ray, *_cpp_box)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static std::pair<bool, Real> Ogre::Math::intersects */


/*
 * Class:      org.ogre4j.Math
 * Method:     intersects()
 * Type:       static method
 * Definition: static bool Ogre::Math::intersects
 * Signature:  (Ogre_RayOgre_AxisAlignedBoxfloatfloat)Z
 */

JNIEXPORT jboolean JNICALL Java_org_ogre4j_Math__1intersects_1_1RayRAxisAlignedBoxRRealpRealp (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong ray, 
  jlong box, 
  jlong d1, 
  jlong d2
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Ray* _cpp_ray = reinterpret_cast< const Ogre::Ray* >(ray);
  const Ogre::AxisAlignedBox* _cpp_box = reinterpret_cast< const Ogre::AxisAlignedBox* >(box);
  float* _cpp_d1 = reinterpret_cast<float*>(d1);
  float* _cpp_d2 = reinterpret_cast<float*>(d2); 
   
   // call library method 
   const bool _cpp_result = Ogre::Math::intersects(*_cpp_ray, *_cpp_box, _cpp_d1, _cpp_d2); 
   return _cpp_result ? 1 : 0;
} /* static bool Ogre::Math::intersects */


/*
 * Class:      org.ogre4j.Math
 * Method:     intersects()
 * Type:       static method
 * Definition: static std::pair<bool, Real> Ogre::Math::intersects
 * Signature:  (Ogre_RayOgre_Vector3Ogre_Vector3Ogre_Vector3Ogre_Vector3ZZ)std_pair__bool__Real__
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1intersects_1_1RayRVector3RVector3RVector3RVector3Rbvbv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong ray, 
  jlong a, 
  jlong b, 
  jlong c, 
  jlong normal, 
  jboolean positiveSide, 
  jboolean negativeSide
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Ray* _cpp_ray = reinterpret_cast< const Ogre::Ray* >(ray);
  const Ogre::Vector3* _cpp_a = reinterpret_cast< const Ogre::Vector3* >(a);
  const Ogre::Vector3* _cpp_b = reinterpret_cast< const Ogre::Vector3* >(b);
  const Ogre::Vector3* _cpp_c = reinterpret_cast< const Ogre::Vector3* >(c);
  const Ogre::Vector3* _cpp_normal = reinterpret_cast< const Ogre::Vector3* >(normal);
  bool _cpp_positiveSide = positiveSide ? true : false;
  bool _cpp_negativeSide = negativeSide ? true : false; 
   
   // call library method 
   const std::pair< bool, float >* _cpp_result = new std::pair< bool, float >( Ogre::Math::intersects(*_cpp_ray, *_cpp_a, *_cpp_b, *_cpp_c, *_cpp_normal, _cpp_positiveSide, _cpp_negativeSide)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static std::pair<bool, Real> Ogre::Math::intersects */


/*
 * Class:      org.ogre4j.Math
 * Method:     intersects()
 * Type:       static method
 * Definition: static std::pair<bool, Real> Ogre::Math::intersects
 * Signature:  (Ogre_RayOgre_Vector3Ogre_Vector3Ogre_Vector3ZZ)std_pair__bool__Real__
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1intersects_1_1RayRVector3RVector3RVector3Rbvbv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong ray, 
  jlong a, 
  jlong b, 
  jlong c, 
  jboolean positiveSide, 
  jboolean negativeSide
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Ray* _cpp_ray = reinterpret_cast< const Ogre::Ray* >(ray);
  const Ogre::Vector3* _cpp_a = reinterpret_cast< const Ogre::Vector3* >(a);
  const Ogre::Vector3* _cpp_b = reinterpret_cast< const Ogre::Vector3* >(b);
  const Ogre::Vector3* _cpp_c = reinterpret_cast< const Ogre::Vector3* >(c);
  bool _cpp_positiveSide = positiveSide ? true : false;
  bool _cpp_negativeSide = negativeSide ? true : false; 
   
   // call library method 
   const std::pair< bool, float >* _cpp_result = new std::pair< bool, float >( Ogre::Math::intersects(*_cpp_ray, *_cpp_a, *_cpp_b, *_cpp_c, _cpp_positiveSide, _cpp_negativeSide)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static std::pair<bool, Real> Ogre::Math::intersects */


/*
 * Class:      org.ogre4j.Math
 * Method:     intersects()
 * Type:       static method
 * Definition: static bool Ogre::Math::intersects
 * Signature:  (Ogre_SphereOgre_AxisAlignedBox)Z
 */

JNIEXPORT jboolean JNICALL Java_org_ogre4j_Math__1intersects_1_1SphereRAxisAlignedBoxR (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong sphere, 
  jlong box
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Sphere* _cpp_sphere = reinterpret_cast< const Ogre::Sphere* >(sphere);
  const Ogre::AxisAlignedBox* _cpp_box = reinterpret_cast< const Ogre::AxisAlignedBox* >(box); 
   
   // call library method 
   const bool _cpp_result = Ogre::Math::intersects(*_cpp_sphere, *_cpp_box); 
   return _cpp_result ? 1 : 0;
} /* static bool Ogre::Math::intersects */


/*
 * Class:      org.ogre4j.Math
 * Method:     intersects()
 * Type:       static method
 * Definition: static bool Ogre::Math::intersects
 * Signature:  (Ogre_PlaneOgre_AxisAlignedBox)Z
 */

JNIEXPORT jboolean JNICALL Java_org_ogre4j_Math__1intersects_1_1PlaneRAxisAlignedBoxR (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong plane, 
  jlong box
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Plane* _cpp_plane = reinterpret_cast< const Ogre::Plane* >(plane);
  const Ogre::AxisAlignedBox* _cpp_box = reinterpret_cast< const Ogre::AxisAlignedBox* >(box); 
   
   // call library method 
   const bool _cpp_result = Ogre::Math::intersects(*_cpp_plane, *_cpp_box); 
   return _cpp_result ? 1 : 0;
} /* static bool Ogre::Math::intersects */


/*
 * Class:      org.ogre4j.Math
 * Method:     intersects()
 * Type:       static method
 * Definition: static std::pair<bool, Real> Ogre::Math::intersects
 * Signature:  (Ogre_Raystd_vector__Plane__Z)std_pair__bool__Real__
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1intersects_1_1RayRstd_1vector_1_1Plane_1_1rbv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong ray, 
  jlong planeList, 
  jboolean normalIsOutside
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Ray* _cpp_ray = reinterpret_cast< const Ogre::Ray* >(ray);
  std::vector< Ogre::Plane >* _cpp_planeList = reinterpret_cast< std::vector< Ogre::Plane >* >(planeList);
  bool _cpp_normalIsOutside = normalIsOutside ? true : false; 
   
   // call library method 
   const std::pair< bool, float >* _cpp_result = new std::pair< bool, float >( Ogre::Math::intersects(*_cpp_ray, *_cpp_planeList, _cpp_normalIsOutside)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static std::pair<bool, Real> Ogre::Math::intersects */


/*
 * Class:      org.ogre4j.Math
 * Method:     intersects()
 * Type:       static method
 * Definition: static std::pair<bool, Real> Ogre::Math::intersects
 * Signature:  (Ogre_Raystd_list__Plane__Z)std_pair__bool__Real__
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1intersects_1_1RayRstd_1list_1_1Plane_1_1rbv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong ray, 
  jlong planeList, 
  jboolean normalIsOutside
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Ray* _cpp_ray = reinterpret_cast< const Ogre::Ray* >(ray);
  std::list< Ogre::Plane >* _cpp_planeList = reinterpret_cast< std::list< Ogre::Plane >* >(planeList);
  bool _cpp_normalIsOutside = normalIsOutside ? true : false; 
   
   // call library method 
   const std::pair< bool, float >* _cpp_result = new std::pair< bool, float >( Ogre::Math::intersects(*_cpp_ray, *_cpp_planeList, _cpp_normalIsOutside)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static std::pair<bool, Real> Ogre::Math::intersects */


/*
 * Class:      org.ogre4j.Math
 * Method:     intersects()
 * Type:       static method
 * Definition: static bool Ogre::Math::intersects
 * Signature:  (Ogre_SphereOgre_Plane)Z
 */

JNIEXPORT jboolean JNICALL Java_org_ogre4j_Math__1intersects_1_1SphereRPlaneR (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong sphere, 
  jlong plane
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Sphere* _cpp_sphere = reinterpret_cast< const Ogre::Sphere* >(sphere);
  const Ogre::Plane* _cpp_plane = reinterpret_cast< const Ogre::Plane* >(plane); 
   
   // call library method 
   const bool _cpp_result = Ogre::Math::intersects(*_cpp_sphere, *_cpp_plane); 
   return _cpp_result ? 1 : 0;
} /* static bool Ogre::Math::intersects */


/*
 * Class:      org.ogre4j.Math
 * Method:     RealEqual()
 * Type:       static method
 * Definition: static bool Ogre::Math::RealEqual
 * Signature:  (floatfloatfloat)Z
 */

JNIEXPORT jboolean JNICALL Java_org_ogre4j_Math__1RealEqual_1_1RealvRealvRealv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat a, 
  jfloat b, 
  jfloat tolerance
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_a = a;
  float _cpp_b = b;
  float _cpp_tolerance = tolerance; 
   
   // call library method 
   const bool _cpp_result = Ogre::Math::RealEqual(_cpp_a, _cpp_b, _cpp_tolerance); 
   return _cpp_result ? 1 : 0;
} /* static bool Ogre::Math::RealEqual */


/*
 * Class:      org.ogre4j.Math
 * Method:     calculateTangentSpaceVector()
 * Type:       static method
 * Definition: static Vector3 Ogre::Math::calculateTangentSpaceVector
 * Signature:  (Ogre_Vector3Ogre_Vector3Ogre_Vector3floatfloatfloatfloatfloatfloat)Ogre_Vector3
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1calculateTangentSpaceVector_1_1Vector3RVector3RVector3RRealvRealvRealvRealvRealvRealv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong position1, 
  jlong position2, 
  jlong position3, 
  jfloat u1, 
  jfloat v1, 
  jfloat u2, 
  jfloat v2, 
  jfloat u3, 
  jfloat v3
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Vector3* _cpp_position1 = reinterpret_cast< const Ogre::Vector3* >(position1);
  const Ogre::Vector3* _cpp_position2 = reinterpret_cast< const Ogre::Vector3* >(position2);
  const Ogre::Vector3* _cpp_position3 = reinterpret_cast< const Ogre::Vector3* >(position3);
  float _cpp_u1 = u1;
  float _cpp_v1 = v1;
  float _cpp_u2 = u2;
  float _cpp_v2 = v2;
  float _cpp_u3 = u3;
  float _cpp_v3 = v3; 
   
   // call library method 
   const Ogre::Vector3* _cpp_result = new Ogre::Vector3( Ogre::Math::calculateTangentSpaceVector(*_cpp_position1, *_cpp_position2, *_cpp_position3, _cpp_u1, _cpp_v1, _cpp_u2, _cpp_v2, _cpp_u3, _cpp_v3)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static Vector3 Ogre::Math::calculateTangentSpaceVector */


/*
 * Class:      org.ogre4j.Math
 * Method:     buildReflectionMatrix()
 * Type:       static method
 * Definition: static Matrix4 Ogre::Math::buildReflectionMatrix
 * Signature:  (Ogre_Plane)Ogre_Matrix4
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1buildReflectionMatrix_1_1PlaneR (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong p
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Plane* _cpp_p = reinterpret_cast< const Ogre::Plane* >(p); 
   
   // call library method 
   const Ogre::Matrix4* _cpp_result = new Ogre::Matrix4( Ogre::Math::buildReflectionMatrix(*_cpp_p)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static Matrix4 Ogre::Math::buildReflectionMatrix */


/*
 * Class:      org.ogre4j.Math
 * Method:     calculateFaceNormal()
 * Type:       static method
 * Definition: static Vector4 Ogre::Math::calculateFaceNormal
 * Signature:  (Ogre_Vector3Ogre_Vector3Ogre_Vector3)Ogre_Vector4
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1calculateFaceNormal_1_1Vector3RVector3RVector3R (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong v1, 
  jlong v2, 
  jlong v3
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Vector3* _cpp_v1 = reinterpret_cast< const Ogre::Vector3* >(v1);
  const Ogre::Vector3* _cpp_v2 = reinterpret_cast< const Ogre::Vector3* >(v2);
  const Ogre::Vector3* _cpp_v3 = reinterpret_cast< const Ogre::Vector3* >(v3); 
   
   // call library method 
   const Ogre::Vector4* _cpp_result = new Ogre::Vector4( Ogre::Math::calculateFaceNormal(*_cpp_v1, *_cpp_v2, *_cpp_v3)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static Vector4 Ogre::Math::calculateFaceNormal */


/*
 * Class:      org.ogre4j.Math
 * Method:     calculateBasicFaceNormal()
 * Type:       static method
 * Definition: static Vector3 Ogre::Math::calculateBasicFaceNormal
 * Signature:  (Ogre_Vector3Ogre_Vector3Ogre_Vector3)Ogre_Vector3
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1calculateBasicFaceNormal_1_1Vector3RVector3RVector3R (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong v1, 
  jlong v2, 
  jlong v3
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Vector3* _cpp_v1 = reinterpret_cast< const Ogre::Vector3* >(v1);
  const Ogre::Vector3* _cpp_v2 = reinterpret_cast< const Ogre::Vector3* >(v2);
  const Ogre::Vector3* _cpp_v3 = reinterpret_cast< const Ogre::Vector3* >(v3); 
   
   // call library method 
   const Ogre::Vector3* _cpp_result = new Ogre::Vector3( Ogre::Math::calculateBasicFaceNormal(*_cpp_v1, *_cpp_v2, *_cpp_v3)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static Vector3 Ogre::Math::calculateBasicFaceNormal */


/*
 * Class:      org.ogre4j.Math
 * Method:     calculateFaceNormalWithoutNormalize()
 * Type:       static method
 * Definition: static Vector4 Ogre::Math::calculateFaceNormalWithoutNormalize
 * Signature:  (Ogre_Vector3Ogre_Vector3Ogre_Vector3)Ogre_Vector4
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1calculateFaceNormalWithoutNormalize_1_1Vector3RVector3RVector3R (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong v1, 
  jlong v2, 
  jlong v3
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Vector3* _cpp_v1 = reinterpret_cast< const Ogre::Vector3* >(v1);
  const Ogre::Vector3* _cpp_v2 = reinterpret_cast< const Ogre::Vector3* >(v2);
  const Ogre::Vector3* _cpp_v3 = reinterpret_cast< const Ogre::Vector3* >(v3); 
   
   // call library method 
   const Ogre::Vector4* _cpp_result = new Ogre::Vector4( Ogre::Math::calculateFaceNormalWithoutNormalize(*_cpp_v1, *_cpp_v2, *_cpp_v3)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static Vector4 Ogre::Math::calculateFaceNormalWithoutNormalize */


/*
 * Class:      org.ogre4j.Math
 * Method:     calculateBasicFaceNormalWithoutNormalize()
 * Type:       static method
 * Definition: static Vector3 Ogre::Math::calculateBasicFaceNormalWithoutNormalize
 * Signature:  (Ogre_Vector3Ogre_Vector3Ogre_Vector3)Ogre_Vector3
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1calculateBasicFaceNormalWithoutNormalize_1_1Vector3RVector3RVector3R (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong v1, 
  jlong v2, 
  jlong v3
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Vector3* _cpp_v1 = reinterpret_cast< const Ogre::Vector3* >(v1);
  const Ogre::Vector3* _cpp_v2 = reinterpret_cast< const Ogre::Vector3* >(v2);
  const Ogre::Vector3* _cpp_v3 = reinterpret_cast< const Ogre::Vector3* >(v3); 
   
   // call library method 
   const Ogre::Vector3* _cpp_result = new Ogre::Vector3( Ogre::Math::calculateBasicFaceNormalWithoutNormalize(*_cpp_v1, *_cpp_v2, *_cpp_v3)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static Vector3 Ogre::Math::calculateBasicFaceNormalWithoutNormalize */


/*
 * Class:      org.ogre4j.Math
 * Method:     gaussianDistribution()
 * Type:       static method
 * Definition: static Real Ogre::Math::gaussianDistribution
 * Signature:  (floatfloatfloat)float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1gaussianDistribution_1_1RealvRealvRealv (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jfloat x, 
  jfloat offset, 
  jfloat scale
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  float _cpp_x = x;
  float _cpp_offset = offset;
  float _cpp_scale = scale; 
   
   // call library method 
   const float _cpp_result = Ogre::Math::gaussianDistribution(_cpp_x, _cpp_offset, _cpp_scale); 
   return _cpp_result;
} /* static Real Ogre::Math::gaussianDistribution */


/*
 * Class:      org.ogre4j.Math
 * Method:     makeViewMatrix()
 * Type:       static method
 * Definition: static Matrix4 Ogre::Math::makeViewMatrix
 * Signature:  (Ogre_Vector3Ogre_QuaternionOgre_Matrix4)Ogre_Matrix4
 */

JNIEXPORT jlong JNICALL Java_org_ogre4j_Math__1makeViewMatrix_1_1Vector3RQuaternionRMatrix4P (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_,  /* class pointer */
  jlong position, 
  jlong orientation, 
  jlong reflectMatrix
)
{
   // static method of class Ogre::Math with return value 
   // parameter conversions 
  const Ogre::Vector3* _cpp_position = reinterpret_cast< const Ogre::Vector3* >(position);
  const Ogre::Quaternion* _cpp_orientation = reinterpret_cast< const Ogre::Quaternion* >(orientation);
  const Ogre::Matrix4* _cpp_reflectMatrix = reinterpret_cast< const Ogre::Matrix4* >(reflectMatrix); 
   
   // call library method 
   const Ogre::Matrix4* _cpp_result = new Ogre::Matrix4( Ogre::Math::makeViewMatrix(*_cpp_position, *_cpp_orientation, _cpp_reflectMatrix)); 
   return reinterpret_cast<jlong>(_cpp_result);
} /* static Matrix4 Ogre::Math::makeViewMatrix */


/*
 * Class:      org.ogre4j.Math
 * Method:     __delete()
 * Type:       destructor
 * Definition: Ogre::Math::__delete
 * Signature:  ()V
 */

JNIEXPORT void JNICALL Java_org_ogre4j_Math__1_1delete (
  JNIEnv* _jni_env_, /* interface pointer */
  jobject _jni_this_, /* Java object */
  jlong _jni_pointer_ /* C++ pointer */
)
{
   // destructor of class Ogre::Math 
   // cast pointer to C++ object 
   Ogre::Math* _cpp_this = reinterpret_cast<Ogre::Math*>(_jni_pointer_); 
   // delete object if it exists 
   if(_cpp_this != NULL) delete _cpp_this;
} /* Ogre::Math::__delete */


/*
 * Class:      org.ogre4j.Math
 * Method:     getPOS_INFINITY()
 * Type:       getter for public attribute
 * Definition: const Real Ogre::Math::POS_INFINITY
 * Signature:  ()float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1getPOS_1INFINITY (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_  /* class pointer */
)
{
   // parameter conversions 
   
   // call library method 
   const float _cpp_result = Ogre::Math::POS_INFINITY ; 
   return _cpp_result;
} /* const Real Ogre::Math::POS_INFINITY */


/*
 * Class:      org.ogre4j.Math
 * Method:     getNEG_INFINITY()
 * Type:       getter for public attribute
 * Definition: const Real Ogre::Math::NEG_INFINITY
 * Signature:  ()float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1getNEG_1INFINITY (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_  /* class pointer */
)
{
   // parameter conversions 
   
   // call library method 
   const float _cpp_result = Ogre::Math::NEG_INFINITY ; 
   return _cpp_result;
} /* const Real Ogre::Math::NEG_INFINITY */


/*
 * Class:      org.ogre4j.Math
 * Method:     getPI()
 * Type:       getter for public attribute
 * Definition: const Real Ogre::Math::PI
 * Signature:  ()float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1getPI (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_  /* class pointer */
)
{
   // parameter conversions 
   
   // call library method 
   const float _cpp_result = Ogre::Math::PI ; 
   return _cpp_result;
} /* const Real Ogre::Math::PI */


/*
 * Class:      org.ogre4j.Math
 * Method:     getTWO_PI()
 * Type:       getter for public attribute
 * Definition: const Real Ogre::Math::TWO_PI
 * Signature:  ()float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1getTWO_1PI (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_  /* class pointer */
)
{
   // parameter conversions 
   
   // call library method 
   const float _cpp_result = Ogre::Math::TWO_PI ; 
   return _cpp_result;
} /* const Real Ogre::Math::TWO_PI */


/*
 * Class:      org.ogre4j.Math
 * Method:     getHALF_PI()
 * Type:       getter for public attribute
 * Definition: const Real Ogre::Math::HALF_PI
 * Signature:  ()float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1getHALF_1PI (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_  /* class pointer */
)
{
   // parameter conversions 
   
   // call library method 
   const float _cpp_result = Ogre::Math::HALF_PI ; 
   return _cpp_result;
} /* const Real Ogre::Math::HALF_PI */


/*
 * Class:      org.ogre4j.Math
 * Method:     getfDeg2Rad()
 * Type:       getter for public attribute
 * Definition: const Real Ogre::Math::fDeg2Rad
 * Signature:  ()float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1getfDeg2Rad (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_  /* class pointer */
)
{
   // parameter conversions 
   
   // call library method 
   const float _cpp_result = Ogre::Math::fDeg2Rad ; 
   return _cpp_result;
} /* const Real Ogre::Math::fDeg2Rad */


/*
 * Class:      org.ogre4j.Math
 * Method:     getfRad2Deg()
 * Type:       getter for public attribute
 * Definition: const Real Ogre::Math::fRad2Deg
 * Signature:  ()float
 */

JNIEXPORT jfloat JNICALL Java_org_ogre4j_Math__1getfRad2Deg (
  JNIEnv* _jni_env_, /* interface pointer */
  jclass _jni_class_  /* class pointer */
)
{
   // parameter conversions 
   
   // call library method 
   const float _cpp_result = Ogre::Math::fRad2Deg ; 
   return _cpp_result;
} /* const Real Ogre::Math::fRad2Deg */
