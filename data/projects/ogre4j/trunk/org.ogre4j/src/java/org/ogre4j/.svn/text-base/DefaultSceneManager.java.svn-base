/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class DefaultSceneManager extends org.xbig.base.NativeObject implements org.ogre4j.IDefaultSceneManager {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public DefaultSceneManager(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected DefaultSceneManager(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public DefaultSceneManager(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public DefaultSceneManager(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public String getTypeName() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Return the instance name of this . **/
    public String getName() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Creates a camera to be managed by this scene manager. **/
    public org.ogre4j.ICamera createCamera(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Retrieves a pointer to the named camera. **/
    public org.ogre4j.ICamera getCamera(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns whether a camera with the given name exists. **/
    public boolean hasCamera(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes a camera from the scene. **/
    public void destroyCamera(org.ogre4j.ICamera cam) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes a camera from the scene. **/
    public void destroyCamera(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes (and destroys) all cameras from the scene. **/
    public void destroyAllCameras() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Creates a light for use in the scene. **/
    public org.ogre4j.ILight createLight(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns a pointer to the named  which has previously been added to the scene. **/
    public org.ogre4j.ILight getLight(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns whether a light with the given name exists. **/
    public boolean hasLight(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Retrieve a set of clipping planes for a given light. **/
    public org.ogre4j.IPlaneList getLightClippingPlanes(org.ogre4j.ILight l) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Retrieve a scissor rectangle for a given light and camera. **/
    public org.ogre4j.IRealRect getLightScissorRect(org.ogre4j.ILight l, org.ogre4j.ICamera cam) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes the named light from the scene and destroys it. **/
    public void destroyLight(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes the light from the scene and destroys it based on a pointer. **/
    public void destroyLight(org.ogre4j.ILight light) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes and destroys all lights in the scene. **/
    public void destroyAllLights() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Advance method to increase the lights dirty counter due lights changed. **/
    public void _notifyLightsDirty() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Advance method to gets the lights dirty counter. **/
    public long _getLightsDirtyCounter() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Get the list of lights which could be affecting the frustum. **/
    public org.ogre4j.ILightList _getLightsAffectingFrustum() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Populate a light list with an ordered set of the lights which are closest to the position specified. **/
    public void _populateLightList(org.ogre4j.IVector3 position, float radius, org.ogre4j.ILightList destList) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Creates an instance of a . **/
    public org.ogre4j.ISceneNode createSceneNode() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Creates an instance of a  with a given name. **/
    public org.ogre4j.ISceneNode createSceneNode(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Destroys a  with a given name. **/
    public void destroySceneNode(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Destroys a . **/
    public void destroySceneNode(org.ogre4j.ISceneNode sn) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Gets the  at the root of the scene hierarchy. **/
    public org.ogre4j.ISceneNode getRootSceneNode() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Retrieves a named  from the scene graph. **/
    public org.ogre4j.ISceneNode getSceneNode(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns whether a scene node with the given name exists. **/
    public boolean hasSceneNode(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Create an  (instance of a discrete mesh). **/
    public org.ogre4j.IEntity createEntity(String entityName, String meshName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Create an  (instance of a discrete mesh) from a range of prefab shapes. **/
    public org.ogre4j.IEntity createEntity(String entityName, org.ogre4j.SceneManager.PrefabType ptype) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Retrieves a pointer to the named . **/
    public org.ogre4j.IEntity getEntity(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns whether an entity with the given name exists. **/
    public boolean hasEntity(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes & destroys an  from the . **/
    public void destroyEntity(org.ogre4j.IEntity ent) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes & destroys an  from the  by name. **/
    public void destroyEntity(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes & destroys all Entities. **/
    public void destroyAllEntities() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Create a , an object which you populate with geometry manually through a GL immediate-mode style interface. **/
    public org.ogre4j.IManualObject createManualObject(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Retrieves a pointer to the named . **/
    public org.ogre4j.IManualObject getManualObject(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns whether a manual object with the given name exists. **/
    public boolean hasManualObject(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes & destroys a  from the . **/
    public void destroyManualObject(org.ogre4j.IManualObject obj) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes & destroys a  from the . **/
    public void destroyManualObject(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes & destroys all ManualObjects from the . **/
    public void destroyAllManualObjects() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Create a , an object which you can use to render a linked chain of billboards. **/
    public org.ogre4j.IBillboardChain createBillboardChain(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Retrieves a pointer to the named . **/
    public org.ogre4j.IBillboardChain getBillboardChain(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns whether a billboard chain with the given name exists. **/
    public boolean hasBillboardChain(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes & destroys a  from the . **/
    public void destroyBillboardChain(org.ogre4j.IBillboardChain obj) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes & destroys a  from the . **/
    public void destroyBillboardChain(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes & destroys all BillboardChains from the . **/
    public void destroyAllBillboardChains() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Create a , an object which you can use to render a linked chain of billboards which follows one or more nodes. **/
    public org.ogre4j.IRibbonTrail createRibbonTrail(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Retrieves a pointer to the named . **/
    public org.ogre4j.IRibbonTrail getRibbonTrail(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns whether a ribbon trail with the given name exists. **/
    public boolean hasRibbonTrail(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes & destroys a  from the . **/
    public void destroyRibbonTrail(org.ogre4j.IRibbonTrail obj) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes & destroys a  from the . **/
    public void destroyRibbonTrail(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes & destroys all RibbonTrails from the . **/
    public void destroyAllRibbonTrails() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Creates a particle system based on a template. **/
    public org.ogre4j.IParticleSystem createParticleSystem(String name, String templateName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Create a blank particle system. **/
    public org.ogre4j.IParticleSystem createParticleSystem(String name, int quota, String resourceGroup) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Retrieves a pointer to the named . **/
    public org.ogre4j.IParticleSystem getParticleSystem(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns whether a particle system with the given name exists. **/
    public boolean hasParticleSystem(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes & destroys a  from the . **/
    public void destroyParticleSystem(org.ogre4j.IParticleSystem obj) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes & destroys a  from the . **/
    public void destroyParticleSystem(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes & destroys all ParticleSystems from the . **/
    public void destroyAllParticleSystems() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets etc. Cameras are not deleted at this stage since they are still referenced by viewports, which are not destroyed during this process. **/
    public void clearScene() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets the ambient light level to be used for the scene. **/
    public void setAmbientLight(org.ogre4j.IColourValue colour) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns the ambient light level to be used for the scene. **/
    public org.ogre4j.IColourValue getAmbientLight() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets the source of the 'world' geometry, i.e. the large, mainly static geometry making up the world e.g. rooms, landscape etc. This function can be called before setWorldGeometry in a background thread, do to some slow tasks (e.g. IO) that do not involve the backend render system. **/
    public void prepareWorldGeometry(String filename) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets the source of the 'world' geometry, i.e. the large, mainly static geometry making up the world e.g. rooms, landscape etc. This function can be called before setWorldGeometry in a background thread, do to some slow tasks (e.g. IO) that do not involve the backend render system. **/
    public void prepareWorldGeometry(org.ogre4j.IDataStreamPtr stream, String typeName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets the source of the 'world' geometry, i.e. the large, mainly static geometry making up the world e.g. rooms, landscape etc. **/
    public void setWorldGeometry(String filename) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets the source of the 'world' geometry, i.e. the large, mainly static geometry making up the world e.g. rooms, landscape etc. **/
    public void setWorldGeometry(org.ogre4j.IDataStreamPtr stream, String typeName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Estimate the number of loading stages required to load the named world geometry. **/
    public int estimateWorldGeometry(String filename) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Estimate the number of loading stages required to load the named world geometry. **/
    public int estimateWorldGeometry(org.ogre4j.IDataStreamPtr stream, String typeName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Asks the  to provide a suggested viewpoint from which the scene should be viewed. **/
    public void getSuggestedViewpoint(org.ogre4j.IViewPoint returnValue, boolean random) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Method for setting a specific option of the Scene Manager. These options are usually specific for a certain implemntation of the Scene Manager class, and may (and probably will) not exist across different implementations. **/
    public boolean setOption(String strKey, VoidPointer pValue) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Method for getting the value of an implementation-specific Scene Manager option. **/
    public boolean getOption(String strKey, VoidPointer pDestValue) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Method for verifying wether the scene manager has an implementation-specific option. **/
    public boolean hasOption(String strKey) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Method for getting all possible values for a specific option. When this list is too large (i.e. the option expects, for example, a float), the return value will be true, but the list will contain just one element whose size will be set to 0. Otherwise, the list will be filled with all the possible values the option can accept. **/
    public boolean getOptionValues(String strKey, org.ogre4j.IStringVector refValueList) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Method for getting all the implementation-specific options of the scene manager. **/
    public boolean getOptionKeys(org.ogre4j.IStringVector refKeys) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Internal method for updating the scene graph ie the tree of  instances managed by this class. **/
    public void _updateSceneGraph(org.ogre4j.ICamera cam) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Internal method which parses the scene to find visible objects to render. **/
    public void _findVisibleObjects(org.ogre4j.ICamera cam, org.ogre4j.IVisibleObjectsBoundsInfo visibleBounds, boolean onlyShadowCasters) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Internal method for applying animations to scene nodes. **/
    public void _applySceneAnimations() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sends visible objects found in _findVisibleObjects to the rendering engine. **/
    public void _renderVisibleObjects() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Prompts the class to send its contents to the renderer. **/
    public void _renderScene(org.ogre4j.ICamera camera, org.ogre4j.IViewport vp, boolean includeOverlays) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Internal method for queueing the sky objects with the params as previously set through setSkyBox, setSkyPlane and setSkyDome. **/
    public void _queueSkiesForRendering(org.ogre4j.ICamera cam) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Notifies the scene manager of its destination render system **/
    public void _setDestinationRenderSystem(org.ogre4j.IRenderSystem sys) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. **/
    public void setSkyPlane(boolean enable, org.ogre4j.IPlane plane, String materialName, float scale, float tiling, boolean drawFirst, float bow, int xsegments, int ysegments, String groupName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. **/
    public void _setSkyPlane(boolean enable, org.ogre4j.IPlane plane, String materialName, float scale, float tiling, short renderQueue, float bow, int xsegments, int ysegments, String groupName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Return whether a key plane is enabled **/
    public boolean isSkyPlaneEnabled() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Get the sky plane node, if enabled. **/
    public org.ogre4j.ISceneNode getSkyPlaneNode() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Get the parameters used to construct the SkyPlane, if any **/
    public org.ogre4j.ISceneManager.ISkyPlaneGenParameters getSkyPlaneGenParameters() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Enables / disables a 'sky box' i.e. a 6-sided box at constant distance from the camera representing the sky. **/
    public void setSkyBox(boolean enable, String materialName, float distance, boolean drawFirst, org.ogre4j.IQuaternion orientation, String groupName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Enables / disables a 'sky box' i.e. a 6-sided box at constant distance from the camera representing the sky. **/
    public void _setSkyBox(boolean enable, String materialName, float distance, short renderQueue, org.ogre4j.IQuaternion orientation, String groupName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Return whether a skybox is enabled **/
    public boolean isSkyBoxEnabled() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Get the skybox node, if enabled. **/
    public org.ogre4j.ISceneNode getSkyBoxNode() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Get the parameters used to generate the current SkyBox, if any **/
    public org.ogre4j.ISceneManager.ISkyBoxGenParameters getSkyBoxGenParameters() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Enables / disables a 'sky dome' i.e. an illusion of a curved sky. **/
    public void setSkyDome(boolean enable, String materialName, float curvature, float tiling, float distance, boolean drawFirst, org.ogre4j.IQuaternion orientation, int xsegments, int ysegments, int ysegments_keep, String groupName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Enables / disables a 'sky dome' i.e. an illusion of a curved sky. **/
    public void _setSkyDome(boolean enable, String materialName, float curvature, float tiling, float distance, short renderQueue, org.ogre4j.IQuaternion orientation, int xsegments, int ysegments, int ysegments_keep, String groupName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Return whether a skydome is enabled **/
    public boolean isSkyDomeEnabled() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Get the sky dome node, if enabled. **/
    public org.ogre4j.ISceneNode getSkyDomeNode() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Get the parameters used to generate the current SkyDome, if any **/
    public org.ogre4j.ISceneManager.ISkyDomeGenParameters getSkyDomeGenParameters() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets the fogging mode applied to the scene. **/
    public void setFog(org.ogre4j.FogMode mode, org.ogre4j.IColourValue colour, float expDensity, float linearStart, float linearEnd) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns the fog mode for the scene. **/
    public org.ogre4j.FogMode getFogMode() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns the fog colour for the scene. **/
    public org.ogre4j.IColourValue getFogColour() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns the fog start distance for the scene. **/
    public float getFogStart() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns the fog end distance for the scene. **/
    public float getFogEnd() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns the fog density for the scene. **/
    public float getFogDensity() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Creates a new  for use with this scene manager. **/
    public org.ogre4j.IBillboardSet createBillboardSet(String name, long poolSize) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Retrieves a pointer to the named . **/
    public org.ogre4j.IBillboardSet getBillboardSet(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns whether a billboardset with the given name exists. **/
    public boolean hasBillboardSet(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes & destroys an  from the . **/
    public void destroyBillboardSet(org.ogre4j.IBillboardSet set) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes & destroys an  from the  by name. **/
    public void destroyBillboardSet(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes & destroys all BillboardSets. **/
    public void destroyAllBillboardSets() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Tells the  whether it should render the SceneNodes which make up the scene as well as the objects in the scene. **/
    public void setDisplaySceneNodes(boolean display) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns true if all scene nodes axis are to be displayed **/
    public boolean getDisplaySceneNodes() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Creates an animation which can be used to animate scene nodes. **/
    public org.ogre4j.IAnimation createAnimation(String name, float length) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Looks up an  object previously created with createAnimation. **/
    public org.ogre4j.IAnimation getAnimation(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns whether an animation with the given name exists. **/
    public boolean hasAnimation(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Destroys an . **/
    public void destroyAnimation(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes all animations created using this . **/
    public void destroyAllAnimations() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Create an  object for managing application of animations. **/
    public org.ogre4j.IAnimationState createAnimationState(String animName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Retrieves animation state as previously created using createAnimationState. **/
    public org.ogre4j.IAnimationState getAnimationState(String animName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns whether an animation state with the given name exists. **/
    public boolean hasAnimationState(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Destroys an . **/
    public void destroyAnimationState(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes all animation states created using this . **/
    public void destroyAllAnimationStates() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Manual rendering method, for advanced users only. **/
    public void manualRender(org.ogre4j.IRenderOperation rend, org.ogre4j.IPass pass, org.ogre4j.IViewport vp, org.ogre4j.IMatrix4 worldMatrix, org.ogre4j.IMatrix4 viewMatrix, org.ogre4j.IMatrix4 projMatrix, boolean doBeginEndFrame) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Retrieves the internal render queue, for advanced users only. **/
    public org.ogre4j.IRenderQueue getRenderQueue() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Registers a new  which will be notified when render queues are processed. **/
    public void addRenderQueueListener(org.ogre4j.IRenderQueueListener newListener) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes a listener previously added with addRenderQueueListener. **/
    public void removeRenderQueueListener(org.ogre4j.IRenderQueueListener delListener) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Adds an item to the 'special case' render queue list. **/
    public void addSpecialCaseRenderQueue(short qid) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Removes an item to the 'special case' render queue list. **/
    public void removeSpecialCaseRenderQueue(short qid) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Clears the 'special case' render queue list. **/
    public void clearSpecialCaseRenderQueues() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets the way the special case render queue list is processed. **/
    public void setSpecialCaseRenderQueueMode(org.ogre4j.SceneManager.SpecialCaseRenderQueueMode mode) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Gets the way the special case render queue list is processed. **/
    public org.ogre4j.SceneManager.SpecialCaseRenderQueueMode getSpecialCaseRenderQueueMode() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns whether or not the named queue will be rendered based on the current 'special case' render queue list and mode. **/
    public boolean isRenderQueueToBeProcessed(short qid) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets the render queue that the world geometry (if any) this  renders will be associated with. **/
    public void setWorldGeometryRenderQueue(short qid) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Gets the render queue that the world geometry (if any) this  renders will be associated with. **/
    public short getWorldGeometryRenderQueue() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Allows all bounding boxes of scene nodes to be displayed. **/
    public void showBoundingBoxes(boolean bShow) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns if all bounding boxes of scene nodes are to be displayed **/
    public boolean getShowBoundingBoxes() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Internal method for notifying the manager that a  is autotracking. **/
    public void _notifyAutotrackingSceneNode(org.ogre4j.ISceneNode node, boolean autoTrack) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Creates an  for this scene manager. **/
    public org.ogre4j.IAxisAlignedBoxSceneQuery createAABBQuery(org.ogre4j.IAxisAlignedBox box, long mask) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Creates a  for this scene manager. **/
    public org.ogre4j.ISphereSceneQuery createSphereQuery(org.ogre4j.ISphere sphere, long mask) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Creates a  for this scene manager. **/
    public org.ogre4j.IPlaneBoundedVolumeListSceneQuery createPlaneBoundedVolumeQuery(org.ogre4j.IPlaneBoundedVolumeList volumes, long mask) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Creates a  for this scene manager. **/
    public org.ogre4j.IRaySceneQuery createRayQuery(org.ogre4j.IRay ray, long mask) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Creates an  for this scene manager. **/
    public org.ogre4j.IIntersectionSceneQuery createIntersectionQuery(long mask) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Destroys a scene query of any type. **/
    public void destroyQuery(org.ogre4j.ISceneQuery query) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns a specialised  over all cameras in the scene. **/
    public void getCameraIterator(org.ogre4j.ISceneManager.ICameraIterator returnValue) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns a specialised  over all animations in the scene. **/
    public void getAnimationIterator(org.ogre4j.ISceneManager.IAnimationIterator returnValue) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns a specialised  over all animation states in the scene. **/
    public void getAnimationStateIterator(org.ogre4j.IAnimationStateIterator returnValue) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets the general shadow technique to be used in this scene. **/
    public void setShadowTechnique(org.ogre4j.ShadowTechnique technique) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Gets the current shadow technique. **/
    public org.ogre4j.ShadowTechnique getShadowTechnique() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Enables / disables the rendering of debug information for shadows. **/
    public void setShowDebugShadows(boolean debug) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Are debug shadows shown? **/
    public boolean getShowDebugShadows() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Set the colour used to modulate areas in shadow. **/
    public void setShadowColour(org.ogre4j.IColourValue colour) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Get the colour used to modulate areas in shadow. **/
    public org.ogre4j.IColourValue getShadowColour() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets the distance a shadow volume is extruded for a directional light. **/
    public void setShadowDirectionalLightExtrusionDistance(float dist) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Gets the distance a shadow volume is extruded for a directional light. **/
    public float getShadowDirectionalLightExtrusionDistance() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets the default maximum distance away from the camera that shadows will be visible. You have to call this function before you create lights or the default distance of zero will be used. **/
    public void setShadowFarDistance(float distance) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Gets the default maximum distance away from the camera that shadows will be visible. **/
    public float getShadowFarDistance() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public float getShadowFarDistanceSquared() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets the maximum size of the index buffer used to render shadow primitives. **/
    public void setShadowIndexBufferSize(int size) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public int getShadowIndexBufferSize() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Set the size of the texture used for all texture-based shadows. **/
    public void setShadowTextureSize(int size) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Set the detailed configuration for a shadow texture. **/
    public void setShadowTextureConfig(int shadowIndex, int width, int height, org.ogre4j.PixelFormat format) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Set the detailed configuration for a shadow texture. **/
    public void setShadowTextureConfig(int shadowIndex, org.ogre4j.IShadowTextureConfig config) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Get an iterator over the current shadow texture settings. **/
    public void getShadowTextureConfigIterator(org.ogre4j.IConstShadowTextureConfigIterator returnValue) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Set the pixel format of the textures used for texture-based shadows. **/
    public void setShadowTexturePixelFormat(org.ogre4j.PixelFormat fmt) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Set the number of textures allocated for texture-based shadows. **/
    public void setShadowTextureCount(int count) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public int getShadowTextureCount() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Set the number of shadow textures a light type uses. **/
    public void setShadowTextureCountPerLightType(org.ogre4j.Light.LightTypes type, int count) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public int getShadowTextureCountPerLightType(org.ogre4j.Light.LightTypes type) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets the size and count of textures used in texture-based shadows. **/
    public void setShadowTextureSettings(int size, int count, org.ogre4j.PixelFormat fmt) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Get a reference to the shadow texture currently in use at the given index. **/
    public org.ogre4j.ITexturePtr getShadowTexture(int shadowIndex) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets the proportional distance which a texture shadow which is generated from a directional light will be offset into the camera view to make best use of texture space. **/
    public void setShadowDirLightTextureOffset(float offset) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Gets the proportional distance which a texture shadow which is generated from a directional light will be offset into the camera view to make best use of texture space. **/
    public float getShadowDirLightTextureOffset() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets the proportional distance at which texture shadows begin to fade out. **/
    public void setShadowTextureFadeStart(float fadeStart) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets the proportional distance at which texture shadows finish to fading out. **/
    public void setShadowTextureFadeEnd(float fadeEnd) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets whether or not texture shadows should attempt to self-shadow. **/
    public void setShadowTextureSelfShadow(boolean selfShadow) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public boolean getShadowTextureSelfShadow() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets the default material to use for rendering shadow casters. **/
    public void setShadowTextureCasterMaterial(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets the default material to use for rendering shadow receivers. **/
    public void setShadowTextureReceiverMaterial(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets whether or not shadow casters should be rendered into shadow textures using their back faces rather than their front faces. **/
    public void setShadowCasterRenderBackFaces(boolean bf) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Gets whether or not shadow casters should be rendered into shadow textures using their back faces rather than their front faces. **/
    public boolean getShadowCasterRenderBackFaces() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Set the shadow camera setup to use for all lights which don't have their own shadow camera setup. **/
    public void setShadowCameraSetup(org.ogre4j.IShadowCameraSetupPtr shadowSetup) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Get the shadow camera setup in use for all lights which don't have their own shadow camera setup. **/
    public org.ogre4j.IShadowCameraSetupPtr getShadowCameraSetup() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets whether we should use an inifinite camera far plane when rendering stencil shadows. **/
    public void setShadowUseInfiniteFarPlane(boolean enable) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Is there a stencil shadow based shadowing technique in use? **/
    public boolean isShadowTechniqueStencilBased() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Is there a texture shadow based shadowing technique in use? **/
    public boolean isShadowTechniqueTextureBased() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Is there a modulative shadowing technique in use? **/
    public boolean isShadowTechniqueModulative() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Is there an additive shadowing technique in use? **/
    public boolean isShadowTechniqueAdditive() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Is the shadow technique integrated into primary materials? **/
    public boolean isShadowTechniqueIntegrated() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Is there any shadowing technique in use? **/
    public boolean isShadowTechniqueInUse() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets whether when using a built-in additive shadow mode, user clip planes should be used to restrict light rendering. **/
    public void setShadowUseLightClipPlanes(boolean enabled) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Gets whether when using a built-in additive shadow mode, user clip planes should be used to restrict light rendering. **/
    public boolean getShadowUseLightClipPlanes() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Add a listener which will get called back on scene manager events. **/
    public void addListener(org.ogre4j.ISceneManager.IListener s) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Remove a listener **/
    public void removeListener(org.ogre4j.ISceneManager.IListener s) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Creates a  instance suitable for use with this . **/
    public org.ogre4j.IStaticGeometry createStaticGeometry(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Retrieve a previously created  instance. **/
    public org.ogre4j.IStaticGeometry getStaticGeometry(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns whether a static geometry instance with the given name exists. **/
    public boolean hasStaticGeometry(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Remove & destroy a  instance. **/
    public void destroyStaticGeometry(org.ogre4j.IStaticGeometry geom) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Remove & destroy a  instance. **/
    public void destroyStaticGeometry(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Remove & destroy all  instances. **/
    public void destroyAllStaticGeometry() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Creates a  instance suitable for use with this . **/
    public org.ogre4j.IInstancedGeometry createInstancedGeometry(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Retrieve a previously created  instance. **/
    public org.ogre4j.IInstancedGeometry getInstancedGeometry(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Remove & destroy a  instance. **/
    public void destroyInstancedGeometry(org.ogre4j.IInstancedGeometry geom) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Remove & destroy a  instance. **/
    public void destroyInstancedGeometry(String name) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Remove & destroy all  instances. **/
    public void destroyAllInstancedGeometry() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Create a movable object of the type specified. **/
    public org.ogre4j.IMovableObject createMovableObject(String name, String typeName, org.ogre4j.INameValuePairList params) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Destroys a  with the name specified, of the type specified. **/
    public void destroyMovableObject(String name, String typeName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Destroys a . **/
    public void destroyMovableObject(org.ogre4j.IMovableObject m) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Destroy all MovableObjects of a given type. **/
    public void destroyAllMovableObjectsByType(String typeName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Destroy all MovableObjects. **/
    public void destroyAllMovableObjects() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Get a reference to a previously created . **/
    public org.ogre4j.IMovableObject getMovableObject(String name, String typeName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns whether a movable object instance with the given name exists. **/
    public boolean hasMovableObject(String name, String typeName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Get an iterator over all MovableObect instances of a given type. **/
    public void getMovableObjectIterator(org.ogre4j.ISceneManager.IMovableObjectIterator returnValue, String typeName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Inject a  instance created externally. **/
    public void injectMovableObject(org.ogre4j.IMovableObject m) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Extract a previously injected . **/
    public void extractMovableObject(String name, String typeName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Extract a previously injected . **/
    public void extractMovableObject(org.ogre4j.IMovableObject m) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Extract all injected MovableObjects of a given type. **/
    public void extractAllMovableObjectsByType(String typeName) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets a mask which is bitwise 'and'ed with objects own visibility masks to determine if the object is visible. **/
    public void setVisibilityMask(long vmask) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Gets a mask which is bitwise 'and'ed with objects own visibility masks to determine if the object is visible. **/
    public long getVisibilityMask() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Internal method for getting the combination between the global visibility mask and the per-viewport visibility mask. **/
    public long _getCombinedVisibilityMask() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Sets whether the  should search for visible objects, or whether they are being manually handled. **/
    public void setFindVisibleObjects(boolean find) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Gets whether the  should search for visible objects, or whether they are being manually handled. **/
    public boolean getFindVisibleObjects() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Set whether to automatically normalise normals on objects whenever they are scaled. **/
    public void setNormaliseNormalsOnScale(boolean n) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Get whether to automatically normalise normals on objects whenever they are scaled. **/
    public boolean getNormaliseNormalsOnScale() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Set whether to automatically flip the culling mode on objects whenever they are negatively scaled. **/
    public void setFlipCullingOnNegativeScale(boolean n) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Get whether to automatically flip the culling mode on objects whenever they are negatively scaled. **/
    public boolean getFlipCullingOnNegativeScale() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Render something as if it came from the current queue. **/
    public void _injectRenderWithPass(org.ogre4j.IPass pass, org.ogre4j.IRenderable rend, boolean shadowDerivation) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Indicates to the  whether it should suppress changing the  states when rendering objects. **/
    public void _suppressRenderStateChanges(boolean suppress) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Are render state changes suppressed? **/
    public boolean _areRenderStateChangesSuppressed() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Internal method for setting up the renderstate for a rendering pass. **/
    public org.ogre4j.IPass _setPass(org.ogre4j.IPass pass, boolean evenIfSuppressed, boolean shadowDerivation) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Indicates to the  whether it should suppress the active shadow rendering technique until told otherwise. **/
    public void _suppressShadows(boolean suppress) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Are shadows suppressed? **/
    public boolean _areShadowsSuppressed() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Render the objects in a given queue group **/
    public void _renderQueueGroupObjects(org.ogre4j.IRenderQueueGroup group, org.ogre4j.QueuedRenderableCollection.OrganisationMode om) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Advanced method for supplying an alternative visitor, used for parsing the render queues and sending the results to the renderer. **/
    public void setQueuedRenderableVisitor(org.ogre4j.ISceneManager.ISceneMgrQueuedRenderableVisitor visitor) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Gets the current visitor object which processes queued renderables. **/
    public org.ogre4j.ISceneManager.ISceneMgrQueuedRenderableVisitor getQueuedRenderableVisitor() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Get the rendersystem subclass to which the output of this Scene Manager gets sent **/
    public org.ogre4j.IRenderSystem getDestinationRenderSystem() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Gets the current viewport being rendered (advanced use only, only valid during viewport update. **/
    public org.ogre4j.IViewport getCurrentViewport() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns a visibility boundary box for a specific camera. **/
    public org.ogre4j.IVisibleObjectsBoundsInfo getVisibleObjectsBoundsInfo(org.ogre4j.ICamera cam) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Returns the shadow caster AAB for a specific light-camera combination **/
    public org.ogre4j.IVisibleObjectsBoundsInfo getShadowCasterBoundsInfo(org.ogre4j.ILight light, int iteration) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Set whether to use camera-relative co-ordinates when rendering, ie to always place the camera at the origin and move the world around it. **/
    public void setCameraRelativeRendering(boolean rel) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** 
    Get whether to use camera-relative co-ordinates when rendering, ie to always place the camera at the origin and move the world around it. **/
    public boolean getCameraRelativeRendering() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public static long getWORLD_GEOMETRY_TYPE_MASK() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public static void setWORLD_GEOMETRY_TYPE_MASK(long _jni_value_) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public static long getENTITY_TYPE_MASK() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public static void setENTITY_TYPE_MASK(long _jni_value_) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public static long getFX_TYPE_MASK() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public static void setFX_TYPE_MASK(long _jni_value_) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public static long getSTATICGEOMETRY_TYPE_MASK() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public static void setSTATICGEOMETRY_TYPE_MASK(long _jni_value_) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public static long getLIGHT_TYPE_MASK() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public static void setLIGHT_TYPE_MASK(long _jni_value_) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public static long getFRUSTUM_TYPE_MASK() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public static void setFRUSTUM_TYPE_MASK(long _jni_value_) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public static long getUSER_TYPE_MASK_LIMIT() {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



    /** **/
    public static void setUSER_TYPE_MASK_LIMIT(long _jni_value_) {
            throw new UnsupportedOperationException("This type is on ignore list!");
    }



}
