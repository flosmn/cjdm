/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class CompositorManager extends org.xbig.base.NativeObject implements org.ogre4j.ICompositorManager {
static { System.loadLibrary("ogre4j");}
private static class Chains extends org.xbig.base.NativeObject implements org.ogre4j.ICompositorManager.IChains {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public Chains(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected Chains(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public Chains(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public Chains() {
         super( new org.xbig.base.InstancePointer(__createChains()), false);
    }

    private native static long __createChains();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(org.ogre4j.IViewport key) {
         return _count__Ogre_ViewportP(this.object.pointer, key.getInstancePointer().pointer);
    }

    private native int _count__Ogre_ViewportP(long _pointer_, long key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(org.ogre4j.IViewport key) {
         return _erase__Ogre_ViewportP(this.object.pointer, key.getInstancePointer().pointer);
    }

    private native int _erase__Ogre_ViewportP(long _pointer_, long key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.ICompositorChain get(org.ogre4j.IViewport key) {
         return new org.ogre4j.CompositorChain(new InstancePointer(_get__Ogre_ViewportP(this.object.pointer, key.getInstancePointer().pointer)));
    }

    private native long _get__Ogre_ViewportP(long _pointer_, long key);

    /** **/
    public void insert(org.ogre4j.IViewport key, org.ogre4j.ICompositorChain value) {
        _insert__Ogre_ViewportPOgre_CompositorChainp(this.object.pointer, key.getInstancePointer().pointer,  value.getInstancePointer().pointer);
    }

    private native void _insert__Ogre_ViewportPOgre_CompositorChainp(long _pointer_, long key, long value);

}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public CompositorManager(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected CompositorManager(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public CompositorManager(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public CompositorManager() {
         super( new org.xbig.base.InstancePointer(__createCompositorManager()), false);
    }

    private native static long __createCompositorManager();

    /** **/
    public org.ogre4j.IResource createImpl(String name, long handle, String group, boolean isManual, org.ogre4j.IManualResourceLoader loader, org.ogre4j.INameValuePairList params) {
         return new org.ogre4j.Resource(new InstancePointer(_createImpl__StringRResourceHandlevStringRbvManualResourceLoaderpNameValuePairListP(this.object.pointer, name,  handle,  group,  isManual,  loader.getInstancePointer().pointer,  params.getInstancePointer().pointer)));
    }

    private native long _createImpl__StringRResourceHandlevStringRbvManualResourceLoaderpNameValuePairListP(long _pointer_, String name, long handle, String group, boolean isManual, long loader, long params);

    /** 
    Initialises the  manager, which also triggers it to parse all available .compositor scripts. **/
    public void initialise() {
        _initialise(this.object.pointer);
    }

    private native void _initialise(long _pointer_);

    /** 
    **/
    public void parseScript(org.ogre4j.IDataStreamPtr stream, String groupName) {
        _parseScript__DataStreamPtrrStringR(this.object.pointer, stream.getInstancePointer().pointer,  groupName);
    }

    private native void _parseScript__DataStreamPtrrStringR(long _pointer_, long stream, String groupName);

    /** 
    Get the compositor chain for a . If there is none yet, a new compositor chain is registered. XXX We need a _notifyViewportRemoved to find out when this viewport disappears, so we can destroy its chain as well. **/
    public org.ogre4j.ICompositorChain getCompositorChain(org.ogre4j.IViewport vp) {
         return new org.ogre4j.CompositorChain(new InstancePointer(_getCompositorChain__Viewportp(this.object.pointer, vp.getInstancePointer().pointer)));
    }

    private native long _getCompositorChain__Viewportp(long _pointer_, long vp);

    /** 
    Returns whether exists compositor chain for a viewport. **/
    public boolean hasCompositorChain(org.ogre4j.IViewport vp) {
         return _hasCompositorChain__Viewportp_const(this.object.pointer, vp.getInstancePointer().pointer);
    }

    private native boolean _hasCompositorChain__Viewportp_const(long _pointer_, long vp);

    /** 
    Remove the compositor chain from a viewport if exists. **/
    public void removeCompositorChain(org.ogre4j.IViewport vp) {
        _removeCompositorChain__Viewportp(this.object.pointer, vp.getInstancePointer().pointer);
    }

    private native void _removeCompositorChain__Viewportp(long _pointer_, long vp);

    /** 
    Add a compositor to a viewport. By default, it is added to end of the chain, after the other compositors. **/
    public org.ogre4j.ICompositorInstance addCompositor(org.ogre4j.IViewport vp, String compositor, int addPosition) {
         return new org.ogre4j.CompositorInstance(new InstancePointer(_addCompositor__ViewportpStringRiv(this.object.pointer, vp.getInstancePointer().pointer,  compositor,  addPosition)));
    }

    private native long _addCompositor__ViewportpStringRiv(long _pointer_, long vp, String compositor, int addPosition);

    /** 
    Remove a compositor from a viewport **/
    public void removeCompositor(org.ogre4j.IViewport vp, String compositor) {
        _removeCompositor__ViewportpStringR(this.object.pointer, vp.getInstancePointer().pointer,  compositor);
    }

    private native void _removeCompositor__ViewportpStringR(long _pointer_, long vp, String compositor);

    /** 
    Set the state of a compositor on a viewport to enabled or disabled. Disabling a compositor stops it from rendering but does not free any resources. This can be more efficient than using removeCompositor and addCompositor in cases the filter is switched on and off a lot. **/
    public void setCompositorEnabled(org.ogre4j.IViewport vp, String compositor, boolean value) {
        _setCompositorEnabled__ViewportpStringRbv(this.object.pointer, vp.getInstancePointer().pointer,  compositor,  value);
    }

    private native void _setCompositorEnabled__ViewportpStringRbv(long _pointer_, long vp, String compositor, boolean value);

    /** 
    Get a textured fullscreen 2D rectangle, for internal use. **/
    public org.ogre4j.IRenderable _getTexturedRectangle2D() {
         return new org.ogre4j.Renderable(new InstancePointer(__getTexturedRectangle2D(this.object.pointer)));
    }

    private native long __getTexturedRectangle2D(long _pointer_);

    /** 
    Overridden from  since we have to clean up chains too. **/
    public void removeAll() {
        _removeAll(this.object.pointer);
    }

    private native void _removeAll(long _pointer_);

    /** 
    Internal method for forcing all active compositors to recreate their resources. **/
    public void _reconstructAllCompositorResources() {
        __reconstructAllCompositorResources(this.object.pointer);
    }

    private native void __reconstructAllCompositorResources(long _pointer_);

    /** 
    Override standard  retrieval. **/
    public static org.ogre4j.ICompositorManager getSingleton() {
         return new org.ogre4j.CompositorManager(new InstancePointer(_getSingleton()));
    }

    private native static long _getSingleton();

    /** 
    Override standard  retrieval. **/
    public static org.ogre4j.ICompositorManager getSingletonPtr() {
         return new org.ogre4j.CompositorManager(new InstancePointer(_getSingletonPtr()));
    }

    private native static long _getSingletonPtr();

    /** 
    Creates a new blank resource, but does not immediately load it. **/
    public void create(org.ogre4j.IResourcePtr returnValue, String name, String group, boolean isManual, org.ogre4j.IManualResourceLoader loader, org.ogre4j.INameValuePairList createParams) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_create__StringRStringRbvManualResourceLoaderpNameValuePairListP(this.object.pointer, name,  group,  isManual,  loader.getInstancePointer().pointer,  createParams.getInstancePointer().pointer)), false);
    }

    private native long _create__StringRStringRbvManualResourceLoaderpNameValuePairListP(long _pointer_, String name, String group, boolean isManual, long loader, long createParams);

    /** 
    Create a new resource, or retrieve an existing one with the same name if it already exists. **/
    public void createOrRetrieve(org.ogre4j.IResourceManager.IResourceCreateOrRetrieveResult returnValue, String name, String group, boolean isManual, org.ogre4j.IManualResourceLoader loader, org.ogre4j.INameValuePairList createParams) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_createOrRetrieve__StringRStringRbvManualResourceLoaderpNameValuePairListP(this.object.pointer, name,  group,  isManual,  loader.getInstancePointer().pointer,  createParams.getInstancePointer().pointer)), false);
    }

    private native long _createOrRetrieve__StringRStringRbvManualResourceLoaderpNameValuePairListP(long _pointer_, String name, String group, boolean isManual, long loader, long createParams);

    /** 
    Set a limit on the amount of memory this resource handler may use. **/
    public void setMemoryBudget(int bytes) {
        _setMemoryBudget__iv(this.object.pointer, bytes);
    }

    private native void _setMemoryBudget__iv(long _pointer_, int bytes);

    /** 
    Get the limit on the amount of memory this resource handler may use. **/
    public int getMemoryBudget() {
         return _getMemoryBudget_const(this.object.pointer);
    }

    private native int _getMemoryBudget_const(long _pointer_);

    /** 
    Gets the current memory usage, in bytes. **/
    public int getMemoryUsage() {
         return _getMemoryUsage_const(this.object.pointer);
    }

    private native int _getMemoryUsage_const(long _pointer_);

    /** 
    Unloads a single resource by name. **/
    public void unload(String name) {
        _unload__StringR(this.object.pointer, name);
    }

    private native void _unload__StringR(long _pointer_, String name);

    /** 
    Unloads a single resource by handle. **/
    public void unload(long handle) {
        _unload__ResourceHandlev(this.object.pointer, handle);
    }

    private native void _unload__ResourceHandlev(long _pointer_, long handle);

    /** 
    Unloads all resources. **/
    public void unloadAll(boolean reloadableOnly) {
        _unloadAll__bv(this.object.pointer, reloadableOnly);
    }

    private native void _unloadAll__bv(long _pointer_, boolean reloadableOnly);

    /** 
    Caused all currently loaded resources to be reloaded. **/
    public void reloadAll(boolean reloadableOnly) {
        _reloadAll__bv(this.object.pointer, reloadableOnly);
    }

    private native void _reloadAll__bv(long _pointer_, boolean reloadableOnly);

    /** 
    Unload all resources which are not referenced by any other object. **/
    public void unloadUnreferencedResources(boolean reloadableOnly) {
        _unloadUnreferencedResources__bv(this.object.pointer, reloadableOnly);
    }

    private native void _unloadUnreferencedResources__bv(long _pointer_, boolean reloadableOnly);

    /** 
    Caused all currently loaded but not referenced by any other object resources to be reloaded. **/
    public void reloadUnreferencedResources(boolean reloadableOnly) {
        _reloadUnreferencedResources__bv(this.object.pointer, reloadableOnly);
    }

    private native void _reloadUnreferencedResources__bv(long _pointer_, boolean reloadableOnly);

    /** 
    Remove a single resource. **/
    public void remove(org.ogre4j.IResourcePtr r) {
        _remove__ResourcePtrr(this.object.pointer, r.getInstancePointer().pointer);
    }

    private native void _remove__ResourcePtrr(long _pointer_, long r);

    /** 
    Remove a single resource by name. **/
    public void remove(String name) {
        _remove__StringR(this.object.pointer, name);
    }

    private native void _remove__StringR(long _pointer_, String name);

    /** 
    Remove a single resource by handle. **/
    public void remove(long handle) {
        _remove__ResourceHandlev(this.object.pointer, handle);
    }

    private native void _remove__ResourceHandlev(long _pointer_, long handle);

    /** 
    Retrieves a pointer to a resource by name, or null if the resource does not exist. **/
    public void getByName(org.ogre4j.IResourcePtr returnValue, String name) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getByName__StringR(this.object.pointer, name)), false);
    }

    private native long _getByName__StringR(long _pointer_, String name);

    /** 
    Retrieves a pointer to a resource by handle, or null if the resource does not exist. **/
    public void getByHandle(org.ogre4j.IResourcePtr returnValue, long handle) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getByHandle__ResourceHandlev(this.object.pointer, handle)), false);
    }

    private native long _getByHandle__ResourceHandlev(long _pointer_, long handle);

    /** **/
    public boolean resourceExists(String name) {
         return _resourceExists__StringR(this.object.pointer, name);
    }

    private native boolean _resourceExists__StringR(long _pointer_, String name);

    /** **/
    public boolean resourceExists(long handle) {
         return _resourceExists__ResourceHandlev(this.object.pointer, handle);
    }

    private native boolean _resourceExists__ResourceHandlev(long _pointer_, long handle);

    /** 
    Notify this manager that a resource which it manages has been 'touched', i.e. used. **/
    public void _notifyResourceTouched(org.ogre4j.IResource res) {
        __notifyResourceTouched__Resourcep(this.object.pointer, res.getInstancePointer().pointer);
    }

    private native void __notifyResourceTouched__Resourcep(long _pointer_, long res);

    /** 
    Notify this manager that a resource which it manages has been loaded. **/
    public void _notifyResourceLoaded(org.ogre4j.IResource res) {
        __notifyResourceLoaded__Resourcep(this.object.pointer, res.getInstancePointer().pointer);
    }

    private native void __notifyResourceLoaded__Resourcep(long _pointer_, long res);

    /** 
    Notify this manager that a resource which it manages has been unloaded. **/
    public void _notifyResourceUnloaded(org.ogre4j.IResource res) {
        __notifyResourceUnloaded__Resourcep(this.object.pointer, res.getInstancePointer().pointer);
    }

    private native void __notifyResourceUnloaded__Resourcep(long _pointer_, long res);

    /** 
    Generic prepare method, used to create a  specific to this  without using one of the specialised 'prepare' methods (containing per-Resource-type parameters). **/
    public void prepare(org.ogre4j.IResourcePtr returnValue, String name, String group, boolean isManual, org.ogre4j.IManualResourceLoader loader, org.ogre4j.INameValuePairList loadParams) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_prepare__StringRStringRbvManualResourceLoaderpNameValuePairListP(this.object.pointer, name,  group,  isManual,  loader.getInstancePointer().pointer,  loadParams.getInstancePointer().pointer)), false);
    }

    private native long _prepare__StringRStringRbvManualResourceLoaderpNameValuePairListP(long _pointer_, String name, String group, boolean isManual, long loader, long loadParams);

    /** 
    Generic load method, used to create a  specific to this  without using one of the specialised 'load' methods (containing per-Resource-type parameters). **/
    public void load(org.ogre4j.IResourcePtr returnValue, String name, String group, boolean isManual, org.ogre4j.IManualResourceLoader loader, org.ogre4j.INameValuePairList loadParams) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_load__StringRStringRbvManualResourceLoaderpNameValuePairListP(this.object.pointer, name,  group,  isManual,  loader.getInstancePointer().pointer,  loadParams.getInstancePointer().pointer)), false);
    }

    private native long _load__StringRStringRbvManualResourceLoaderpNameValuePairListP(long _pointer_, String name, String group, boolean isManual, long loader, long loadParams);

    /** 
    Gets the file patterns which should be used to find scripts for this . **/
    public org.ogre4j.IStringVector getScriptPatterns() {
         return new org.ogre4j.StringVector(new InstancePointer(_getScriptPatterns_const(this.object.pointer)));
    }

    private native long _getScriptPatterns_const(long _pointer_);

    /** 
    Gets the relative loading order of resources of this type. **/
    public float getLoadingOrder() {
         return _getLoadingOrder_const(this.object.pointer);
    }

    private native float _getLoadingOrder_const(long _pointer_);

    /** 
    Gets a string identifying the type of resource this manager handles. **/
    public String getResourceType() {
         return _getResourceType_const(this.object.pointer);
    }

    private native String _getResourceType_const(long _pointer_);

    /** 
    Sets whether this manager and its resources habitually produce log output **/
    public void setVerbose(boolean v) {
        _setVerbose__bv(this.object.pointer, v);
    }

    private native void _setVerbose__bv(long _pointer_, boolean v);

    /** 
    Gets whether this manager and its resources habitually produce log output **/
    public boolean getVerbose() {
         return _getVerbose(this.object.pointer);
    }

    private native boolean _getVerbose(long _pointer_);

    /** 
    Returns an iterator over all resources in this manager. **/
    public void getResourceIterator(org.ogre4j.IResourceManager.IResourceMapIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getResourceIterator(this.object.pointer)), false);
    }

    private native long _getResourceIterator(long _pointer_);

}
