/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class SubMesh extends org.xbig.base.NativeObject implements org.ogre4j.ISubMesh {
static { System.loadLibrary("ogre4j");}
public static class IndexMap extends org.xbig.base.NativeObject implements org.ogre4j.ISubMesh.IIndexMap {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public IndexMap(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected IndexMap(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public IndexMap(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public IndexMap() {
         super( new org.xbig.base.InstancePointer(__createIndexMap()), false);
    }

    private native static long __createIndexMap();

    /** **/
    public void assign(int num, int val) {
        _assign__ivHR(this.object.pointer, num,  val);
    }

    private native void _assign__ivHR(long _pointer_, int num, int val);

    /** **/
    public IntegerPointer at(int loc) {
         return new IntegerPointer(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public IntegerPointer back() {
         return new IntegerPointer(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public IntegerPointer front() {
         return new IntegerPointer(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(int val) {
        _push_back__HR(this.object.pointer, val);
    }

    private native void _push_back__HR(long _pointer_, int val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
public static class VertexBoneAssignmentList extends org.xbig.base.NativeObject implements org.ogre4j.ISubMesh.IVertexBoneAssignmentList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public VertexBoneAssignmentList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected VertexBoneAssignmentList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public VertexBoneAssignmentList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public VertexBoneAssignmentList() {
         super( new org.xbig.base.InstancePointer(__createVertexBoneAssignmentList()), false);
    }

    private native static long __createVertexBoneAssignmentList();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(int key) {
         return _count__iR(this.object.pointer, key);
    }

    private native int _count__iR(long _pointer_, int key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(int key) {
         return _erase__iR(this.object.pointer, key);
    }

    private native int _erase__iR(long _pointer_, int key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

}
public static class BoneAssignmentIterator extends org.xbig.base.NativeObject implements org.ogre4j.ISubMesh.IBoneAssignmentIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public BoneAssignmentIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected BoneAssignmentIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public BoneAssignmentIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public BoneAssignmentIterator(org.ogre4j.ISubMesh.IVertexBoneAssignmentList c) {
         super( new org.xbig.base.InstancePointer(__createBoneAssignmentIterator__Ogre_SubMesh_VertexBoneAssignmentListr( c.getInstancePointer().pointer)), false);
    }

    private native static long __createBoneAssignmentIterator__Ogre_SubMesh_VertexBoneAssignmentListr(long c);

    /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public void getNext(org.ogre4j.IVertexBoneAssignment_s returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getNext(this.object.pointer)), false);
    }

    private native long _getNext(long _pointer_);

    /** **/
    public void peekNextValue(org.ogre4j.IVertexBoneAssignment_s returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_peekNextValue(this.object.pointer)), false);
    }

    private native long _peekNextValue(long _pointer_);

    /** **/
    public int peekNextKey() {
         return _peekNextKey(this.object.pointer);
    }

    private native int _peekNextKey(long _pointer_);

    /** **/
    public org.ogre4j.ISubMesh.IBoneAssignmentIterator operatorAssignment(org.ogre4j.ISubMesh.IBoneAssignmentIterator rhs) {
         return new org.ogre4j.SubMesh.BoneAssignmentIterator(new InstancePointer(_operatorAssignment___Ogre_SubMesh_BoneAssignmentIteratorr(this.object.pointer, rhs.getInstancePointer().pointer)));
    }

    private native long _operatorAssignment___Ogre_SubMesh_BoneAssignmentIteratorr(long _pointer_, long rhs);

    /** **/
    public org.ogre4j.IVertexBoneAssignment_s peekNextValuePtr() {
         return new org.ogre4j.VertexBoneAssignment_s(new InstancePointer(_peekNextValuePtr(this.object.pointer)));
    }

    private native long _peekNextValuePtr(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext(this.object.pointer);
    }

    private native void _moveNext(long _pointer_);

}
public static class AliasTextureIterator extends org.xbig.base.NativeObject implements org.ogre4j.ISubMesh.IAliasTextureIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public AliasTextureIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected AliasTextureIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public AliasTextureIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public AliasTextureIterator(org.ogre4j.IAliasTextureNamePairList c) {
         super( new org.xbig.base.InstancePointer(__createAliasTextureIterator__Ogre_AliasTextureNamePairListR( c.getInstancePointer().pointer)), false);
    }

    private native static long __createAliasTextureIterator__Ogre_AliasTextureNamePairListR(long c);

    /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public String getNext() {
         return _getNext(this.object.pointer);
    }

    private native String _getNext(long _pointer_);

    /** **/
    public String peekNextValue() {
         return _peekNextValue_const(this.object.pointer);
    }

    private native String _peekNextValue_const(long _pointer_);

    /** **/
    public String peekNextKey() {
         return _peekNextKey_const(this.object.pointer);
    }

    private native String _peekNextKey_const(long _pointer_);

    /** **/
    public org.ogre4j.ISubMesh.IAliasTextureIterator operatorAssignment(org.ogre4j.ISubMesh.IAliasTextureIterator rhs) {
         return new org.ogre4j.SubMesh.AliasTextureIterator(new InstancePointer(_operatorAssignment___Ogre_SubMesh_AliasTextureIteratorr(this.object.pointer, rhs.getInstancePointer().pointer)));
    }

    private native long _operatorAssignment___Ogre_SubMesh_AliasTextureIteratorr(long _pointer_, long rhs);

    /** **/
    public StringPointer peekNextValuePtr() {
         return new StringPointer(new InstancePointer(_peekNextValuePtr_const(this.object.pointer)));
    }

    private native long _peekNextValuePtr_const(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext_const(this.object.pointer);
    }

    private native void _moveNext_const(long _pointer_);

}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public SubMesh(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected SubMesh(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public SubMesh(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public SubMesh() {
         super( new org.xbig.base.InstancePointer(__createSubMesh()), false);
    }

    private native static long __createSubMesh();

    /** **/
    public void setMaterialName(String matName) {
        _setMaterialName__StringR(this.object.pointer, matName);
    }

    private native void _setMaterialName__StringR(long _pointer_, String matName);

    /** **/
    public String getMaterialName() {
         return _getMaterialName_const(this.object.pointer);
    }

    private native String _getMaterialName_const(long _pointer_);

    /** 
    Returns true if a material has been assigned to the submesh, otherwise returns false. **/
    public boolean isMatInitialised() {
         return _isMatInitialised_const(this.object.pointer);
    }

    private native boolean _isMatInitialised_const(long _pointer_);

    /** 
    Returns a  structure required to render this mesh. **/
    public void _getRenderOperation(org.ogre4j.IRenderOperation rend, int lodIndex) {
        __getRenderOperation__RenderOperationrushortv(this.object.pointer, rend.getInstancePointer().pointer,  lodIndex);
    }

    private native void __getRenderOperation__RenderOperationrushortv(long _pointer_, long rend, int lodIndex);

    /** 
    Assigns a vertex to a bone with a given weight, for skeletal animation. **/
    public void addBoneAssignment(org.ogre4j.IVertexBoneAssignment_s vertBoneAssign) {
        _addBoneAssignment__VertexBoneAssignmentR(this.object.pointer, vertBoneAssign.getInstancePointer().pointer);
    }

    private native void _addBoneAssignment__VertexBoneAssignmentR(long _pointer_, long vertBoneAssign);

    /** 
    Removes all bone assignments for this mesh. **/
    public void clearBoneAssignments() {
        _clearBoneAssignments(this.object.pointer);
    }

    private native void _clearBoneAssignments(long _pointer_);

    /** 
    Gets an iterator for access all bone assignments. **/
    public void getBoneAssignmentIterator(org.ogre4j.ISubMesh.IBoneAssignmentIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getBoneAssignmentIterator(this.object.pointer)), false);
    }

    private native long _getBoneAssignmentIterator(long _pointer_);

    /** 
    Gets a const reference to the list of bone assignments **/
    public org.ogre4j.ISubMesh.IVertexBoneAssignmentList getBoneAssignments() {
         return new org.ogre4j.SubMesh.VertexBoneAssignmentList(new InstancePointer(_getBoneAssignments(this.object.pointer)));
    }

    private native long _getBoneAssignments(long _pointer_);

    /** 
    Must be called once to compile bone assignments into geometry buffer. **/
    public void _compileBoneAssignments() {
        __compileBoneAssignments(this.object.pointer);
    }

    private native void __compileBoneAssignments(long _pointer_);

    /** 
    Gets an constant iterator to access all texture alias names assigned to this submesh. **/
    public void getAliasTextureIterator(org.ogre4j.ISubMesh.IAliasTextureIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getAliasTextureIterator_const(this.object.pointer)), false);
    }

    private native long _getAliasTextureIterator_const(long _pointer_);

    /** 
    Adds the alias or replaces an existing one and associates the texture name to it. **/
    public void addTextureAlias(String aliasName, String textureName) {
        _addTextureAlias__StringRStringR(this.object.pointer, aliasName,  textureName);
    }

    private native void _addTextureAlias__StringRStringR(long _pointer_, String aliasName, String textureName);

    /** 
    Remove a specific texture alias name from the sub mesh **/
    public void removeTextureAlias(String aliasName) {
        _removeTextureAlias__StringR(this.object.pointer, aliasName);
    }

    private native void _removeTextureAlias__StringR(long _pointer_, String aliasName);

    /** 
    removes all texture aliases from the sub mesh **/
    public void removeAllTextureAliases() {
        _removeAllTextureAliases(this.object.pointer);
    }

    private native void _removeAllTextureAliases(long _pointer_);

    /** 
    returns true if the sub mesh has texture aliases **/
    public boolean hasTextureAliases() {
         return _hasTextureAliases_const(this.object.pointer);
    }

    private native boolean _hasTextureAliases_const(long _pointer_);

    /** 
    Gets the number of texture aliases assigned to the sub mesh. **/
    public int getTextureAliasCount() {
         return _getTextureAliasCount_const(this.object.pointer);
    }

    private native int _getTextureAliasCount_const(long _pointer_);

    /** 
    The current material used by the submesh is copied into a new material and the submesh's texture aliases are applied if the current texture alias names match those found in the original material. **/
    public boolean updateMaterialUsingTextureAliases() {
         return _updateMaterialUsingTextureAliases(this.object.pointer);
    }

    private native boolean _updateMaterialUsingTextureAliases(long _pointer_);

    /** 
    Get the type of any vertex animation used by dedicated geometry. **/
    public org.ogre4j.VertexAnimationType getVertexAnimationType() {
         return org.ogre4j.VertexAnimationType.toEnum(_getVertexAnimationType_const(this.object.pointer));
    }

    private native int _getVertexAnimationType_const(long _pointer_);

    /** 
    Generate the submesh extremes (**/
    public void generateExtremes(int count) {
        _generateExtremes__iv(this.object.pointer, count);
    }

    private native void _generateExtremes__iv(long _pointer_, int count);

    /** 
    Returns true(by default) if the submesh should be included in the mesh EdgeList, otherwise returns false. **/
    public boolean isBuildEdgesEnabled() {
         return _isBuildEdgesEnabled_const(this.object.pointer);
    }

    private native boolean _isBuildEdgesEnabled_const(long _pointer_);

    /** **/
    public void setBuildEdgesEnabled(boolean b) {
        _setBuildEdgesEnabled__bv(this.object.pointer, b);
    }

    private native void _setBuildEdgesEnabled__bv(long _pointer_, boolean b);

    /** **/
    public boolean getuseSharedVertices() {
         return _getuseSharedVertices(this.object.pointer);
    }

    private native boolean _getuseSharedVertices(long _pointer_);

    /** **/
    public void setuseSharedVertices(boolean _jni_value_) {
        _setuseSharedVertices(this.object.pointer, _jni_value_);
    }

    private native void _setuseSharedVertices(long _pointer_, boolean _jni_value_);

    /** **/
    public org.ogre4j.RenderOperation.OperationType getoperationType() {
         return org.ogre4j.RenderOperation.OperationType.toEnum(_getoperationType(this.object.pointer));
    }

    private native int _getoperationType(long _pointer_);

    /** **/
    public void setoperationType(org.ogre4j.RenderOperation.OperationType _jni_value_) {
        _setoperationType(this.object.pointer, _jni_value_.getValue());
    }

    private native void _setoperationType(long _pointer_, int _jni_value_);

    /** **/
    public org.ogre4j.IVertexData getvertexData() {
         return new org.ogre4j.VertexData(new InstancePointer(_getvertexData(this.object.pointer)));
    }

    private native long _getvertexData(long _pointer_);

    /** **/
    public void setvertexData(org.ogre4j.IVertexData _jni_value_) {
        _setvertexData(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setvertexData(long _pointer_, long _jni_value_);

    /** **/
    public org.ogre4j.IIndexData getindexData() {
         return new org.ogre4j.IndexData(new InstancePointer(_getindexData(this.object.pointer)));
    }

    private native long _getindexData(long _pointer_);

    /** **/
    public void setindexData(org.ogre4j.IIndexData _jni_value_) {
        _setindexData(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setindexData(long _pointer_, long _jni_value_);

    /** **/
    public void getblendIndexToBoneIndexMap(org.ogre4j.ISubMesh.IIndexMap returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getblendIndexToBoneIndexMap(this.object.pointer)), false);
    }

    private native long _getblendIndexToBoneIndexMap(long _pointer_);

    /** **/
    public void setblendIndexToBoneIndexMap(org.ogre4j.ISubMesh.IIndexMap _jni_value_) {
        _setblendIndexToBoneIndexMap(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setblendIndexToBoneIndexMap(long _pointer_, long _jni_value_);

    /** **/
    public void getmLodFaceList(org.ogre4j.IProgressiveMesh.ILODFaceList returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getmLodFaceList(this.object.pointer)), false);
    }

    private native long _getmLodFaceList(long _pointer_);

    /** **/
    public void setmLodFaceList(org.ogre4j.IProgressiveMesh.ILODFaceList _jni_value_) {
        _setmLodFaceList(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setmLodFaceList(long _pointer_, long _jni_value_);

    /** **/
    public void getextremityPoints(org.std.Ivector< org.ogre4j.IVector3 > returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getextremityPoints(this.object.pointer)), false);
    }

    private native long _getextremityPoints(long _pointer_);

    /** **/
    public void setextremityPoints(org.std.Ivector< org.ogre4j.IVector3 > _jni_value_) {
        _setextremityPoints(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setextremityPoints(long _pointer_, long _jni_value_);

    /** **/
    public org.ogre4j.IMesh getparent() {
         return new org.ogre4j.Mesh(new InstancePointer(_getparent(this.object.pointer)));
    }

    private native long _getparent(long _pointer_);

    /** **/
    public void setparent(org.ogre4j.IMesh _jni_value_) {
        _setparent(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setparent(long _pointer_, long _jni_value_);

}
