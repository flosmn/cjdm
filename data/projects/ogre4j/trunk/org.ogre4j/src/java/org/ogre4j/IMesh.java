/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public interface IMesh extends INativeObject, org.ogre4j.IResource {

public interface ILodDistanceList extends INativeObject, org.std.Ivector< Float > {

    /** **/
    public void assign(int num, float val);

    /** **/
    public FloatPointer at(int loc);

    /** **/
    public FloatPointer back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public FloatPointer front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(float val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
public interface IVertexBoneAssignmentList extends INativeObject, org.std.Imultimap< Integer, org.ogre4j.IVertexBoneAssignment_s > {

    /** **/
    public void clear();

    /** **/
    public int count(int key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(int key);

    /** **/
    public int max_size();

    /** **/
    public int size();

}
public interface IBoneAssignmentIterator extends INativeObject, org.ogre4j.IMapIterator< org.ogre4j.IMesh.IVertexBoneAssignmentList > {

    /** **/
    public boolean hasMoreElements();

    /** **/
    public void getNext(org.ogre4j.IVertexBoneAssignment_s returnValue);

    /** **/
    public void peekNextValue(org.ogre4j.IVertexBoneAssignment_s returnValue);

    /** **/
    public int peekNextKey();

    /** **/
    public org.ogre4j.IMesh.IBoneAssignmentIterator operatorAssignment(org.ogre4j.IMesh.IBoneAssignmentIterator rhs);

    /** **/
    public org.ogre4j.IVertexBoneAssignment_s peekNextValuePtr();

    /** **/
    public void moveNext();

}
public interface ISubMeshList extends INativeObject, org.std.Ivector< org.ogre4j.ISubMesh > {

    /** **/
    public void assign(int num, org.ogre4j.ISubMesh val);

    /** **/
    public org.ogre4j.ISubMesh at(int loc);

    /** **/
    public org.ogre4j.ISubMesh back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public org.ogre4j.ISubMesh front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(org.ogre4j.ISubMesh val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
public interface IIndexMap extends INativeObject, org.std.Ivector< Integer > {

    /** **/
    public void assign(int num, int val);

    /** **/
    public IntegerPointer at(int loc);

    /** **/
    public IntegerPointer back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public IntegerPointer front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(int val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
public interface ISubMeshNameMap extends INativeObject, org.std.Ihash_map< String, Integer > {

    /** **/
    public void clear();

    /** **/
    public int count(String key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(String key);

    /** **/
    public int max_size();

    /** **/
    public int size();

    /** **/
    public IntegerPointer get(String key);

    /** **/
    public void insert(String key, IntegerPointer value);

}
public interface ISubMeshIterator extends INativeObject, org.ogre4j.IVectorIterator< org.ogre4j.IMesh.ISubMeshList > {

    /** **/
    public boolean hasMoreElements();

    /** **/
    public org.ogre4j.ISubMesh getNext();

    /** **/
    public org.ogre4j.ISubMesh peekNext();

    /** **/
    public NativeObjectPointer<org.ogre4j.ISubMesh> peekNextPtr();

    /** **/
    public void moveNext();

}
public interface IPoseIterator extends INativeObject, org.ogre4j.IVectorIterator< org.ogre4j.IPoseList > {

    /** **/
    public boolean hasMoreElements();

    /** **/
    public org.ogre4j.IPose getNext();

    /** **/
    public org.ogre4j.IPose peekNext();

    /** **/
    public NativeObjectPointer<org.ogre4j.IPose> peekNextPtr();

    /** **/
    public void moveNext();

}
public interface IConstPoseIterator extends INativeObject, org.ogre4j.IConstVectorIterator< org.ogre4j.IPoseList > {

    /** **/
    public boolean hasMoreElements();

    /** **/
    public org.ogre4j.IPose getNext();

    /** **/
    public org.ogre4j.IPose peekNext();

    /** **/
    public NativeObjectPointer<org.ogre4j.IPose> peekNextPtr();

    /** **/
    public void moveNext();

}
public interface IMeshLodUsageList extends INativeObject, org.std.Ivector< org.ogre4j.IMeshLodUsage > {

    /** **/
    public void assign(int num, org.ogre4j.IMeshLodUsage val);

    /** **/
    public org.ogre4j.IMeshLodUsage at(int loc);

    /** **/
    public org.ogre4j.IMeshLodUsage back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public org.ogre4j.IMeshLodUsage front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(org.ogre4j.IMeshLodUsage val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
public interface IAnimationList extends INativeObject, org.std.Imap< String, org.ogre4j.IAnimation > {

    /** **/
    public void clear();

    /** **/
    public int count(String key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(String key);

    /** **/
    public int max_size();

    /** **/
    public int size();

    /** **/
    public org.ogre4j.IAnimation get(String key);

    /** **/
    public void insert(String key, org.ogre4j.IAnimation value);

}
    /** 
    Creates a new . **/
    public org.ogre4j.ISubMesh createSubMesh();

    /** 
    Creates a new  and gives it a name **/
    public org.ogre4j.ISubMesh createSubMesh(String name);

    /** 
    Gives a name to a **/
    public void nameSubMesh(String name, int index);

    /** 
    Gets the index of a submesh with a given name. **/
    public int _getSubMeshIndex(String name);

    /** 
    Gets the number of sub meshes which comprise this mesh. **/
    public int getNumSubMeshes();

    /** 
    Gets a pointer to the submesh indicated by the index. **/
    public org.ogre4j.ISubMesh getSubMesh(int index);

    /** 
    Gets a  by name **/
    public org.ogre4j.ISubMesh getSubMesh(String name);

    /** **/
    public void getSubMeshIterator(org.ogre4j.IMesh.ISubMeshIterator returnValue);

    /** 
    Makes a copy of this mesh object and gives it a new name. **/
    public void clone(org.ogre4j.IMeshPtr returnValue, String newName, String newGroup);

    /** 
    Get the axis-aligned bounding box for this mesh. **/
    public org.ogre4j.IAxisAlignedBox getBounds();

    /** 
    Gets the radius of the bounding sphere surrounding this mesh. **/
    public float getBoundingSphereRadius();

    /** 
    Manually set the bounding box for this . **/
    public void _setBounds(org.ogre4j.IAxisAlignedBox bounds, boolean pad);

    /** 
    Manually set the bounding radius. **/
    public void _setBoundingSphereRadius(float radius);

    /** 
    Sets the name of the skeleton this  uses for animation. **/
    public void setSkeletonName(String skelName);

    /** 
    Returns true if this  has a linked . **/
    public boolean hasSkeleton();

    /** 
    Returns whether or not this mesh has some kind of vertex animation. **/
    public boolean hasVertexAnimation();

    /** 
    Gets a pointer to any linked . **/
    public org.ogre4j.ISkeletonPtr getSkeleton();

    /** 
    Gets the name of any linked **/
    public String getSkeletonName();

    /** 
    Initialise an animation set suitable for use with this mesh. **/
    public void _initAnimationState(org.ogre4j.IAnimationStateSet animSet);

    /** 
    Refresh an animation set suitable for use with this mesh. **/
    public void _refreshAnimationState(org.ogre4j.IAnimationStateSet animSet);

    /** 
    Assigns a vertex to a bone with a given weight, for skeletal animation. **/
    public void addBoneAssignment(org.ogre4j.IVertexBoneAssignment_s vertBoneAssign);

    /** 
    Removes all bone assignments for this mesh. **/
    public void clearBoneAssignments();

    /** 
    Internal notification, used to tell the  which  to use without loading it. **/
    public void _notifySkeleton(org.ogre4j.ISkeletonPtr pSkel);

    /** 
    Gets an iterator for access all bone assignments. **/
    public void getBoneAssignmentIterator(org.ogre4j.IMesh.IBoneAssignmentIterator returnValue);

    /** 
    Gets a const reference to the list of bone assignments **/
    public org.ogre4j.IMesh.IVertexBoneAssignmentList getBoneAssignments();

    /** 
    Automatically generates lower level of detail versions of this mesh for use when a simpler version of the model is acceptable for rendering. **/
    public void generateLodLevels(org.ogre4j.IMesh.ILodDistanceList lodDistances, org.ogre4j.ProgressiveMesh.VertexReductionQuota reductionMethod, float reductionValue);

    /** 
    Returns the number of levels of detail that this mesh supports. **/
    public int getNumLodLevels();

    /** 
    Gets details of the numbered level of detail entry. **/
    public org.ogre4j.IMeshLodUsage getLodLevel(int index);

    /** 
    Adds a new manual level-of-detail entry to this . **/
    public void createManualLodLevel(float fromDepth, String meshName);

    /** 
    Changes the alternate mesh to use as a manual LOD at the given index. **/
    public void updateManualLodLevel(int index, String meshName);

    /** 
    Retrieves the level of detail index for the given depth value. **/
    public int getLodIndex(float depth);

    /** 
    Retrieves the level of detail index for the given squared depth value. **/
    public int getLodIndexSquaredDepth(float squaredDepth);

    /** 
    Returns true if this mesh is using manual LOD. **/
    public boolean isLodManual();

    /** 
    Internal methods for loading LOD, do not use. **/
    public void _setLodInfo(int numLevels, boolean isManual);

    /** 
    Internal methods for loading LOD, do not use. **/
    public void _setLodUsage(int level, org.ogre4j.IMeshLodUsage usage);

    /** 
    Internal methods for loading LOD, do not use. **/
    public void _setSubMeshLodFaceList(int subIdx, int level, org.ogre4j.IIndexData facedata);

    /** 
    Removes all LOD data from this . **/
    public void removeLodLevels();

    /** 
    Sets the policy for the vertex buffers to be used when loading this . **/
    public void setVertexBufferPolicy(org.ogre4j.HardwareBuffer.Usage usage, boolean shadowBuffer);

    /** 
    Sets the policy for the index buffers to be used when loading this . **/
    public void setIndexBufferPolicy(org.ogre4j.HardwareBuffer.Usage usage, boolean shadowBuffer);

    /** 
    Gets the usage setting for this meshes vertex buffers. **/
    public org.ogre4j.HardwareBuffer.Usage getVertexBufferUsage();

    /** 
    Gets the usage setting for this meshes index buffers. **/
    public org.ogre4j.HardwareBuffer.Usage getIndexBufferUsage();

    /** 
    Gets whether or not this meshes vertex buffers are shadowed. **/
    public boolean isVertexBufferShadowed();

    /** 
    Gets whether or not this meshes index buffers are shadowed. **/
    public boolean isIndexBufferShadowed();

    /** 
    Rationalises the passed in bone assignment list. **/
    public int _rationaliseBoneAssignments(int vertexCount, org.ogre4j.IMesh.IVertexBoneAssignmentList assignments);

    /** 
    Internal method, be called once to compile bone assignments into geometry buffer. **/
    public void _compileBoneAssignments();

    /** 
    Internal method, be called once to update the compiled bone assignments. **/
    public void _updateCompiledBoneAssignments();

    /** 
    This method builds a set of tangent vectors for a given mesh into a 3D texture coordinate buffer. **/
    public void buildTangentVectors(org.ogre4j.VertexElementSemantic targetSemantic, int sourceTexCoordSet, int index, boolean splitMirrored, boolean splitRotated, boolean storeParityInW);

    /** 
    Ask the mesh to suggest parameters to a future buildTangentVectors call, should you wish to use texture coordinates to store the tangents. **/
    public boolean suggestTangentVectorBuildParams(org.ogre4j.VertexElementSemantic targetSemantic, IntegerPointer outSourceCoordSet, IntegerPointer outIndex);

    /** 
    Builds an edge list for this mesh, which can be used for generating a shadow volume among other things. **/
    public void buildEdgeList();

    /** 
    Destroys and frees the edge lists this mesh has built. **/
    public void freeEdgeList();

    /** 
    This method prepares the mesh for generating a renderable shadow volume. **/
    public void prepareForShadowVolume();

    /** 
    Return the edge list for this mesh, building it if required. **/
    public org.ogre4j.IEdgeData getEdgeList(long lodIndex);

    /** **/
    public org.ogre4j.IEdgeData getEdgeList_const(long lodIndex);

    /** 
    Returns whether this mesh has already had it's geometry prepared for use in rendering shadow volumes. **/
    public boolean isPreparedForShadowVolumes();

    /** 
    Returns whether this mesh has an attached edge list. **/
    public boolean isEdgeListBuilt();

    /** 
    Gets a reference to the optional name assignments of the SubMeshes. **/
    public org.ogre4j.IMesh.ISubMeshNameMap getSubMeshNameMap();

    /** 
    Sets whether or not this  should automatically build edge lists when asked for them, or whether it should never build them if they are not already provided. **/
    public void setAutoBuildEdgeLists(boolean autobuild);

    /** 
    Sets whether or not this  should automatically build edge lists when asked for them, or whether it should never build them if they are not already provided. **/
    public boolean getAutoBuildEdgeLists();

    /** 
    Gets the type of vertex animation the shared vertex data of this mesh supports. **/
    public org.ogre4j.VertexAnimationType getSharedVertexDataAnimationType();

    /** 
    Creates a new  object for vertex animating this mesh. **/
    public org.ogre4j.IAnimation createAnimation(String name, float length);

    /** 
    Returns the named vertex  object. **/
    public org.ogre4j.IAnimation getAnimation(String name);

    /** 
    Internal access to the named vertex  object - returns null if it does not exist. **/
    public org.ogre4j.IAnimation _getAnimationImpl(String name);

    /** 
    Returns whether this mesh contains the named vertex animation. **/
    public boolean hasAnimation(String name);

    /** 
    Removes vertex  from this mesh. **/
    public void removeAnimation(String name);

    /** 
    Gets the number of morph animations in this mesh. **/
    public int getNumAnimations();

    /** 
    Gets a single morph animation by index. **/
    public org.ogre4j.IAnimation getAnimation(int index);

    /** 
    Removes all morph Animations from this mesh. **/
    public void removeAllAnimations();

    /** 
    Gets a pointer to a vertex data element based on a morph animation track handle. **/
    public org.ogre4j.IVertexData getVertexDataByTrackHandle(int handle);

    /** 
    Iterates through all submeshes and requests them to apply their texture aliases to the material they use. **/
    public void updateMaterialForAllSubMeshes();

    /** 
    Internal method which, if animation types have not been determined, scans any vertex animations and determines the type for each set of vertex data (cannot have 2 different types). **/
    public void _determineAnimationTypes();

    /** 
    Are the derived animation types out of date? **/
    public boolean _getAnimationTypesDirty();

    /** 
    Create a new  for this mesh or one of its submeshes. **/
    public org.ogre4j.IPose createPose(int target, String name);

    /** 
    Get the number of poses. **/
    public int getPoseCount();

    /** 
    Retrieve an existing  by index. **/
    public org.ogre4j.IPose getPose(int index);

    /** 
    Retrieve an existing  by name. **/
    public org.ogre4j.IPose getPose(String name);

    /** 
    Destroy a pose by index. **/
    public void removePose(int index);

    /** 
    Destroy a pose by name. **/
    public void removePose(String name);

    /** 
    Destroy all poses **/
    public void removeAllPoses();

    /** 
    Get an iterator over all the poses defined. **/
    public void getPoseIterator(org.ogre4j.IMesh.IPoseIterator returnValue);

    /** **/
    public void getPoseIterator_const(org.ogre4j.IMesh.IConstPoseIterator returnValue);

    /** 
    Get pose list **/
    public org.ogre4j.IPoseList getPoseList();

    /** **/
    public org.ogre4j.IVertexData getsharedVertexData();

    /** **/
    public void setsharedVertexData(org.ogre4j.IVertexData _jni_value_);

    /** **/
    public void getsharedBlendIndexToBoneIndexMap(org.ogre4j.IMesh.IIndexMap returnValue);

    /** **/
    public void setsharedBlendIndexToBoneIndexMap(org.ogre4j.IMesh.IIndexMap _jni_value_);

}
