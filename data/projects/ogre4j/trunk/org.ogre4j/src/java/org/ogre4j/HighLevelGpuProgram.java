/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class HighLevelGpuProgram extends org.xbig.base.NativeObject implements org.ogre4j.IHighLevelGpuProgram {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public HighLevelGpuProgram(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected HighLevelGpuProgram(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public HighLevelGpuProgram(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** 
    Creates a new parameters object compatible with this program definition. **/
    public void createParameters(org.ogre4j.IGpuProgramParametersSharedPtr returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_createParameters(this.object.pointer)), false);
    }

    private native long _createParameters(long _pointer_);

    /** 
    **/
    public org.ogre4j.IGpuProgram _getBindingDelegate() {
         return new org.ogre4j.GpuProgram(new InstancePointer(__getBindingDelegate(this.object.pointer)));
    }

    private native long __getBindingDelegate(long _pointer_);

    /** 
    Get the full list of  instances. **/
    public org.ogre4j.IGpuNamedConstants getConstantDefinitions() {
         return new org.ogre4j.GpuNamedConstants(new InstancePointer(_getConstantDefinitions_const(this.object.pointer)));
    }

    private native long _getConstantDefinitions_const(long _pointer_);

    /** **/
    public org.ogre4j.IGpuNamedConstants getNamedConstants() {
         return new org.ogre4j.GpuNamedConstants(new InstancePointer(_getNamedConstants_const(this.object.pointer)));
    }

    private native long _getNamedConstants_const(long _pointer_);

    /** 
    Sets the filename of the source assembly for this program. **/
    public void setSourceFile(String filename) {
        _setSourceFile__StringR(this.object.pointer, filename);
    }

    private native void _setSourceFile__StringR(long _pointer_, String filename);

    /** 
    Sets the source assembly for this program from an in-memory string. **/
    public void setSource(String source) {
        _setSource__StringR(this.object.pointer, source);
    }

    private native void _setSource__StringR(long _pointer_, String source);

    /** 
    Gets the syntax code for this program e.g. arbvp1, fp20, vs_1_1 etc **/
    public String getSyntaxCode() {
         return _getSyntaxCode_const(this.object.pointer);
    }

    private native String _getSyntaxCode_const(long _pointer_);

    /** 
    Sets the syntax code for this program e.g. arbvp1, fp20, vs_1_1 etc **/
    public void setSyntaxCode(String syntax) {
        _setSyntaxCode__StringR(this.object.pointer, syntax);
    }

    private native void _setSyntaxCode__StringR(long _pointer_, String syntax);

    /** 
    Gets the name of the file used as source for this program. **/
    public String getSourceFile() {
         return _getSourceFile_const(this.object.pointer);
    }

    private native String _getSourceFile_const(long _pointer_);

    /** 
    Gets the assembler source for this program. **/
    public String getSource() {
         return _getSource_const(this.object.pointer);
    }

    private native String _getSource_const(long _pointer_);

    /** **/
    public void setType(org.ogre4j.GpuProgramType t) {
        _setType__GpuProgramTypev(this.object.pointer, t.getValue());
    }

    private native void _setType__GpuProgramTypev(long _pointer_, int t);

    /** **/
    public org.ogre4j.GpuProgramType getType() {
         return org.ogre4j.GpuProgramType.toEnum(_getType_const(this.object.pointer));
    }

    private native int _getType_const(long _pointer_);

    /** 
    Returns whether this program can be supported on the current renderer and hardware. **/
    public boolean isSupported() {
         return _isSupported_const(this.object.pointer);
    }

    private native boolean _isSupported_const(long _pointer_);

    /** 
    Sets whether a vertex program includes the required instructions to perform skeletal animation. **/
    public void setSkeletalAnimationIncluded(boolean included) {
        _setSkeletalAnimationIncluded__bv(this.object.pointer, included);
    }

    private native void _setSkeletalAnimationIncluded__bv(long _pointer_, boolean included);

    /** 
    Returns whether a vertex program includes the required instructions to perform skeletal animation. **/
    public boolean isSkeletalAnimationIncluded() {
         return _isSkeletalAnimationIncluded_const(this.object.pointer);
    }

    private native boolean _isSkeletalAnimationIncluded_const(long _pointer_);

    /** 
    Sets whether a vertex program includes the required instructions to perform morph animation. **/
    public void setMorphAnimationIncluded(boolean included) {
        _setMorphAnimationIncluded__bv(this.object.pointer, included);
    }

    private native void _setMorphAnimationIncluded__bv(long _pointer_, boolean included);

    /** 
    Sets whether a vertex program includes the required instructions to perform pose animation. **/
    public void setPoseAnimationIncluded(int poseCount) {
        _setPoseAnimationIncluded__ushortv(this.object.pointer, poseCount);
    }

    private native void _setPoseAnimationIncluded__ushortv(long _pointer_, int poseCount);

    /** 
    Returns whether a vertex program includes the required instructions to perform morph animation. **/
    public boolean isMorphAnimationIncluded() {
         return _isMorphAnimationIncluded_const(this.object.pointer);
    }

    private native boolean _isMorphAnimationIncluded_const(long _pointer_);

    /** 
    Returns whether a vertex program includes the required instructions to perform pose animation. **/
    public boolean isPoseAnimationIncluded() {
         return _isPoseAnimationIncluded_const(this.object.pointer);
    }

    private native boolean _isPoseAnimationIncluded_const(long _pointer_);

    /** 
    Returns the number of simultaneous poses the vertex program can blend, for use in pose animation. **/
    public int getNumberOfPosesIncluded() {
         return _getNumberOfPosesIncluded_const(this.object.pointer);
    }

    private native int _getNumberOfPosesIncluded_const(long _pointer_);

    /** 
    Sets whether this vertex program requires support for vertex texture fetch from the hardware. **/
    public void setVertexTextureFetchRequired(boolean r) {
        _setVertexTextureFetchRequired__bv(this.object.pointer, r);
    }

    private native void _setVertexTextureFetchRequired__bv(long _pointer_, boolean r);

    /** 
    Returns whether this vertex program requires support for vertex texture fetch from the hardware. **/
    public boolean isVertexTextureFetchRequired() {
         return _isVertexTextureFetchRequired_const(this.object.pointer);
    }

    private native boolean _isVertexTextureFetchRequired_const(long _pointer_);

    /** 
    Sets whether this geometry program requires adjacency information from the input primitives. **/
    public void setAdjacencyInfoRequired(boolean r) {
        _setAdjacencyInfoRequired__bv(this.object.pointer, r);
    }

    private native void _setAdjacencyInfoRequired__bv(long _pointer_, boolean r);

    /** 
    Returns whether this geometry program requires adjacency information from the input primitives. **/
    public boolean isAdjacencyInfoRequired() {
         return _isAdjacencyInfoRequired_const(this.object.pointer);
    }

    private native boolean _isAdjacencyInfoRequired_const(long _pointer_);

    /** 
    Get a reference to the default parameters which are to be used for all uses of this program. **/
    public void getDefaultParameters(org.ogre4j.IGpuProgramParametersSharedPtr returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getDefaultParameters(this.object.pointer)), false);
    }

    private native long _getDefaultParameters(long _pointer_);

    /** 
    Returns true if default parameters have been set up. **/
    public boolean hasDefaultParameters() {
         return _hasDefaultParameters_const(this.object.pointer);
    }

    private native boolean _hasDefaultParameters_const(long _pointer_);

    /** 
    Sets whether a vertex program requires light and material states to be passed to through fixed pipeline low level API rendering calls. **/
    public void setSurfaceAndPassLightStates(boolean state) {
        _setSurfaceAndPassLightStates__bv(this.object.pointer, state);
    }

    private native void _setSurfaceAndPassLightStates__bv(long _pointer_, boolean state);

    /** 
    Returns whether a vertex program wants light and material states to be passed through fixed pipeline low level API rendering calls **/
    public boolean getPassSurfaceAndLightStates() {
         return _getPassSurfaceAndLightStates_const(this.object.pointer);
    }

    private native boolean _getPassSurfaceAndLightStates_const(long _pointer_);

    /** 
    Returns a string that specifies the language of the gpu programs as specified in a material script. ie: asm, cg, hlsl, glsl **/
    public String getLanguage() {
         return _getLanguage_const(this.object.pointer);
    }

    private native String _getLanguage_const(long _pointer_);

    /** 
    Did this program encounter a compile error when loading? **/
    public boolean hasCompileError() {
         return _hasCompileError_const(this.object.pointer);
    }

    private native boolean _hasCompileError_const(long _pointer_);

    /** 
    Reset a compile error if it occurred, allowing the load to be retried **/
    public void resetCompileError() {
        _resetCompileError(this.object.pointer);
    }

    private native void _resetCompileError(long _pointer_);

    /** 
    Allows you to manually provide a set of named parameter mappings to a program which would not be able to derive named parameters itself. **/
    public void setManualNamedConstants(org.ogre4j.IGpuNamedConstants namedConstants) {
        _setManualNamedConstants__GpuNamedConstantsR(this.object.pointer, namedConstants.getInstancePointer().pointer);
    }

    private native void _setManualNamedConstants__GpuNamedConstantsR(long _pointer_, long namedConstants);

    /** 
    Specifies the name of a file from which to load named parameters mapping for a program which would not be able to derive named parameters itself. **/
    public void setManualNamedConstantsFile(String paramDefFile) {
        _setManualNamedConstantsFile__StringR(this.object.pointer, paramDefFile);
    }

    private native void _setManualNamedConstantsFile__StringR(long _pointer_, String paramDefFile);

    /** 
    Gets the name of a file from which to load named parameters mapping for a program which would not be able to derive named parameters itself. **/
    public String getManualNamedConstantsFile() {
         return _getManualNamedConstantsFile_const(this.object.pointer);
    }

    private native String _getManualNamedConstantsFile_const(long _pointer_);

    /** 
    Prepares the resource for load, if it is not already. One can call  before , but this is not required as  will call  itself, if needed. When OGRE_THREAD_SUPPORT==1 both  and  are thread-safe. When OGRE_THREAD_SUPPORT==2 however, only  is thread-safe. The reason for this function is to allow a background thread to do some of the loading work, without requiring the whole render system to be thread-safe. The background thread would call  while the main render loop would later call . So long as  remains thread-safe, subclasses can arbitrarily split the work of loading a resource between  and . It is best to try and do as much work in , however, since this will leave less work for the main render thread to do and thus increase FPS. **/
    public void prepare() {
        _prepare(this.object.pointer);
    }

    private native void _prepare(long _pointer_);

    /** 
    Loads the resource, if it is not already. **/
    public void load(boolean backgroundThread) {
        _load__bv(this.object.pointer, backgroundThread);
    }

    private native void _load__bv(long _pointer_, boolean backgroundThread);

    /** 
    Reloads the resource, if it is already loaded. **/
    public void reload() {
        _reload(this.object.pointer);
    }

    private native void _reload(long _pointer_);

    /** 
    Returns true if the  is reloadable, false otherwise. **/
    public boolean isReloadable() {
         return _isReloadable_const(this.object.pointer);
    }

    private native boolean _isReloadable_const(long _pointer_);

    /** 
    Is this resource manually loaded? **/
    public boolean isManuallyLoaded() {
         return _isManuallyLoaded_const(this.object.pointer);
    }

    private native boolean _isManuallyLoaded_const(long _pointer_);

    /** 
    Unloads the resource; this is not permanent, the resource can be reloaded later if required. **/
    public void unload() {
        _unload(this.object.pointer);
    }

    private native void _unload(long _pointer_);

    /** 
    Retrieves info about the size of the resource. **/
    public int getSize() {
         return _getSize_const(this.object.pointer);
    }

    private native int _getSize_const(long _pointer_);

    /** 
    'Touches' the resource to indicate it has been used. **/
    public void touch() {
        _touch(this.object.pointer);
    }

    private native void _touch(long _pointer_);

    /** 
    Gets resource name. **/
    public String getName() {
         return _getName_const(this.object.pointer);
    }

    private native String _getName_const(long _pointer_);

    /** **/
    public long getHandle() {
         return _getHandle_const(this.object.pointer);
    }

    private native long _getHandle_const(long _pointer_);

    /** 
    Returns true if the  has been prepared, false otherwise. **/
    public boolean isPrepared() {
         return _isPrepared_const(this.object.pointer);
    }

    private native boolean _isPrepared_const(long _pointer_);

    /** 
    Returns true if the  has been loaded, false otherwise. **/
    public boolean isLoaded() {
         return _isLoaded_const(this.object.pointer);
    }

    private native boolean _isLoaded_const(long _pointer_);

    /** 
    Returns whether the resource is currently in the process of background loading. **/
    public boolean isLoading() {
         return _isLoading_const(this.object.pointer);
    }

    private native boolean _isLoading_const(long _pointer_);

    /** 
    Returns the current loading state. **/
    public org.ogre4j.Resource.LoadingState getLoadingState() {
         return org.ogre4j.Resource.LoadingState.toEnum(_getLoadingState_const(this.object.pointer));
    }

    private native int _getLoadingState_const(long _pointer_);

    /** 
    Returns whether this  has been earmarked for background loading. **/
    public boolean isBackgroundLoaded() {
         return _isBackgroundLoaded_const(this.object.pointer);
    }

    private native boolean _isBackgroundLoaded_const(long _pointer_);

    /** 
    Tells the resource whether it is background loaded or not. **/
    public void setBackgroundLoaded(boolean bl) {
        _setBackgroundLoaded__bv(this.object.pointer, bl);
    }

    private native void _setBackgroundLoaded__bv(long _pointer_, boolean bl);

    /** 
    Escalates the loading of a background loaded resource. **/
    public void escalateLoading() {
        _escalateLoading(this.object.pointer);
    }

    private native void _escalateLoading(long _pointer_);

    /** 
    Register a listener on this resource. **/
    public void addListener(org.ogre4j.IResource.IListener lis) {
        _addListener__Listenerp(this.object.pointer, lis.getInstancePointer().pointer);
    }

    private native void _addListener__Listenerp(long _pointer_, long lis);

    /** 
    Remove a listener on this resource. **/
    public void removeListener(org.ogre4j.IResource.IListener lis) {
        _removeListener__Listenerp(this.object.pointer, lis.getInstancePointer().pointer);
    }

    private native void _removeListener__Listenerp(long _pointer_, long lis);

    /** **/
    public String getGroup() {
         return _getGroup(this.object.pointer);
    }

    private native String _getGroup(long _pointer_);

    /** 
    Change the resource group ownership of a . **/
    public void changeGroupOwnership(String newGroup) {
        _changeGroupOwnership__StringR(this.object.pointer, newGroup);
    }

    private native void _changeGroupOwnership__StringR(long _pointer_, String newGroup);

    /** **/
    public org.ogre4j.IResourceManager getCreator() {
         return new org.ogre4j.ResourceManager(new InstancePointer(_getCreator(this.object.pointer)));
    }

    private native long _getCreator(long _pointer_);

    /** 
    Get the origin of this resource, e.g. a script file name. **/
    public String getOrigin() {
         return _getOrigin_const(this.object.pointer);
    }

    private native String _getOrigin_const(long _pointer_);

    /** **/
    public void _notifyOrigin(String origin) {
        __notifyOrigin__StringR(this.object.pointer, origin);
    }

    private native void __notifyOrigin__StringR(long _pointer_, String origin);

    /** 
    Returns the number of times this resource has changed state, which generally means the number of times it has been loaded. Objects that build derived data based on the resource can check this value against a copy they kept last time they built this derived data, in order to know whether it needs rebuilding. This is a nice way of monitoring changes without having a tightly-bound callback. **/
    public int getStateCount() {
         return _getStateCount_const(this.object.pointer);
    }

    private native int _getStateCount_const(long _pointer_);

    /** 
    Manually mark the state of this resource as having been changed. **/
    public void _dirtyState() {
        __dirtyState(this.object.pointer);
    }

    private native void __dirtyState(long _pointer_);

    /** 
    Firing of background loading complete event **/
    public void _fireBackgroundLoadingComplete() {
        __fireBackgroundLoadingComplete(this.object.pointer);
    }

    private native void __fireBackgroundLoadingComplete(long _pointer_);

    /** 
    Firing of background preparing complete event **/
    public void _fireBackgroundPreparingComplete() {
        __fireBackgroundPreparingComplete(this.object.pointer);
    }

    private native void __fireBackgroundPreparingComplete(long _pointer_);

    /** 
    Retrieves the parameter dictionary for this class. **/
    public org.ogre4j.IParamDictionary getParamDictionary() {
         return new org.ogre4j.ParamDictionary(new InstancePointer(_getParamDictionary(this.object.pointer)));
    }

    private native long _getParamDictionary(long _pointer_);

    /** **/
    public org.ogre4j.IParamDictionary getParamDictionary_const() {
         return new org.ogre4j.ParamDictionary(new InstancePointer(_getParamDictionary_const_const(this.object.pointer)));
    }

    private native long _getParamDictionary_const_const(long _pointer_);

    /** 
    Retrieves a list of parameters valid for this object. **/
    public org.ogre4j.IParameterList getParameters() {
         return new org.ogre4j.ParameterList(new InstancePointer(_getParameters_const(this.object.pointer)));
    }

    private native long _getParameters_const(long _pointer_);

    /** 
    Generic parameter setting method. **/
    public boolean setParameter(String name, String value) {
         return _setParameter__StringRStringR(this.object.pointer, name,  value);
    }

    private native boolean _setParameter__StringRStringR(long _pointer_, String name, String value);

    /** 
    Generic multiple parameter setting method. **/
    public void setParameterList(org.ogre4j.INameValuePairList paramList) {
        _setParameterList__NameValuePairListR(this.object.pointer, paramList.getInstancePointer().pointer);
    }

    private native void _setParameterList__NameValuePairListR(long _pointer_, long paramList);

    /** 
    Generic parameter retrieval method. **/
    public String getParameter(String name) {
         return _getParameter__StringR_const(this.object.pointer, name);
    }

    private native String _getParameter__StringR_const(long _pointer_, String name);

    /** 
    Method for copying this object's parameters to another object. **/
    public void copyParametersTo(org.ogre4j.IStringInterface dest) {
        _copyParametersTo__StringInterfacep_const(this.object.pointer, dest.getInstancePointer().pointer);
    }

    private native void _copyParametersTo__StringInterfacep_const(long _pointer_, long dest);

    /** 
    Cleans up the static 'msDictionary' required to reset , otherwise the containers are left with invalid pointers, which will lead to a crash as soon as one of the  implementers (e.g. ) initializes. **/
    public static void cleanupDictionary() {
        _cleanupDictionary();
    }

    private native static void _cleanupDictionary();

}
