/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public interface IVertexData extends INativeObject, org.ogre4j.IGeometryAllocatedObject {

public static interface IHardwareAnimationData extends INativeObject {

    /** **/
    public org.ogre4j.IVertexElement gettargetVertexElement();

    /** **/
    public float getparametric();

    /** **/
    public void setparametric(float _jni_value_);

}
public interface IHardwareAnimationDataList extends INativeObject, org.std.Ivector< org.ogre4j.IVertexData.IHardwareAnimationData > {

    /** **/
    public void assign(int num, org.ogre4j.IVertexData.IHardwareAnimationData val);

    /** **/
    public org.ogre4j.IVertexData.IHardwareAnimationData at(int loc);

    /** **/
    public org.ogre4j.IVertexData.IHardwareAnimationData back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public org.ogre4j.IVertexData.IHardwareAnimationData front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(org.ogre4j.IVertexData.IHardwareAnimationData val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
    /** 
    Clones this vertex data, potentially including replicating any vertex buffers. **/
    public org.ogre4j.IVertexData clone(boolean copyData);

    /** 
    Modifies the vertex data to be suitable for use for rendering shadow geometry. **/
    public void prepareForShadowVolume();

    /** 
    Reorganises the data in the vertex buffers according to the new vertex declaration passed in. Note that new vertex buffers are created and written to, so if the buffers being referenced by this vertex data object are also used by others, then the original buffers will not be damaged by this operation. Once this operation has completed, the new declaration passed in will overwrite the current one. **/
    public void reorganiseBuffers(org.ogre4j.IVertexDeclaration newDeclaration, org.ogre4j.IBufferUsageList bufferUsage);

    /** 
    Reorganises the data in the vertex buffers according to the new vertex declaration passed in. Note that new vertex buffers are created and written to, so if the buffers being referenced by this vertex data object are also used by others, then the original buffers will not be damaged by this operation. Once this operation has completed, the new declaration passed in will overwrite the current one. This version of the method derives the buffer usages from the existing buffers, by using the 'most flexible' usage from the equivalent sources. **/
    public void reorganiseBuffers(org.ogre4j.IVertexDeclaration newDeclaration);

    /** 
    Remove any gaps in the vertex buffer bindings. **/
    public void closeGapsInBindings();

    /** 
    Remove all vertex buffers that never used by the vertex declaration. **/
    public void removeUnusedBuffers();

    /** 
    Convert all packed colour values (VET_COLOUR_*) in buffers used to another type. **/
    public void convertPackedColour(org.ogre4j.VertexElementType srcType, org.ogre4j.VertexElementType destType);

    /** 
    Allocate elements to serve a holder of morph / pose target data for hardware morphing / pose blending. **/
    public void allocateHardwareAnimationElements(int count);

    /** **/
    public org.ogre4j.IVertexDeclaration getvertexDeclaration();

    /** **/
    public void setvertexDeclaration(org.ogre4j.IVertexDeclaration _jni_value_);

    /** **/
    public org.ogre4j.IVertexBufferBinding getvertexBufferBinding();

    /** **/
    public void setvertexBufferBinding(org.ogre4j.IVertexBufferBinding _jni_value_);

    /** **/
    public int getvertexStart();

    /** **/
    public void setvertexStart(int _jni_value_);

    /** **/
    public int getvertexCount();

    /** **/
    public void setvertexCount(int _jni_value_);

    /** **/
    public void gethwAnimationDataList(org.ogre4j.IVertexData.IHardwareAnimationDataList returnValue);

    /** **/
    public void sethwAnimationDataList(org.ogre4j.IVertexData.IHardwareAnimationDataList _jni_value_);

    /** **/
    public int gethwAnimDataItemsUsed();

    /** **/
    public void sethwAnimDataItemsUsed(int _jni_value_);

    /** **/
    public void gethardwareShadowVolWBuffer(org.ogre4j.IHardwareVertexBufferSharedPtr returnValue);

    /** **/
    public void sethardwareShadowVolWBuffer(org.ogre4j.IHardwareVertexBufferSharedPtr _jni_value_);

}
