/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class SceneManager extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager {
static { System.loadLibrary("ogre4j");}
public static class Listener extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.IListener {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public Listener(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected Listener(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public Listener(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** 
    Called prior to searching for visible objects in this . **/
    public void preFindVisibleObjects(org.ogre4j.ISceneManager source, org.ogre4j.SceneManager.IlluminationRenderStage irs, org.ogre4j.IViewport v) {
        _preFindVisibleObjects__SceneManagerpIlluminationRenderStagevViewportp(this.object.pointer, source.getInstancePointer().pointer,  irs.getValue(),  v.getInstancePointer().pointer);
    }

    private native void _preFindVisibleObjects__SceneManagerpIlluminationRenderStagevViewportp(long _pointer_, long source, int irs, long v);

    /** 
    Called after searching for visible objects in this . **/
    public void postFindVisibleObjects(org.ogre4j.ISceneManager source, org.ogre4j.SceneManager.IlluminationRenderStage irs, org.ogre4j.IViewport v) {
        _postFindVisibleObjects__SceneManagerpIlluminationRenderStagevViewportp(this.object.pointer, source.getInstancePointer().pointer,  irs.getValue(),  v.getInstancePointer().pointer);
    }

    private native void _postFindVisibleObjects__SceneManagerpIlluminationRenderStagevViewportp(long _pointer_, long source, int irs, long v);

    /** 
    Event raised after all shadow textures have been rendered into for all queues / targets but before any other geometry has been rendered (including main scene geometry and any additional shadow receiver passes). **/
    public void shadowTexturesUpdated(int numberOfShadowTextures) {
        _shadowTexturesUpdated__iv(this.object.pointer, numberOfShadowTextures);
    }

    private native void _shadowTexturesUpdated__iv(long _pointer_, int numberOfShadowTextures);

    /** 
    This event occurs just before the view & projection matrices are set for rendering into a shadow texture. **/
    public void shadowTextureCasterPreViewProj(org.ogre4j.ILight light, org.ogre4j.ICamera camera, int iteration) {
        _shadowTextureCasterPreViewProj__LightpCamerapiv(this.object.pointer, light.getInstancePointer().pointer,  camera.getInstancePointer().pointer,  iteration);
    }

    private native void _shadowTextureCasterPreViewProj__LightpCamerapiv(long _pointer_, long light, long camera, int iteration);

    /** 
    This event occurs just before the view & projection matrices are set for re-rendering a shadow receiver. **/
    public void shadowTextureReceiverPreViewProj(org.ogre4j.ILight light, org.ogre4j.IFrustum frustum) {
        _shadowTextureReceiverPreViewProj__LightpFrustump(this.object.pointer, light.getInstancePointer().pointer,  frustum.getInstancePointer().pointer);
    }

    private native void _shadowTextureReceiverPreViewProj__LightpFrustump(long _pointer_, long light, long frustum);

    /** 
    Hook to allow the listener to override the ordering of lights for the entire frustum. **/
    public boolean sortLightsAffectingFrustum(org.ogre4j.ILightList lightList) {
         return _sortLightsAffectingFrustum__LightListr(this.object.pointer, lightList.getInstancePointer().pointer);
    }

    private native boolean _sortLightsAffectingFrustum__LightListr(long _pointer_, long lightList);

}
protected static class SceneMgrQueuedRenderableVisitor extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.ISceneMgrQueuedRenderableVisitor {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public SceneMgrQueuedRenderableVisitor(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected SceneMgrQueuedRenderableVisitor(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public SceneMgrQueuedRenderableVisitor(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public SceneMgrQueuedRenderableVisitor() {
         super( new org.xbig.base.InstancePointer(__createSceneMgrQueuedRenderableVisitor()), false);
    }

    private native static long __createSceneMgrQueuedRenderableVisitor();

    /** **/
    public void visit(org.ogre4j.IRenderable r) {
        _visit__Renderablep(this.object.pointer, r.getInstancePointer().pointer);
    }

    private native void _visit__Renderablep(long _pointer_, long r);

    /** **/
    public boolean visit(org.ogre4j.IPass p) {
         return _visit__PassP(this.object.pointer, p.getInstancePointer().pointer);
    }

    private native boolean _visit__PassP(long _pointer_, long p);

    /** **/
    public void visit(org.ogre4j.IRenderablePass rp) {
        _visit__RenderablePassp(this.object.pointer, rp.getInstancePointer().pointer);
    }

    private native void _visit__RenderablePassp(long _pointer_, long rp);

    /** **/
    public org.ogre4j.ISceneManager gettargetSceneMgr() {
         return new org.ogre4j.SceneManager(new InstancePointer(_gettargetSceneMgr(this.object.pointer)));
    }

    private native long _gettargetSceneMgr(long _pointer_);

    /** **/
    public void settargetSceneMgr(org.ogre4j.ISceneManager _jni_value_) {
        _settargetSceneMgr(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _settargetSceneMgr(long _pointer_, long _jni_value_);

    /** **/
    public boolean gettransparentShadowCastersMode() {
         return _gettransparentShadowCastersMode(this.object.pointer);
    }

    private native boolean _gettransparentShadowCastersMode(long _pointer_);

    /** **/
    public void settransparentShadowCastersMode(boolean _jni_value_) {
        _settransparentShadowCastersMode(this.object.pointer, _jni_value_);
    }

    private native void _settransparentShadowCastersMode(long _pointer_, boolean _jni_value_);

    /** **/
    public boolean getautoLights() {
         return _getautoLights(this.object.pointer);
    }

    private native boolean _getautoLights(long _pointer_);

    /** **/
    public void setautoLights(boolean _jni_value_) {
        _setautoLights(this.object.pointer, _jni_value_);
    }

    private native void _setautoLights(long _pointer_, boolean _jni_value_);

    /** **/
    public org.ogre4j.ILightList getmanualLightList() {
         return new org.ogre4j.LightList(new InstancePointer(_getmanualLightList(this.object.pointer)));
    }

    private native long _getmanualLightList(long _pointer_);

    /** **/
    public boolean getscissoring() {
         return _getscissoring(this.object.pointer);
    }

    private native boolean _getscissoring(long _pointer_);

    /** **/
    public void setscissoring(boolean _jni_value_) {
        _setscissoring(this.object.pointer, _jni_value_);
    }

    private native void _setscissoring(long _pointer_, boolean _jni_value_);

}
protected static class ShadowCasterSceneQueryListener extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.IShadowCasterSceneQueryListener {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public ShadowCasterSceneQueryListener(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected ShadowCasterSceneQueryListener(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public ShadowCasterSceneQueryListener(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public ShadowCasterSceneQueryListener(org.ogre4j.ISceneManager sm) {
         super( new org.xbig.base.InstancePointer(__createShadowCasterSceneQueryListener__SceneManagerp( sm.getInstancePointer().pointer)), false);
    }

    private native static long __createShadowCasterSceneQueryListener__SceneManagerp(long sm);

    /** **/
    public void prepare(boolean lightInFrustum, org.ogre4j.IPlaneBoundedVolumeList lightClipVolumes, org.ogre4j.ILight light, org.ogre4j.ICamera cam, org.ogre4j.ISceneManager.IShadowCasterList casterList, float farDistSquared) {
        _prepare__bvPlaneBoundedVolumeListPLightPCameraPShadowCasterListpRealv(this.object.pointer, lightInFrustum,  lightClipVolumes.getInstancePointer().pointer,  light.getInstancePointer().pointer,  cam.getInstancePointer().pointer,  casterList.getInstancePointer().pointer,  farDistSquared);
    }

    private native void _prepare__bvPlaneBoundedVolumeListPLightPCameraPShadowCasterListpRealv(long _pointer_, boolean lightInFrustum, long lightClipVolumes, long light, long cam, long casterList, float farDistSquared);

    /** **/
    public boolean queryResult(org.ogre4j.IMovableObject object) {
         return _queryResult__MovableObjectp(this.object.pointer, object.getInstancePointer().pointer);
    }

    private native boolean _queryResult__MovableObjectp(long _pointer_, long object);

    /** **/
    public boolean queryResult(org.ogre4j.ISceneQuery.IWorldFragment fragment) {
         return _queryResult__SceneQuery_WorldFragmentp(this.object.pointer, fragment.getInstancePointer().pointer);
    }

    private native boolean _queryResult__SceneQuery_WorldFragmentp(long _pointer_, long fragment);

}
protected static class LightClippingInfo extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.ILightClippingInfo {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public LightClippingInfo(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected LightClippingInfo(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public LightClippingInfo(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public LightClippingInfo() {
         super( new org.xbig.base.InstancePointer(__createLightClippingInfo()), false);
    }

    private native static long __createLightClippingInfo();

    /** **/
    public void getscissorRect(org.ogre4j.IRealRect returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getscissorRect(this.object.pointer)), false);
    }

    private native long _getscissorRect(long _pointer_);

    /** **/
    public void setscissorRect(org.ogre4j.IRealRect _jni_value_) {
        _setscissorRect(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setscissorRect(long _pointer_, long _jni_value_);

    /** **/
    public void getclipPlanes(org.ogre4j.IPlaneList returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getclipPlanes(this.object.pointer)), false);
    }

    private native long _getclipPlanes(long _pointer_);

    /** **/
    public void setclipPlanes(org.ogre4j.IPlaneList _jni_value_) {
        _setclipPlanes(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setclipPlanes(long _pointer_, long _jni_value_);

    /** **/
    public boolean getscissorValid() {
         return _getscissorValid(this.object.pointer);
    }

    private native boolean _getscissorValid(long _pointer_);

    /** **/
    public void setscissorValid(boolean _jni_value_) {
        _setscissorValid(this.object.pointer, _jni_value_);
    }

    private native void _setscissorValid(long _pointer_, boolean _jni_value_);

    /** **/
    public long getclipPlanesValid() {
         return _getclipPlanesValid(this.object.pointer);
    }

    private native long _getclipPlanesValid(long _pointer_);

    /** **/
    public void setclipPlanesValid(long _jni_value_) {
        _setclipPlanesValid(this.object.pointer, _jni_value_);
    }

    private native void _setclipPlanesValid(long _pointer_, long _jni_value_);

}
protected static class LightInfo extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.ILightInfo {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public LightInfo(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected LightInfo(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public LightInfo(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public boolean operatorEqual(org.ogre4j.ISceneManager.ILightInfo rhs) {
         return _operatorEqual__LightInfoR_const(this.object.pointer, rhs.getInstancePointer().pointer);
    }

    private native boolean _operatorEqual__LightInfoR_const(long _pointer_, long rhs);

    /** **/
    public boolean operatorNotEqual(org.ogre4j.ISceneManager.ILightInfo rhs) {
         return _operatorNotEqual__LightInfoR_const(this.object.pointer, rhs.getInstancePointer().pointer);
    }

    private native boolean _operatorNotEqual__LightInfoR_const(long _pointer_, long rhs);

    /** **/
    public LightInfo() {
         super( new org.xbig.base.InstancePointer(__createLightInfo()), false);
    }

    private native static long __createLightInfo();

    /** **/
    public org.ogre4j.ILight getlight() {
         return new org.ogre4j.Light(new InstancePointer(_getlight(this.object.pointer)));
    }

    private native long _getlight(long _pointer_);

    /** **/
    public void setlight(org.ogre4j.ILight _jni_value_) {
        _setlight(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setlight(long _pointer_, long _jni_value_);

    /** **/
    public int gettype() {
         return _gettype(this.object.pointer);
    }

    private native int _gettype(long _pointer_);

    /** **/
    public void settype(int _jni_value_) {
        _settype(this.object.pointer, _jni_value_);
    }

    private native void _settype(long _pointer_, int _jni_value_);

    /** **/
    public float getrange() {
         return _getrange(this.object.pointer);
    }

    private native float _getrange(long _pointer_);

    /** **/
    public void setrange(float _jni_value_) {
        _setrange(this.object.pointer, _jni_value_);
    }

    private native void _setrange(long _pointer_, float _jni_value_);

    /** **/
    public void getposition(org.ogre4j.IVector3 returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getposition(this.object.pointer)), false);
    }

    private native long _getposition(long _pointer_);

    /** **/
    public void setposition(org.ogre4j.IVector3 _jni_value_) {
        _setposition(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setposition(long _pointer_, long _jni_value_);

}
public static class lightLess extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.IlightLess {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public lightLess(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected lightLess(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public lightLess(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public boolean operatorFunctionCall(org.ogre4j.ILight a, org.ogre4j.ILight b) {
         return _operatorFunctionCall__LightPLightP_const(this.object.pointer, a.getInstancePointer().pointer,  b.getInstancePointer().pointer);
    }

    private native boolean _operatorFunctionCall__LightPLightP_const(long _pointer_, long a, long b);

    /** **/
    public lightLess() {
         super( new org.xbig.base.InstancePointer(__createlightLess()), false);
    }

    private native static long __createlightLess();

}
protected static class lightsForShadowTextureLess extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.IlightsForShadowTextureLess {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public lightsForShadowTextureLess(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected lightsForShadowTextureLess(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public lightsForShadowTextureLess(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public boolean operatorFunctionCall(org.ogre4j.ILight l1, org.ogre4j.ILight l2) {
         return _operatorFunctionCall__LightPLightP_const(this.object.pointer, l1.getInstancePointer().pointer,  l2.getInstancePointer().pointer);
    }

    private native boolean _operatorFunctionCall__LightPLightP_const(long _pointer_, long l1, long l2);

    /** **/
    public lightsForShadowTextureLess() {
         super( new org.xbig.base.InstancePointer(__createlightsForShadowTextureLess()), false);
    }

    private native static long __createlightsForShadowTextureLess();

}
public static class materialLess extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.ImaterialLess {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public materialLess(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected materialLess(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public materialLess(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public boolean operatorFunctionCall(org.ogre4j.IMaterial x, org.ogre4j.IMaterial y) {
         return _operatorFunctionCall__MaterialPMaterialP_const(this.object.pointer, x.getInstancePointer().pointer,  y.getInstancePointer().pointer);
    }

    private native boolean _operatorFunctionCall__MaterialPMaterialP_const(long _pointer_, long x, long y);

    /** **/
    public materialLess() {
         super( new org.xbig.base.InstancePointer(__creatematerialLess()), false);
    }

    private native static long __creatematerialLess();

}
protected static class MovableObjectCollection extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.IMovableObjectCollection {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public MovableObjectCollection(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected MovableObjectCollection(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public MovableObjectCollection(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public MovableObjectCollection() {
         super( new org.xbig.base.InstancePointer(__createMovableObjectCollection()), false);
    }

    private native static long __createMovableObjectCollection();

    /** **/
    public void getmap(org.ogre4j.ISceneManager.IMovableObjectMap returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getmap(this.object.pointer)), false);
    }

    private native long _getmap(long _pointer_);

    /** **/
    public void setmap(org.ogre4j.ISceneManager.IMovableObjectMap _jni_value_) {
        _setmap(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setmap(long _pointer_, long _jni_value_);

}
public static class SkyBoxGenParameters extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.ISkyBoxGenParameters {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public SkyBoxGenParameters(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected SkyBoxGenParameters(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public SkyBoxGenParameters(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public SkyBoxGenParameters() {
         super( new org.xbig.base.InstancePointer(__createSkyBoxGenParameters()), false);
    }

    private native static long __createSkyBoxGenParameters();

    /** **/
    public float getskyBoxDistance() {
         return _getskyBoxDistance(this.object.pointer);
    }

    private native float _getskyBoxDistance(long _pointer_);

    /** **/
    public void setskyBoxDistance(float _jni_value_) {
        _setskyBoxDistance(this.object.pointer, _jni_value_);
    }

    private native void _setskyBoxDistance(long _pointer_, float _jni_value_);

}
public static class SkyDomeGenParameters extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.ISkyDomeGenParameters {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public SkyDomeGenParameters(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected SkyDomeGenParameters(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public SkyDomeGenParameters(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public SkyDomeGenParameters() {
         super( new org.xbig.base.InstancePointer(__createSkyDomeGenParameters()), false);
    }

    private native static long __createSkyDomeGenParameters();

    /** **/
    public float getskyDomeCurvature() {
         return _getskyDomeCurvature(this.object.pointer);
    }

    private native float _getskyDomeCurvature(long _pointer_);

    /** **/
    public void setskyDomeCurvature(float _jni_value_) {
        _setskyDomeCurvature(this.object.pointer, _jni_value_);
    }

    private native void _setskyDomeCurvature(long _pointer_, float _jni_value_);

    /** **/
    public float getskyDomeTiling() {
         return _getskyDomeTiling(this.object.pointer);
    }

    private native float _getskyDomeTiling(long _pointer_);

    /** **/
    public void setskyDomeTiling(float _jni_value_) {
        _setskyDomeTiling(this.object.pointer, _jni_value_);
    }

    private native void _setskyDomeTiling(long _pointer_, float _jni_value_);

    /** **/
    public float getskyDomeDistance() {
         return _getskyDomeDistance(this.object.pointer);
    }

    private native float _getskyDomeDistance(long _pointer_);

    /** **/
    public void setskyDomeDistance(float _jni_value_) {
        _setskyDomeDistance(this.object.pointer, _jni_value_);
    }

    private native void _setskyDomeDistance(long _pointer_, float _jni_value_);

    /** **/
    public int getskyDomeXSegments() {
         return _getskyDomeXSegments(this.object.pointer);
    }

    private native int _getskyDomeXSegments(long _pointer_);

    /** **/
    public void setskyDomeXSegments(int _jni_value_) {
        _setskyDomeXSegments(this.object.pointer, _jni_value_);
    }

    private native void _setskyDomeXSegments(long _pointer_, int _jni_value_);

    /** **/
    public int getskyDomeYSegments() {
         return _getskyDomeYSegments(this.object.pointer);
    }

    private native int _getskyDomeYSegments(long _pointer_);

    /** **/
    public void setskyDomeYSegments(int _jni_value_) {
        _setskyDomeYSegments(this.object.pointer, _jni_value_);
    }

    private native void _setskyDomeYSegments(long _pointer_, int _jni_value_);

    /** **/
    public int getskyDomeYSegments_keep() {
         return _getskyDomeYSegments_keep(this.object.pointer);
    }

    private native int _getskyDomeYSegments_keep(long _pointer_);

    /** **/
    public void setskyDomeYSegments_keep(int _jni_value_) {
        _setskyDomeYSegments_keep(this.object.pointer, _jni_value_);
    }

    private native void _setskyDomeYSegments_keep(long _pointer_, int _jni_value_);

}
public static class SkyPlaneGenParameters extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.ISkyPlaneGenParameters {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public SkyPlaneGenParameters(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected SkyPlaneGenParameters(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public SkyPlaneGenParameters(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public SkyPlaneGenParameters() {
         super( new org.xbig.base.InstancePointer(__createSkyPlaneGenParameters()), false);
    }

    private native static long __createSkyPlaneGenParameters();

    /** **/
    public float getskyPlaneScale() {
         return _getskyPlaneScale(this.object.pointer);
    }

    private native float _getskyPlaneScale(long _pointer_);

    /** **/
    public void setskyPlaneScale(float _jni_value_) {
        _setskyPlaneScale(this.object.pointer, _jni_value_);
    }

    private native void _setskyPlaneScale(long _pointer_, float _jni_value_);

    /** **/
    public float getskyPlaneTiling() {
         return _getskyPlaneTiling(this.object.pointer);
    }

    private native float _getskyPlaneTiling(long _pointer_);

    /** **/
    public void setskyPlaneTiling(float _jni_value_) {
        _setskyPlaneTiling(this.object.pointer, _jni_value_);
    }

    private native void _setskyPlaneTiling(long _pointer_, float _jni_value_);

    /** **/
    public float getskyPlaneBow() {
         return _getskyPlaneBow(this.object.pointer);
    }

    private native float _getskyPlaneBow(long _pointer_);

    /** **/
    public void setskyPlaneBow(float _jni_value_) {
        _setskyPlaneBow(this.object.pointer, _jni_value_);
    }

    private native void _setskyPlaneBow(long _pointer_, float _jni_value_);

    /** **/
    public int getskyPlaneXSegments() {
         return _getskyPlaneXSegments(this.object.pointer);
    }

    private native int _getskyPlaneXSegments(long _pointer_);

    /** **/
    public void setskyPlaneXSegments(int _jni_value_) {
        _setskyPlaneXSegments(this.object.pointer, _jni_value_);
    }

    private native void _setskyPlaneXSegments(long _pointer_, int _jni_value_);

    /** **/
    public int getskyPlaneYSegments() {
         return _getskyPlaneYSegments(this.object.pointer);
    }

    private native int _getskyPlaneYSegments(long _pointer_);

    /** **/
    public void setskyPlaneYSegments(int _jni_value_) {
        _setskyPlaneYSegments(this.object.pointer, _jni_value_);
    }

    private native void _setskyPlaneYSegments(long _pointer_, int _jni_value_);

}
public enum IlluminationRenderStage implements INativeEnum < IlluminationRenderStage > {
    IRS_NONE(IlluminationRenderStageHelper.ENUM_VALUES[0]),
    IRS_RENDER_TO_TEXTURE(IlluminationRenderStageHelper.ENUM_VALUES[1]),
    IRS_RENDER_RECEIVER_PASS(IlluminationRenderStageHelper.ENUM_VALUES[2]);

    private int value;

    IlluminationRenderStage(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public IlluminationRenderStage getEnum(int val) {
        return toEnum(val);
    }

    public static final IlluminationRenderStage toEnum(int retval) {
    if (retval ==IRS_NONE.value)
        return IlluminationRenderStage.IRS_NONE;
    else if (retval ==IRS_RENDER_TO_TEXTURE.value)
        return IlluminationRenderStage.IRS_RENDER_TO_TEXTURE;
    else if (retval ==IRS_RENDER_RECEIVER_PASS.value)
        return IlluminationRenderStage.IRS_RENDER_RECEIVER_PASS;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class IlluminationRenderStageHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

public enum SpecialCaseRenderQueueMode implements INativeEnum < SpecialCaseRenderQueueMode > {
    SCRQM_INCLUDE(SpecialCaseRenderQueueModeHelper.ENUM_VALUES[0]),
    SCRQM_EXCLUDE(SpecialCaseRenderQueueModeHelper.ENUM_VALUES[1]);

    private int value;

    SpecialCaseRenderQueueMode(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public SpecialCaseRenderQueueMode getEnum(int val) {
        return toEnum(val);
    }

    public static final SpecialCaseRenderQueueMode toEnum(int retval) {
    if (retval ==SCRQM_INCLUDE.value)
        return SpecialCaseRenderQueueMode.SCRQM_INCLUDE;
    else if (retval ==SCRQM_EXCLUDE.value)
        return SpecialCaseRenderQueueMode.SCRQM_EXCLUDE;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class SpecialCaseRenderQueueModeHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

public enum PrefabType implements INativeEnum < PrefabType > {
    PT_PLANE(PrefabTypeHelper.ENUM_VALUES[0]),
    PT_CUBE(PrefabTypeHelper.ENUM_VALUES[1]),
    PT_SPHERE(PrefabTypeHelper.ENUM_VALUES[2]);

    private int value;

    PrefabType(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public PrefabType getEnum(int val) {
        return toEnum(val);
    }

    public static final PrefabType toEnum(int retval) {
    if (retval ==PT_PLANE.value)
        return PrefabType.PT_PLANE;
    else if (retval ==PT_CUBE.value)
        return PrefabType.PT_CUBE;
    else if (retval ==PT_SPHERE.value)
        return PrefabType.PT_SPHERE;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class PrefabTypeHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

protected enum BoxPlane implements INativeEnum < BoxPlane > {
    BP_FRONT(BoxPlaneHelper.ENUM_VALUES[0]),
    BP_BACK(BoxPlaneHelper.ENUM_VALUES[1]),
    BP_LEFT(BoxPlaneHelper.ENUM_VALUES[2]),
    BP_RIGHT(BoxPlaneHelper.ENUM_VALUES[3]),
    BP_UP(BoxPlaneHelper.ENUM_VALUES[4]),
    BP_DOWN(BoxPlaneHelper.ENUM_VALUES[5]);

    private int value;

    BoxPlane(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public BoxPlane getEnum(int val) {
        return toEnum(val);
    }

    public static final BoxPlane toEnum(int retval) {
    if (retval ==BP_FRONT.value)
        return BoxPlane.BP_FRONT;
    else if (retval ==BP_BACK.value)
        return BoxPlane.BP_BACK;
    else if (retval ==BP_LEFT.value)
        return BoxPlane.BP_LEFT;
    else if (retval ==BP_RIGHT.value)
        return BoxPlane.BP_RIGHT;
    else if (retval ==BP_UP.value)
        return BoxPlane.BP_UP;
    else if (retval ==BP_DOWN.value)
        return BoxPlane.BP_DOWN;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class BoxPlaneHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

public static class CameraIterator extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.ICameraIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public CameraIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected CameraIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public CameraIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public org.ogre4j.ICamera getNext() {
         return new org.ogre4j.Camera(new InstancePointer(_getNext(this.object.pointer)));
    }

    private native long _getNext(long _pointer_);

    /** **/
    public org.ogre4j.ICamera peekNextValue() {
         return new org.ogre4j.Camera(new InstancePointer(_peekNextValue(this.object.pointer)));
    }

    private native long _peekNextValue(long _pointer_);

    /** **/
    public String peekNextKey() {
         return _peekNextKey(this.object.pointer);
    }

    private native String _peekNextKey(long _pointer_);

    /** **/
    public org.ogre4j.ISceneManager.ICameraIterator operatorAssignment(org.ogre4j.ISceneManager.ICameraIterator rhs) {
         return new org.ogre4j.SceneManager.CameraIterator(new InstancePointer(_operatorAssignment___Ogre_SceneManager_CameraIteratorr(this.object.pointer, rhs.getInstancePointer().pointer)));
    }

    private native long _operatorAssignment___Ogre_SceneManager_CameraIteratorr(long _pointer_, long rhs);

    /** **/
    public NativeObjectPointer<org.ogre4j.ICamera> peekNextValuePtr() {
         return new NativeObjectPointer<org.ogre4j.ICamera>(new InstancePointer(_peekNextValuePtr(this.object.pointer)));
    }

    private native long _peekNextValuePtr(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext(this.object.pointer);
    }

    private native void _moveNext(long _pointer_);

}
public static class AnimationIterator extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.IAnimationIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public AnimationIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected AnimationIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public AnimationIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public org.ogre4j.IAnimation getNext() {
         return new org.ogre4j.Animation(new InstancePointer(_getNext(this.object.pointer)));
    }

    private native long _getNext(long _pointer_);

    /** **/
    public org.ogre4j.IAnimation peekNextValue() {
         return new org.ogre4j.Animation(new InstancePointer(_peekNextValue(this.object.pointer)));
    }

    private native long _peekNextValue(long _pointer_);

    /** **/
    public String peekNextKey() {
         return _peekNextKey(this.object.pointer);
    }

    private native String _peekNextKey(long _pointer_);

    /** **/
    public org.ogre4j.ISceneManager.IAnimationIterator operatorAssignment(org.ogre4j.ISceneManager.IAnimationIterator rhs) {
         return new org.ogre4j.SceneManager.AnimationIterator(new InstancePointer(_operatorAssignment___Ogre_SceneManager_AnimationIteratorr(this.object.pointer, rhs.getInstancePointer().pointer)));
    }

    private native long _operatorAssignment___Ogre_SceneManager_AnimationIteratorr(long _pointer_, long rhs);

    /** **/
    public NativeObjectPointer<org.ogre4j.IAnimation> peekNextValuePtr() {
         return new NativeObjectPointer<org.ogre4j.IAnimation>(new InstancePointer(_peekNextValuePtr(this.object.pointer)));
    }

    private native long _peekNextValuePtr(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext(this.object.pointer);
    }

    private native void _moveNext(long _pointer_);

}
public static class MovableObjectIterator extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.IMovableObjectIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public MovableObjectIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected MovableObjectIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public MovableObjectIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public org.ogre4j.IMovableObject getNext() {
         return new org.ogre4j.MovableObject(new InstancePointer(_getNext(this.object.pointer)));
    }

    private native long _getNext(long _pointer_);

    /** **/
    public org.ogre4j.IMovableObject peekNextValue() {
         return new org.ogre4j.MovableObject(new InstancePointer(_peekNextValue(this.object.pointer)));
    }

    private native long _peekNextValue(long _pointer_);

    /** **/
    public String peekNextKey() {
         return _peekNextKey(this.object.pointer);
    }

    private native String _peekNextKey(long _pointer_);

    /** **/
    public org.ogre4j.ISceneManager.IMovableObjectIterator operatorAssignment(org.ogre4j.ISceneManager.IMovableObjectIterator rhs) {
         return new org.ogre4j.SceneManager.MovableObjectIterator(new InstancePointer(_operatorAssignment___Ogre_SceneManager_MovableObjectIteratorr(this.object.pointer, rhs.getInstancePointer().pointer)));
    }

    private native long _operatorAssignment___Ogre_SceneManager_MovableObjectIteratorr(long _pointer_, long rhs);

    /** **/
    public NativeObjectPointer<org.ogre4j.IMovableObject> peekNextValuePtr() {
         return new NativeObjectPointer<org.ogre4j.IMovableObject>(new InstancePointer(_peekNextValuePtr(this.object.pointer)));
    }

    private native long _peekNextValuePtr(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext(this.object.pointer);
    }

    private native void _moveNext(long _pointer_);

}
protected static class CameraList extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.ICameraList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public CameraList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected CameraList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public CameraList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public CameraList() {
         super( new org.xbig.base.InstancePointer(__createCameraList()), false);
    }

    private native static long __createCameraList();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.ICamera get(String key) {
         return new org.ogre4j.Camera(new InstancePointer(_get__sR(this.object.pointer, key)));
    }

    private native long _get__sR(long _pointer_, String key);

    /** **/
    public void insert(String key, org.ogre4j.ICamera value) {
        _insert__sROgre_Camerap(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__sROgre_Camerap(long _pointer_, String key, long value);

}
protected static class StaticGeometryList extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.IStaticGeometryList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public StaticGeometryList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected StaticGeometryList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public StaticGeometryList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public StaticGeometryList() {
         super( new org.xbig.base.InstancePointer(__createStaticGeometryList()), false);
    }

    private native static long __createStaticGeometryList();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.IStaticGeometry get(String key) {
         return new org.ogre4j.StaticGeometry(new InstancePointer(_get__sR(this.object.pointer, key)));
    }

    private native long _get__sR(long _pointer_, String key);

    /** **/
    public void insert(String key, org.ogre4j.IStaticGeometry value) {
        _insert__sROgre_StaticGeometryp(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__sROgre_StaticGeometryp(long _pointer_, String key, long value);

}
protected static class InstancedGeometryList extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.IInstancedGeometryList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public InstancedGeometryList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected InstancedGeometryList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public InstancedGeometryList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public InstancedGeometryList() {
         super( new org.xbig.base.InstancePointer(__createInstancedGeometryList()), false);
    }

    private native static long __createInstancedGeometryList();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.IInstancedGeometry get(String key) {
         return new org.ogre4j.InstancedGeometry(new InstancePointer(_get__sR(this.object.pointer, key)));
    }

    private native long _get__sR(long _pointer_, String key);

    /** **/
    public void insert(String key, org.ogre4j.IInstancedGeometry value) {
        _insert__sROgre_InstancedGeometryp(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__sROgre_InstancedGeometryp(long _pointer_, String key, long value);

}
protected static class SceneNodeList extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.ISceneNodeList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public SceneNodeList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected SceneNodeList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public SceneNodeList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public SceneNodeList() {
         super( new org.xbig.base.InstancePointer(__createSceneNodeList()), false);
    }

    private native static long __createSceneNodeList();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.ISceneNode get(String key) {
         return new org.ogre4j.SceneNode(new InstancePointer(_get__sR(this.object.pointer, key)));
    }

    private native long _get__sR(long _pointer_, String key);

    /** **/
    public void insert(String key, org.ogre4j.ISceneNode value) {
        _insert__sROgre_SceneNodep(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__sROgre_SceneNodep(long _pointer_, String key, long value);

}
protected static class AutoTrackingSceneNodes extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.IAutoTrackingSceneNodes {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public AutoTrackingSceneNodes(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected AutoTrackingSceneNodes(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public AutoTrackingSceneNodes(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public AutoTrackingSceneNodes() {
         super( new org.xbig.base.InstancePointer(__createAutoTrackingSceneNodes()), false);
    }

    private native static long __createAutoTrackingSceneNodes();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(org.ogre4j.ISceneNode key) {
         return _count__Ogre_SceneNodeP(this.object.pointer, key.getInstancePointer().pointer);
    }

    private native int _count__Ogre_SceneNodeP(long _pointer_, long key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(org.ogre4j.ISceneNode key) {
         return _erase__Ogre_SceneNodeP(this.object.pointer, key.getInstancePointer().pointer);
    }

    private native int _erase__Ogre_SceneNodeP(long _pointer_, long key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

}
protected static class SpecialCaseRenderQueueList extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.ISpecialCaseRenderQueueList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public SpecialCaseRenderQueueList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected SpecialCaseRenderQueueList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public SpecialCaseRenderQueueList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public SpecialCaseRenderQueueList() {
         super( new org.xbig.base.InstancePointer(__createSpecialCaseRenderQueueList()), false);
    }

    private native static long __createSpecialCaseRenderQueueList();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(short key) {
         return _count__BR(this.object.pointer, key);
    }

    private native int _count__BR(long _pointer_, short key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(short key) {
         return _erase__BR(this.object.pointer, key);
    }

    private native int _erase__BR(long _pointer_, short key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

}
protected static class CamVisibleObjectsMap extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.ICamVisibleObjectsMap {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public CamVisibleObjectsMap(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected CamVisibleObjectsMap(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public CamVisibleObjectsMap(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public CamVisibleObjectsMap() {
         super( new org.xbig.base.InstancePointer(__createCamVisibleObjectsMap()), false);
    }

    private native static long __createCamVisibleObjectsMap();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(org.ogre4j.ICamera key) {
         return _count__Ogre_CameraP(this.object.pointer, key.getInstancePointer().pointer);
    }

    private native int _count__Ogre_CameraP(long _pointer_, long key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(org.ogre4j.ICamera key) {
         return _erase__Ogre_CameraP(this.object.pointer, key.getInstancePointer().pointer);
    }

    private native int _erase__Ogre_CameraP(long _pointer_, long key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.IVisibleObjectsBoundsInfo get(org.ogre4j.ICamera key) {
         return new org.ogre4j.VisibleObjectsBoundsInfo(new InstancePointer(_get__Ogre_CameraP(this.object.pointer, key.getInstancePointer().pointer)));
    }

    private native long _get__Ogre_CameraP(long _pointer_, long key);

    /** **/
    public void insert(org.ogre4j.ICamera key, org.ogre4j.IVisibleObjectsBoundsInfo value) {
        _insert__Ogre_CameraPOgre_VisibleObjectsBoundsInfor(this.object.pointer, key.getInstancePointer().pointer,  value.getInstancePointer().pointer);
    }

    private native void _insert__Ogre_CameraPOgre_VisibleObjectsBoundsInfor(long _pointer_, long key, long value);

}
protected static class ShadowCamLightMapping extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.IShadowCamLightMapping {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public ShadowCamLightMapping(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected ShadowCamLightMapping(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public ShadowCamLightMapping(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public ShadowCamLightMapping() {
         super( new org.xbig.base.InstancePointer(__createShadowCamLightMapping()), false);
    }

    private native static long __createShadowCamLightMapping();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(org.ogre4j.ICamera key) {
         return _count__Ogre_CameraP(this.object.pointer, key.getInstancePointer().pointer);
    }

    private native int _count__Ogre_CameraP(long _pointer_, long key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(org.ogre4j.ICamera key) {
         return _erase__Ogre_CameraP(this.object.pointer, key.getInstancePointer().pointer);
    }

    private native int _erase__Ogre_CameraP(long _pointer_, long key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.ILight get(org.ogre4j.ICamera key) {
         return new org.ogre4j.Light(new InstancePointer(_get__Ogre_CameraP(this.object.pointer, key.getInstancePointer().pointer)));
    }

    private native long _get__Ogre_CameraP(long _pointer_, long key);

    /** **/
    public void insert(org.ogre4j.ICamera key, org.ogre4j.ILight value) {
        _insert__Ogre_CameraPOgre_LightP(this.object.pointer, key.getInstancePointer().pointer,  value.getInstancePointer().pointer);
    }

    private native void _insert__Ogre_CameraPOgre_LightP(long _pointer_, long key, long value);

}
protected static class LightInfoList extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.ILightInfoList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public LightInfoList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected LightInfoList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public LightInfoList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public LightInfoList() {
         super( new org.xbig.base.InstancePointer(__createLightInfoList()), false);
    }

    private native static long __createLightInfoList();

    /** **/
    public void assign(int num, org.ogre4j.ISceneManager.ILightInfo val) {
        _assign__ivOgre_SceneManager_LightInfoR(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_SceneManager_LightInfoR(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.ISceneManager.ILightInfo at(int loc) {
         return new org.ogre4j.SceneManager.LightInfo(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.ISceneManager.ILightInfo back() {
         return new org.ogre4j.SceneManager.LightInfo(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.ISceneManager.ILightInfo front() {
         return new org.ogre4j.SceneManager.LightInfo(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.ISceneManager.ILightInfo val) {
        _push_back__Ogre_SceneManager_LightInfoR(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_SceneManager_LightInfoR(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
protected static class MovableObjectMap extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.IMovableObjectMap {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public MovableObjectMap(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected MovableObjectMap(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public MovableObjectMap(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public MovableObjectMap() {
         super( new org.xbig.base.InstancePointer(__createMovableObjectMap()), false);
    }

    private native static long __createMovableObjectMap();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.IMovableObject get(String key) {
         return new org.ogre4j.MovableObject(new InstancePointer(_get__sR(this.object.pointer, key)));
    }

    private native long _get__sR(long _pointer_, String key);

    /** **/
    public void insert(String key, org.ogre4j.IMovableObject value) {
        _insert__sROgre_MovableObjectp(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__sROgre_MovableObjectp(long _pointer_, String key, long value);

}
protected static class MovableObjectCollectionMap extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.IMovableObjectCollectionMap {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public MovableObjectCollectionMap(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected MovableObjectCollectionMap(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public MovableObjectCollectionMap(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public MovableObjectCollectionMap() {
         super( new org.xbig.base.InstancePointer(__createMovableObjectCollectionMap()), false);
    }

    private native static long __createMovableObjectCollectionMap();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.ISceneManager.IMovableObjectCollection get(String key) {
         return new org.ogre4j.SceneManager.MovableObjectCollection(new InstancePointer(_get__sR(this.object.pointer, key)));
    }

    private native long _get__sR(long _pointer_, String key);

    /** **/
    public void insert(String key, org.ogre4j.ISceneManager.IMovableObjectCollection value) {
        _insert__sROgre_SceneManager_MovableObjectCollectionp(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__sROgre_SceneManager_MovableObjectCollectionp(long _pointer_, String key, long value);

}
protected static class AnimationList extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.IAnimationList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public AnimationList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected AnimationList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public AnimationList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public AnimationList() {
         super( new org.xbig.base.InstancePointer(__createAnimationList()), false);
    }

    private native static long __createAnimationList();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.IAnimation get(String key) {
         return new org.ogre4j.Animation(new InstancePointer(_get__sR(this.object.pointer, key)));
    }

    private native long _get__sR(long _pointer_, String key);

    /** **/
    public void insert(String key, org.ogre4j.IAnimation value) {
        _insert__sROgre_Animationp(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__sROgre_Animationp(long _pointer_, String key, long value);

}
protected static class RenderQueueListenerList extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.IRenderQueueListenerList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public RenderQueueListenerList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected RenderQueueListenerList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public RenderQueueListenerList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public RenderQueueListenerList() {
         super( new org.xbig.base.InstancePointer(__createRenderQueueListenerList()), false);
    }

    private native static long __createRenderQueueListenerList();

    /** **/
    public void assign(int num, org.ogre4j.IRenderQueueListener val) {
        _assign__ivOgre_RenderQueueListenerP(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_RenderQueueListenerP(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.IRenderQueueListener at(int loc) {
         return new org.ogre4j.RenderQueueListener(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.IRenderQueueListener back() {
         return new org.ogre4j.RenderQueueListener(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.IRenderQueueListener front() {
         return new org.ogre4j.RenderQueueListener(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.IRenderQueueListener val) {
        _push_back__Ogre_RenderQueueListenerP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_RenderQueueListenerP(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
protected static class ListenerList extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.IListenerList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public ListenerList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected ListenerList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public ListenerList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public ListenerList() {
         super( new org.xbig.base.InstancePointer(__createListenerList()), false);
    }

    private native static long __createListenerList();

    /** **/
    public void assign(int num, org.ogre4j.ISceneManager.IListener val) {
        _assign__ivOgre_SceneManager_ListenerP(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_SceneManager_ListenerP(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.ISceneManager.IListener at(int loc) {
         return new org.ogre4j.SceneManager.Listener(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.ISceneManager.IListener back() {
         return new org.ogre4j.SceneManager.Listener(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.ISceneManager.IListener front() {
         return new org.ogre4j.SceneManager.Listener(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.ISceneManager.IListener val) {
        _push_back__Ogre_SceneManager_ListenerP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_SceneManager_ListenerP(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
protected static class ShadowTextureCameraList extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.IShadowTextureCameraList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public ShadowTextureCameraList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected ShadowTextureCameraList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public ShadowTextureCameraList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public ShadowTextureCameraList() {
         super( new org.xbig.base.InstancePointer(__createShadowTextureCameraList()), false);
    }

    private native static long __createShadowTextureCameraList();

    /** **/
    public void assign(int num, org.ogre4j.ICamera val) {
        _assign__ivOgre_CameraP(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_CameraP(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.ICamera at(int loc) {
         return new org.ogre4j.Camera(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.ICamera back() {
         return new org.ogre4j.Camera(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.ICamera front() {
         return new org.ogre4j.Camera(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.ICamera val) {
        _push_back__Ogre_CameraP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_CameraP(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
protected static class LightClippingInfoMap extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.ILightClippingInfoMap {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public LightClippingInfoMap(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected LightClippingInfoMap(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public LightClippingInfoMap(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public LightClippingInfoMap() {
         super( new org.xbig.base.InstancePointer(__createLightClippingInfoMap()), false);
    }

    private native static long __createLightClippingInfoMap();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(org.ogre4j.ILight key) {
         return _count__Ogre_LightP(this.object.pointer, key.getInstancePointer().pointer);
    }

    private native int _count__Ogre_LightP(long _pointer_, long key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(org.ogre4j.ILight key) {
         return _erase__Ogre_LightP(this.object.pointer, key.getInstancePointer().pointer);
    }

    private native int _erase__Ogre_LightP(long _pointer_, long key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.ISceneManager.ILightClippingInfo get(org.ogre4j.ILight key) {
         return new org.ogre4j.SceneManager.LightClippingInfo(new InstancePointer(_get__Ogre_LightP(this.object.pointer, key.getInstancePointer().pointer)));
    }

    private native long _get__Ogre_LightP(long _pointer_, long key);

    /** **/
    public void insert(org.ogre4j.ILight key, org.ogre4j.ISceneManager.ILightClippingInfo value) {
        _insert__Ogre_LightPOgre_SceneManager_LightClippingInfor(this.object.pointer, key.getInstancePointer().pointer,  value.getInstancePointer().pointer);
    }

    private native void _insert__Ogre_LightPOgre_SceneManager_LightClippingInfor(long _pointer_, long key, long value);

}
protected static class ShadowCasterList extends org.xbig.base.NativeObject implements org.ogre4j.ISceneManager.IShadowCasterList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public ShadowCasterList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected ShadowCasterList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public ShadowCasterList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public ShadowCasterList() {
         super( new org.xbig.base.InstancePointer(__createShadowCasterList()), false);
    }

    private native static long __createShadowCasterList();

    /** **/
    public void assign(int num, org.ogre4j.IShadowCaster val) {
        _assign__ivOgre_ShadowCasterP(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_ShadowCasterP(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.IShadowCaster at(int loc) {
         return new org.ogre4j.ShadowCaster(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.IShadowCaster back() {
         return new org.ogre4j.ShadowCaster(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.IShadowCaster front() {
         return new org.ogre4j.ShadowCaster(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.IShadowCaster val) {
        _push_back__Ogre_ShadowCasterP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_ShadowCasterP(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public SceneManager(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected SceneManager(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public SceneManager(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** 
    Return the instance name of this . **/
    public String getName() {
         return _getName_const(this.object.pointer);
    }

    private native String _getName_const(long _pointer_);

    /** 
    Retrieve the type name of this scene manager. **/
    public String getTypeName() {
         return _getTypeName_const(this.object.pointer);
    }

    private native String _getTypeName_const(long _pointer_);

    /** 
    Creates a camera to be managed by this scene manager. **/
    public org.ogre4j.ICamera createCamera(String name) {
         return new org.ogre4j.Camera(new InstancePointer(_createCamera__StringR(this.object.pointer, name)));
    }

    private native long _createCamera__StringR(long _pointer_, String name);

    /** 
    Retrieves a pointer to the named camera. **/
    public org.ogre4j.ICamera getCamera(String name) {
         return new org.ogre4j.Camera(new InstancePointer(_getCamera__StringR_const(this.object.pointer, name)));
    }

    private native long _getCamera__StringR_const(long _pointer_, String name);

    /** 
    Returns whether a camera with the given name exists. **/
    public boolean hasCamera(String name) {
         return _hasCamera__StringR_const(this.object.pointer, name);
    }

    private native boolean _hasCamera__StringR_const(long _pointer_, String name);

    /** 
    Removes a camera from the scene. **/
    public void destroyCamera(org.ogre4j.ICamera cam) {
        _destroyCamera__Camerap(this.object.pointer, cam.getInstancePointer().pointer);
    }

    private native void _destroyCamera__Camerap(long _pointer_, long cam);

    /** 
    Removes a camera from the scene. **/
    public void destroyCamera(String name) {
        _destroyCamera__StringR(this.object.pointer, name);
    }

    private native void _destroyCamera__StringR(long _pointer_, String name);

    /** 
    Removes (and destroys) all cameras from the scene. **/
    public void destroyAllCameras() {
        _destroyAllCameras(this.object.pointer);
    }

    private native void _destroyAllCameras(long _pointer_);

    /** 
    Creates a light for use in the scene. **/
    public org.ogre4j.ILight createLight(String name) {
         return new org.ogre4j.Light(new InstancePointer(_createLight__StringR(this.object.pointer, name)));
    }

    private native long _createLight__StringR(long _pointer_, String name);

    /** 
    Returns a pointer to the named  which has previously been added to the scene. **/
    public org.ogre4j.ILight getLight(String name) {
         return new org.ogre4j.Light(new InstancePointer(_getLight__StringR_const(this.object.pointer, name)));
    }

    private native long _getLight__StringR_const(long _pointer_, String name);

    /** 
    Returns whether a light with the given name exists. **/
    public boolean hasLight(String name) {
         return _hasLight__StringR_const(this.object.pointer, name);
    }

    private native boolean _hasLight__StringR_const(long _pointer_, String name);

    /** 
    Retrieve a set of clipping planes for a given light. **/
    public org.ogre4j.IPlaneList getLightClippingPlanes(org.ogre4j.ILight l) {
         return new org.ogre4j.PlaneList(new InstancePointer(_getLightClippingPlanes__Lightp(this.object.pointer, l.getInstancePointer().pointer)));
    }

    private native long _getLightClippingPlanes__Lightp(long _pointer_, long l);

    /** 
    Retrieve a scissor rectangle for a given light and camera. **/
    public org.ogre4j.IRealRect getLightScissorRect(org.ogre4j.ILight l, org.ogre4j.ICamera cam) {
         return new org.ogre4j.RealRect(new InstancePointer(_getLightScissorRect__LightpCameraP(this.object.pointer, l.getInstancePointer().pointer,  cam.getInstancePointer().pointer)));
    }

    private native long _getLightScissorRect__LightpCameraP(long _pointer_, long l, long cam);

    /** 
    Removes the named light from the scene and destroys it. **/
    public void destroyLight(String name) {
        _destroyLight__StringR(this.object.pointer, name);
    }

    private native void _destroyLight__StringR(long _pointer_, String name);

    /** 
    Removes the light from the scene and destroys it based on a pointer. **/
    public void destroyLight(org.ogre4j.ILight light) {
        _destroyLight__Lightp(this.object.pointer, light.getInstancePointer().pointer);
    }

    private native void _destroyLight__Lightp(long _pointer_, long light);

    /** 
    Removes and destroys all lights in the scene. **/
    public void destroyAllLights() {
        _destroyAllLights(this.object.pointer);
    }

    private native void _destroyAllLights(long _pointer_);

    /** 
    Advance method to increase the lights dirty counter due lights changed. **/
    public void _notifyLightsDirty() {
        __notifyLightsDirty(this.object.pointer);
    }

    private native void __notifyLightsDirty(long _pointer_);

    /** 
    Advance method to gets the lights dirty counter. **/
    public long _getLightsDirtyCounter() {
         return __getLightsDirtyCounter_const(this.object.pointer);
    }

    private native long __getLightsDirtyCounter_const(long _pointer_);

    /** 
    Get the list of lights which could be affecting the frustum. **/
    public org.ogre4j.ILightList _getLightsAffectingFrustum() {
         return new org.ogre4j.LightList(new InstancePointer(__getLightsAffectingFrustum_const(this.object.pointer)));
    }

    private native long __getLightsAffectingFrustum_const(long _pointer_);

    /** 
    Populate a light list with an ordered set of the lights which are closest to the position specified. **/
    public void _populateLightList(org.ogre4j.IVector3 position, float radius, org.ogre4j.ILightList destList) {
        __populateLightList__Vector3RRealvLightListr(this.object.pointer, position.getInstancePointer().pointer,  radius,  destList.getInstancePointer().pointer);
    }

    private native void __populateLightList__Vector3RRealvLightListr(long _pointer_, long position, float radius, long destList);

    /** 
    Creates an instance of a . **/
    public org.ogre4j.ISceneNode createSceneNode() {
         return new org.ogre4j.SceneNode(new InstancePointer(_createSceneNode(this.object.pointer)));
    }

    private native long _createSceneNode(long _pointer_);

    /** 
    Creates an instance of a  with a given name. **/
    public org.ogre4j.ISceneNode createSceneNode(String name) {
         return new org.ogre4j.SceneNode(new InstancePointer(_createSceneNode__StringR(this.object.pointer, name)));
    }

    private native long _createSceneNode__StringR(long _pointer_, String name);

    /** 
    Destroys a  with a given name. **/
    public void destroySceneNode(String name) {
        _destroySceneNode__StringR(this.object.pointer, name);
    }

    private native void _destroySceneNode__StringR(long _pointer_, String name);

    /** 
    Destroys a . **/
    public void destroySceneNode(org.ogre4j.ISceneNode sn) {
        _destroySceneNode__SceneNodep(this.object.pointer, sn.getInstancePointer().pointer);
    }

    private native void _destroySceneNode__SceneNodep(long _pointer_, long sn);

    /** 
    Gets the  at the root of the scene hierarchy. **/
    public org.ogre4j.ISceneNode getRootSceneNode() {
         return new org.ogre4j.SceneNode(new InstancePointer(_getRootSceneNode(this.object.pointer)));
    }

    private native long _getRootSceneNode(long _pointer_);

    /** 
    Retrieves a named  from the scene graph. **/
    public org.ogre4j.ISceneNode getSceneNode(String name) {
         return new org.ogre4j.SceneNode(new InstancePointer(_getSceneNode__StringR_const(this.object.pointer, name)));
    }

    private native long _getSceneNode__StringR_const(long _pointer_, String name);

    /** 
    Returns whether a scene node with the given name exists. **/
    public boolean hasSceneNode(String name) {
         return _hasSceneNode__StringR_const(this.object.pointer, name);
    }

    private native boolean _hasSceneNode__StringR_const(long _pointer_, String name);

    /** 
    Create an  (instance of a discrete mesh). **/
    public org.ogre4j.IEntity createEntity(String entityName, String meshName) {
         return new org.ogre4j.Entity(new InstancePointer(_createEntity__StringRStringR(this.object.pointer, entityName,  meshName)));
    }

    private native long _createEntity__StringRStringR(long _pointer_, String entityName, String meshName);

    /** 
    Create an  (instance of a discrete mesh) from a range of prefab shapes. **/
    public org.ogre4j.IEntity createEntity(String entityName, org.ogre4j.SceneManager.PrefabType ptype) {
         return new org.ogre4j.Entity(new InstancePointer(_createEntity__StringRPrefabTypev(this.object.pointer, entityName,  ptype.getValue())));
    }

    private native long _createEntity__StringRPrefabTypev(long _pointer_, String entityName, int ptype);

    /** 
    Retrieves a pointer to the named . **/
    public org.ogre4j.IEntity getEntity(String name) {
         return new org.ogre4j.Entity(new InstancePointer(_getEntity__StringR_const(this.object.pointer, name)));
    }

    private native long _getEntity__StringR_const(long _pointer_, String name);

    /** 
    Returns whether an entity with the given name exists. **/
    public boolean hasEntity(String name) {
         return _hasEntity__StringR_const(this.object.pointer, name);
    }

    private native boolean _hasEntity__StringR_const(long _pointer_, String name);

    /** 
    Removes & destroys an  from the . **/
    public void destroyEntity(org.ogre4j.IEntity ent) {
        _destroyEntity__Entityp(this.object.pointer, ent.getInstancePointer().pointer);
    }

    private native void _destroyEntity__Entityp(long _pointer_, long ent);

    /** 
    Removes & destroys an  from the  by name. **/
    public void destroyEntity(String name) {
        _destroyEntity__StringR(this.object.pointer, name);
    }

    private native void _destroyEntity__StringR(long _pointer_, String name);

    /** 
    Removes & destroys all Entities. **/
    public void destroyAllEntities() {
        _destroyAllEntities(this.object.pointer);
    }

    private native void _destroyAllEntities(long _pointer_);

    /** 
    Create a , an object which you populate with geometry manually through a GL immediate-mode style interface. **/
    public org.ogre4j.IManualObject createManualObject(String name) {
         return new org.ogre4j.ManualObject(new InstancePointer(_createManualObject__StringR(this.object.pointer, name)));
    }

    private native long _createManualObject__StringR(long _pointer_, String name);

    /** 
    Retrieves a pointer to the named . **/
    public org.ogre4j.IManualObject getManualObject(String name) {
         return new org.ogre4j.ManualObject(new InstancePointer(_getManualObject__StringR_const(this.object.pointer, name)));
    }

    private native long _getManualObject__StringR_const(long _pointer_, String name);

    /** 
    Returns whether a manual object with the given name exists. **/
    public boolean hasManualObject(String name) {
         return _hasManualObject__StringR_const(this.object.pointer, name);
    }

    private native boolean _hasManualObject__StringR_const(long _pointer_, String name);

    /** 
    Removes & destroys a  from the . **/
    public void destroyManualObject(org.ogre4j.IManualObject obj) {
        _destroyManualObject__ManualObjectp(this.object.pointer, obj.getInstancePointer().pointer);
    }

    private native void _destroyManualObject__ManualObjectp(long _pointer_, long obj);

    /** 
    Removes & destroys a  from the . **/
    public void destroyManualObject(String name) {
        _destroyManualObject__StringR(this.object.pointer, name);
    }

    private native void _destroyManualObject__StringR(long _pointer_, String name);

    /** 
    Removes & destroys all ManualObjects from the . **/
    public void destroyAllManualObjects() {
        _destroyAllManualObjects(this.object.pointer);
    }

    private native void _destroyAllManualObjects(long _pointer_);

    /** 
    Create a , an object which you can use to render a linked chain of billboards. **/
    public org.ogre4j.IBillboardChain createBillboardChain(String name) {
         return new org.ogre4j.BillboardChain(new InstancePointer(_createBillboardChain__StringR(this.object.pointer, name)));
    }

    private native long _createBillboardChain__StringR(long _pointer_, String name);

    /** 
    Retrieves a pointer to the named . **/
    public org.ogre4j.IBillboardChain getBillboardChain(String name) {
         return new org.ogre4j.BillboardChain(new InstancePointer(_getBillboardChain__StringR_const(this.object.pointer, name)));
    }

    private native long _getBillboardChain__StringR_const(long _pointer_, String name);

    /** 
    Returns whether a billboard chain with the given name exists. **/
    public boolean hasBillboardChain(String name) {
         return _hasBillboardChain__StringR_const(this.object.pointer, name);
    }

    private native boolean _hasBillboardChain__StringR_const(long _pointer_, String name);

    /** 
    Removes & destroys a  from the . **/
    public void destroyBillboardChain(org.ogre4j.IBillboardChain obj) {
        _destroyBillboardChain__BillboardChainp(this.object.pointer, obj.getInstancePointer().pointer);
    }

    private native void _destroyBillboardChain__BillboardChainp(long _pointer_, long obj);

    /** 
    Removes & destroys a  from the . **/
    public void destroyBillboardChain(String name) {
        _destroyBillboardChain__StringR(this.object.pointer, name);
    }

    private native void _destroyBillboardChain__StringR(long _pointer_, String name);

    /** 
    Removes & destroys all BillboardChains from the . **/
    public void destroyAllBillboardChains() {
        _destroyAllBillboardChains(this.object.pointer);
    }

    private native void _destroyAllBillboardChains(long _pointer_);

    /** 
    Create a , an object which you can use to render a linked chain of billboards which follows one or more nodes. **/
    public org.ogre4j.IRibbonTrail createRibbonTrail(String name) {
         return new org.ogre4j.RibbonTrail(new InstancePointer(_createRibbonTrail__StringR(this.object.pointer, name)));
    }

    private native long _createRibbonTrail__StringR(long _pointer_, String name);

    /** 
    Retrieves a pointer to the named . **/
    public org.ogre4j.IRibbonTrail getRibbonTrail(String name) {
         return new org.ogre4j.RibbonTrail(new InstancePointer(_getRibbonTrail__StringR_const(this.object.pointer, name)));
    }

    private native long _getRibbonTrail__StringR_const(long _pointer_, String name);

    /** 
    Returns whether a ribbon trail with the given name exists. **/
    public boolean hasRibbonTrail(String name) {
         return _hasRibbonTrail__StringR_const(this.object.pointer, name);
    }

    private native boolean _hasRibbonTrail__StringR_const(long _pointer_, String name);

    /** 
    Removes & destroys a  from the . **/
    public void destroyRibbonTrail(org.ogre4j.IRibbonTrail obj) {
        _destroyRibbonTrail__RibbonTrailp(this.object.pointer, obj.getInstancePointer().pointer);
    }

    private native void _destroyRibbonTrail__RibbonTrailp(long _pointer_, long obj);

    /** 
    Removes & destroys a  from the . **/
    public void destroyRibbonTrail(String name) {
        _destroyRibbonTrail__StringR(this.object.pointer, name);
    }

    private native void _destroyRibbonTrail__StringR(long _pointer_, String name);

    /** 
    Removes & destroys all RibbonTrails from the . **/
    public void destroyAllRibbonTrails() {
        _destroyAllRibbonTrails(this.object.pointer);
    }

    private native void _destroyAllRibbonTrails(long _pointer_);

    /** 
    Creates a particle system based on a template. **/
    public org.ogre4j.IParticleSystem createParticleSystem(String name, String templateName) {
         return new org.ogre4j.ParticleSystem(new InstancePointer(_createParticleSystem__StringRStringR(this.object.pointer, name,  templateName)));
    }

    private native long _createParticleSystem__StringRStringR(long _pointer_, String name, String templateName);

    /** 
    Create a blank particle system. **/
    public org.ogre4j.IParticleSystem createParticleSystem(String name, int quota, String resourceGroup) {
         return new org.ogre4j.ParticleSystem(new InstancePointer(_createParticleSystem__StringRivStringR(this.object.pointer, name,  quota,  resourceGroup)));
    }

    private native long _createParticleSystem__StringRivStringR(long _pointer_, String name, int quota, String resourceGroup);

    /** 
    Retrieves a pointer to the named . **/
    public org.ogre4j.IParticleSystem getParticleSystem(String name) {
         return new org.ogre4j.ParticleSystem(new InstancePointer(_getParticleSystem__StringR_const(this.object.pointer, name)));
    }

    private native long _getParticleSystem__StringR_const(long _pointer_, String name);

    /** 
    Returns whether a particle system with the given name exists. **/
    public boolean hasParticleSystem(String name) {
         return _hasParticleSystem__StringR_const(this.object.pointer, name);
    }

    private native boolean _hasParticleSystem__StringR_const(long _pointer_, String name);

    /** 
    Removes & destroys a  from the . **/
    public void destroyParticleSystem(org.ogre4j.IParticleSystem obj) {
        _destroyParticleSystem__ParticleSystemp(this.object.pointer, obj.getInstancePointer().pointer);
    }

    private native void _destroyParticleSystem__ParticleSystemp(long _pointer_, long obj);

    /** 
    Removes & destroys a  from the . **/
    public void destroyParticleSystem(String name) {
        _destroyParticleSystem__StringR(this.object.pointer, name);
    }

    private native void _destroyParticleSystem__StringR(long _pointer_, String name);

    /** 
    Removes & destroys all ParticleSystems from the . **/
    public void destroyAllParticleSystems() {
        _destroyAllParticleSystems(this.object.pointer);
    }

    private native void _destroyAllParticleSystems(long _pointer_);

    /** 
    Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets etc. Cameras are not deleted at this stage since they are still referenced by viewports, which are not destroyed during this process. **/
    public void clearScene() {
        _clearScene(this.object.pointer);
    }

    private native void _clearScene(long _pointer_);

    /** 
    Sets the ambient light level to be used for the scene. **/
    public void setAmbientLight(org.ogre4j.IColourValue colour) {
        _setAmbientLight__ColourValueR(this.object.pointer, colour.getInstancePointer().pointer);
    }

    private native void _setAmbientLight__ColourValueR(long _pointer_, long colour);

    /** 
    Returns the ambient light level to be used for the scene. **/
    public org.ogre4j.IColourValue getAmbientLight() {
         return new org.ogre4j.ColourValue(new InstancePointer(_getAmbientLight_const(this.object.pointer)));
    }

    private native long _getAmbientLight_const(long _pointer_);

    /** 
    Sets the source of the 'world' geometry, i.e. the large, mainly static geometry making up the world e.g. rooms, landscape etc. This function can be called before setWorldGeometry in a background thread, do to some slow tasks (e.g. IO) that do not involve the backend render system. **/
    public void prepareWorldGeometry(String filename) {
        _prepareWorldGeometry__StringR(this.object.pointer, filename);
    }

    private native void _prepareWorldGeometry__StringR(long _pointer_, String filename);

    /** 
    Sets the source of the 'world' geometry, i.e. the large, mainly static geometry making up the world e.g. rooms, landscape etc. This function can be called before setWorldGeometry in a background thread, do to some slow tasks (e.g. IO) that do not involve the backend render system. **/
    public void prepareWorldGeometry(org.ogre4j.IDataStreamPtr stream, String typeName) {
        _prepareWorldGeometry__DataStreamPtrrStringR(this.object.pointer, stream.getInstancePointer().pointer,  typeName);
    }

    private native void _prepareWorldGeometry__DataStreamPtrrStringR(long _pointer_, long stream, String typeName);

    /** 
    Sets the source of the 'world' geometry, i.e. the large, mainly static geometry making up the world e.g. rooms, landscape etc. **/
    public void setWorldGeometry(String filename) {
        _setWorldGeometry__StringR(this.object.pointer, filename);
    }

    private native void _setWorldGeometry__StringR(long _pointer_, String filename);

    /** 
    Sets the source of the 'world' geometry, i.e. the large, mainly static geometry making up the world e.g. rooms, landscape etc. **/
    public void setWorldGeometry(org.ogre4j.IDataStreamPtr stream, String typeName) {
        _setWorldGeometry__DataStreamPtrrStringR(this.object.pointer, stream.getInstancePointer().pointer,  typeName);
    }

    private native void _setWorldGeometry__DataStreamPtrrStringR(long _pointer_, long stream, String typeName);

    /** 
    Estimate the number of loading stages required to load the named world geometry. **/
    public int estimateWorldGeometry(String filename) {
         return _estimateWorldGeometry__StringR(this.object.pointer, filename);
    }

    private native int _estimateWorldGeometry__StringR(long _pointer_, String filename);

    /** 
    Estimate the number of loading stages required to load the named world geometry. **/
    public int estimateWorldGeometry(org.ogre4j.IDataStreamPtr stream, String typeName) {
         return _estimateWorldGeometry__DataStreamPtrrStringR(this.object.pointer, stream.getInstancePointer().pointer,  typeName);
    }

    private native int _estimateWorldGeometry__DataStreamPtrrStringR(long _pointer_, long stream, String typeName);

    /** 
    Asks the  to provide a suggested viewpoint from which the scene should be viewed. **/
    public void getSuggestedViewpoint(org.ogre4j.IViewPoint returnValue, boolean random) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getSuggestedViewpoint__bv(this.object.pointer, random)), false);
    }

    private native long _getSuggestedViewpoint__bv(long _pointer_, boolean random);

    /** 
    Method for setting a specific option of the Scene Manager. These options are usually specific for a certain implemntation of the Scene Manager class, and may (and probably will) not exist across different implementations. **/
    public boolean setOption(String strKey, VoidPointer pValue) {
         return _setOption__StringRvP(this.object.pointer, strKey,  pValue.object.pointer);
    }

    private native boolean _setOption__StringRvP(long _pointer_, String strKey, long pValue);

    /** 
    Method for getting the value of an implementation-specific Scene Manager option. **/
    public boolean getOption(String strKey, VoidPointer pDestValue) {
         return _getOption__StringRvp(this.object.pointer, strKey,  pDestValue.object.pointer);
    }

    private native boolean _getOption__StringRvp(long _pointer_, String strKey, long pDestValue);

    /** 
    Method for verifying wether the scene manager has an implementation-specific option. **/
    public boolean hasOption(String strKey) {
         return _hasOption__StringR_const(this.object.pointer, strKey);
    }

    private native boolean _hasOption__StringR_const(long _pointer_, String strKey);

    /** 
    Method for getting all possible values for a specific option. When this list is too large (i.e. the option expects, for example, a float), the return value will be true, but the list will contain just one element whose size will be set to 0. Otherwise, the list will be filled with all the possible values the option can accept. **/
    public boolean getOptionValues(String strKey, org.ogre4j.IStringVector refValueList) {
         return _getOptionValues__StringRStringVectorr(this.object.pointer, strKey,  refValueList.getInstancePointer().pointer);
    }

    private native boolean _getOptionValues__StringRStringVectorr(long _pointer_, String strKey, long refValueList);

    /** 
    Method for getting all the implementation-specific options of the scene manager. **/
    public boolean getOptionKeys(org.ogre4j.IStringVector refKeys) {
         return _getOptionKeys__StringVectorr(this.object.pointer, refKeys.getInstancePointer().pointer);
    }

    private native boolean _getOptionKeys__StringVectorr(long _pointer_, long refKeys);

    /** 
    Internal method for updating the scene graph ie the tree of  instances managed by this class. **/
    public void _updateSceneGraph(org.ogre4j.ICamera cam) {
        __updateSceneGraph__Camerap(this.object.pointer, cam.getInstancePointer().pointer);
    }

    private native void __updateSceneGraph__Camerap(long _pointer_, long cam);

    /** 
    Internal method which parses the scene to find visible objects to render. **/
    public void _findVisibleObjects(org.ogre4j.ICamera cam, org.ogre4j.IVisibleObjectsBoundsInfo visibleBounds, boolean onlyShadowCasters) {
        __findVisibleObjects__CamerapVisibleObjectsBoundsInfopbv(this.object.pointer, cam.getInstancePointer().pointer,  visibleBounds.getInstancePointer().pointer,  onlyShadowCasters);
    }

    private native void __findVisibleObjects__CamerapVisibleObjectsBoundsInfopbv(long _pointer_, long cam, long visibleBounds, boolean onlyShadowCasters);

    /** 
    Internal method for applying animations to scene nodes. **/
    public void _applySceneAnimations() {
        __applySceneAnimations(this.object.pointer);
    }

    private native void __applySceneAnimations(long _pointer_);

    /** 
    Sends visible objects found in _findVisibleObjects to the rendering engine. **/
    public void _renderVisibleObjects() {
        __renderVisibleObjects(this.object.pointer);
    }

    private native void __renderVisibleObjects(long _pointer_);

    /** 
    Prompts the class to send its contents to the renderer. **/
    public void _renderScene(org.ogre4j.ICamera camera, org.ogre4j.IViewport vp, boolean includeOverlays) {
        __renderScene__CamerapViewportpbv(this.object.pointer, camera.getInstancePointer().pointer,  vp.getInstancePointer().pointer,  includeOverlays);
    }

    private native void __renderScene__CamerapViewportpbv(long _pointer_, long camera, long vp, boolean includeOverlays);

    /** 
    Internal method for queueing the sky objects with the params as previously set through setSkyBox, setSkyPlane and setSkyDome. **/
    public void _queueSkiesForRendering(org.ogre4j.ICamera cam) {
        __queueSkiesForRendering__Camerap(this.object.pointer, cam.getInstancePointer().pointer);
    }

    private native void __queueSkiesForRendering__Camerap(long _pointer_, long cam);

    /** 
    Notifies the scene manager of its destination render system **/
    public void _setDestinationRenderSystem(org.ogre4j.IRenderSystem sys) {
        __setDestinationRenderSystem__RenderSystemp(this.object.pointer, sys.getInstancePointer().pointer);
    }

    private native void __setDestinationRenderSystem__RenderSystemp(long _pointer_, long sys);

    /** 
    Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. **/
    public void setSkyPlane(boolean enable, org.ogre4j.IPlane plane, String materialName, float scale, float tiling, boolean drawFirst, float bow, int xsegments, int ysegments, String groupName) {
        _setSkyPlane__bvPlaneRStringRRealvRealvbvRealvivivStringR(this.object.pointer, enable,  plane.getInstancePointer().pointer,  materialName,  scale,  tiling,  drawFirst,  bow,  xsegments,  ysegments,  groupName);
    }

    private native void _setSkyPlane__bvPlaneRStringRRealvRealvbvRealvivivStringR(long _pointer_, boolean enable, long plane, String materialName, float scale, float tiling, boolean drawFirst, float bow, int xsegments, int ysegments, String groupName);

    /** 
    Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. **/
    public void _setSkyPlane(boolean enable, org.ogre4j.IPlane plane, String materialName, float scale, float tiling, short renderQueue, float bow, int xsegments, int ysegments, String groupName) {
        __setSkyPlane__bvPlaneRStringRRealvRealvuint8vRealvivivStringR(this.object.pointer, enable,  plane.getInstancePointer().pointer,  materialName,  scale,  tiling,  renderQueue,  bow,  xsegments,  ysegments,  groupName);
    }

    private native void __setSkyPlane__bvPlaneRStringRRealvRealvuint8vRealvivivStringR(long _pointer_, boolean enable, long plane, String materialName, float scale, float tiling, short renderQueue, float bow, int xsegments, int ysegments, String groupName);

    /** 
    Return whether a key plane is enabled **/
    public boolean isSkyPlaneEnabled() {
         return _isSkyPlaneEnabled_const(this.object.pointer);
    }

    private native boolean _isSkyPlaneEnabled_const(long _pointer_);

    /** 
    Get the sky plane node, if enabled. **/
    public org.ogre4j.ISceneNode getSkyPlaneNode() {
         return new org.ogre4j.SceneNode(new InstancePointer(_getSkyPlaneNode_const(this.object.pointer)));
    }

    private native long _getSkyPlaneNode_const(long _pointer_);

    /** 
    Get the parameters used to construct the SkyPlane, if any **/
    public org.ogre4j.ISceneManager.ISkyPlaneGenParameters getSkyPlaneGenParameters() {
         return new org.ogre4j.SceneManager.SkyPlaneGenParameters(new InstancePointer(_getSkyPlaneGenParameters_const(this.object.pointer)));
    }

    private native long _getSkyPlaneGenParameters_const(long _pointer_);

    /** 
    Enables / disables a 'sky box' i.e. a 6-sided box at constant distance from the camera representing the sky. **/
    public void setSkyBox(boolean enable, String materialName, float distance, boolean drawFirst, org.ogre4j.IQuaternion orientation, String groupName) {
        _setSkyBox__bvStringRRealvbvQuaternionRStringR(this.object.pointer, enable,  materialName,  distance,  drawFirst,  orientation.getInstancePointer().pointer,  groupName);
    }

    private native void _setSkyBox__bvStringRRealvbvQuaternionRStringR(long _pointer_, boolean enable, String materialName, float distance, boolean drawFirst, long orientation, String groupName);

    /** 
    Enables / disables a 'sky box' i.e. a 6-sided box at constant distance from the camera representing the sky. **/
    public void _setSkyBox(boolean enable, String materialName, float distance, short renderQueue, org.ogre4j.IQuaternion orientation, String groupName) {
        __setSkyBox__bvStringRRealvuint8vQuaternionRStringR(this.object.pointer, enable,  materialName,  distance,  renderQueue,  orientation.getInstancePointer().pointer,  groupName);
    }

    private native void __setSkyBox__bvStringRRealvuint8vQuaternionRStringR(long _pointer_, boolean enable, String materialName, float distance, short renderQueue, long orientation, String groupName);

    /** 
    Return whether a skybox is enabled **/
    public boolean isSkyBoxEnabled() {
         return _isSkyBoxEnabled_const(this.object.pointer);
    }

    private native boolean _isSkyBoxEnabled_const(long _pointer_);

    /** 
    Get the skybox node, if enabled. **/
    public org.ogre4j.ISceneNode getSkyBoxNode() {
         return new org.ogre4j.SceneNode(new InstancePointer(_getSkyBoxNode_const(this.object.pointer)));
    }

    private native long _getSkyBoxNode_const(long _pointer_);

    /** 
    Get the parameters used to generate the current SkyBox, if any **/
    public org.ogre4j.ISceneManager.ISkyBoxGenParameters getSkyBoxGenParameters() {
         return new org.ogre4j.SceneManager.SkyBoxGenParameters(new InstancePointer(_getSkyBoxGenParameters_const(this.object.pointer)));
    }

    private native long _getSkyBoxGenParameters_const(long _pointer_);

    /** 
    Enables / disables a 'sky dome' i.e. an illusion of a curved sky. **/
    public void setSkyDome(boolean enable, String materialName, float curvature, float tiling, float distance, boolean drawFirst, org.ogre4j.IQuaternion orientation, int xsegments, int ysegments, int ysegments_keep, String groupName) {
        _setSkyDome__bvStringRRealvRealvRealvbvQuaternionRivivivStringR(this.object.pointer, enable,  materialName,  curvature,  tiling,  distance,  drawFirst,  orientation.getInstancePointer().pointer,  xsegments,  ysegments,  ysegments_keep,  groupName);
    }

    private native void _setSkyDome__bvStringRRealvRealvRealvbvQuaternionRivivivStringR(long _pointer_, boolean enable, String materialName, float curvature, float tiling, float distance, boolean drawFirst, long orientation, int xsegments, int ysegments, int ysegments_keep, String groupName);

    /** 
    Enables / disables a 'sky dome' i.e. an illusion of a curved sky. **/
    public void _setSkyDome(boolean enable, String materialName, float curvature, float tiling, float distance, short renderQueue, org.ogre4j.IQuaternion orientation, int xsegments, int ysegments, int ysegments_keep, String groupName) {
        __setSkyDome__bvStringRRealvRealvRealvuint8vQuaternionRivivivStringR(this.object.pointer, enable,  materialName,  curvature,  tiling,  distance,  renderQueue,  orientation.getInstancePointer().pointer,  xsegments,  ysegments,  ysegments_keep,  groupName);
    }

    private native void __setSkyDome__bvStringRRealvRealvRealvuint8vQuaternionRivivivStringR(long _pointer_, boolean enable, String materialName, float curvature, float tiling, float distance, short renderQueue, long orientation, int xsegments, int ysegments, int ysegments_keep, String groupName);

    /** 
    Return whether a skydome is enabled **/
    public boolean isSkyDomeEnabled() {
         return _isSkyDomeEnabled_const(this.object.pointer);
    }

    private native boolean _isSkyDomeEnabled_const(long _pointer_);

    /** 
    Get the sky dome node, if enabled. **/
    public org.ogre4j.ISceneNode getSkyDomeNode() {
         return new org.ogre4j.SceneNode(new InstancePointer(_getSkyDomeNode_const(this.object.pointer)));
    }

    private native long _getSkyDomeNode_const(long _pointer_);

    /** 
    Get the parameters used to generate the current SkyDome, if any **/
    public org.ogre4j.ISceneManager.ISkyDomeGenParameters getSkyDomeGenParameters() {
         return new org.ogre4j.SceneManager.SkyDomeGenParameters(new InstancePointer(_getSkyDomeGenParameters_const(this.object.pointer)));
    }

    private native long _getSkyDomeGenParameters_const(long _pointer_);

    /** 
    Sets the fogging mode applied to the scene. **/
    public void setFog(org.ogre4j.FogMode mode, org.ogre4j.IColourValue colour, float expDensity, float linearStart, float linearEnd) {
        _setFog__FogModevColourValueRRealvRealvRealv(this.object.pointer, mode.getValue(),  colour.getInstancePointer().pointer,  expDensity,  linearStart,  linearEnd);
    }

    private native void _setFog__FogModevColourValueRRealvRealvRealv(long _pointer_, int mode, long colour, float expDensity, float linearStart, float linearEnd);

    /** 
    Returns the fog mode for the scene. **/
    public org.ogre4j.FogMode getFogMode() {
         return org.ogre4j.FogMode.toEnum(_getFogMode_const(this.object.pointer));
    }

    private native int _getFogMode_const(long _pointer_);

    /** 
    Returns the fog colour for the scene. **/
    public org.ogre4j.IColourValue getFogColour() {
         return new org.ogre4j.ColourValue(new InstancePointer(_getFogColour_const(this.object.pointer)));
    }

    private native long _getFogColour_const(long _pointer_);

    /** 
    Returns the fog start distance for the scene. **/
    public float getFogStart() {
         return _getFogStart_const(this.object.pointer);
    }

    private native float _getFogStart_const(long _pointer_);

    /** 
    Returns the fog end distance for the scene. **/
    public float getFogEnd() {
         return _getFogEnd_const(this.object.pointer);
    }

    private native float _getFogEnd_const(long _pointer_);

    /** 
    Returns the fog density for the scene. **/
    public float getFogDensity() {
         return _getFogDensity_const(this.object.pointer);
    }

    private native float _getFogDensity_const(long _pointer_);

    /** 
    Creates a new  for use with this scene manager. **/
    public org.ogre4j.IBillboardSet createBillboardSet(String name, long poolSize) {
         return new org.ogre4j.BillboardSet(new InstancePointer(_createBillboardSet__StringRIv(this.object.pointer, name,  poolSize)));
    }

    private native long _createBillboardSet__StringRIv(long _pointer_, String name, long poolSize);

    /** 
    Retrieves a pointer to the named . **/
    public org.ogre4j.IBillboardSet getBillboardSet(String name) {
         return new org.ogre4j.BillboardSet(new InstancePointer(_getBillboardSet__StringR_const(this.object.pointer, name)));
    }

    private native long _getBillboardSet__StringR_const(long _pointer_, String name);

    /** 
    Returns whether a billboardset with the given name exists. **/
    public boolean hasBillboardSet(String name) {
         return _hasBillboardSet__StringR_const(this.object.pointer, name);
    }

    private native boolean _hasBillboardSet__StringR_const(long _pointer_, String name);

    /** 
    Removes & destroys an  from the . **/
    public void destroyBillboardSet(org.ogre4j.IBillboardSet set) {
        _destroyBillboardSet__BillboardSetp(this.object.pointer, set.getInstancePointer().pointer);
    }

    private native void _destroyBillboardSet__BillboardSetp(long _pointer_, long set);

    /** 
    Removes & destroys an  from the  by name. **/
    public void destroyBillboardSet(String name) {
        _destroyBillboardSet__StringR(this.object.pointer, name);
    }

    private native void _destroyBillboardSet__StringR(long _pointer_, String name);

    /** 
    Removes & destroys all BillboardSets. **/
    public void destroyAllBillboardSets() {
        _destroyAllBillboardSets(this.object.pointer);
    }

    private native void _destroyAllBillboardSets(long _pointer_);

    /** 
    Tells the  whether it should render the SceneNodes which make up the scene as well as the objects in the scene. **/
    public void setDisplaySceneNodes(boolean display) {
        _setDisplaySceneNodes__bv(this.object.pointer, display);
    }

    private native void _setDisplaySceneNodes__bv(long _pointer_, boolean display);

    /** 
    Returns true if all scene nodes axis are to be displayed **/
    public boolean getDisplaySceneNodes() {
         return _getDisplaySceneNodes_const(this.object.pointer);
    }

    private native boolean _getDisplaySceneNodes_const(long _pointer_);

    /** 
    Creates an animation which can be used to animate scene nodes. **/
    public org.ogre4j.IAnimation createAnimation(String name, float length) {
         return new org.ogre4j.Animation(new InstancePointer(_createAnimation__StringRRealv(this.object.pointer, name,  length)));
    }

    private native long _createAnimation__StringRRealv(long _pointer_, String name, float length);

    /** 
    Looks up an  object previously created with createAnimation. **/
    public org.ogre4j.IAnimation getAnimation(String name) {
         return new org.ogre4j.Animation(new InstancePointer(_getAnimation__StringR_const(this.object.pointer, name)));
    }

    private native long _getAnimation__StringR_const(long _pointer_, String name);

    /** 
    Returns whether an animation with the given name exists. **/
    public boolean hasAnimation(String name) {
         return _hasAnimation__StringR_const(this.object.pointer, name);
    }

    private native boolean _hasAnimation__StringR_const(long _pointer_, String name);

    /** 
    Destroys an . **/
    public void destroyAnimation(String name) {
        _destroyAnimation__StringR(this.object.pointer, name);
    }

    private native void _destroyAnimation__StringR(long _pointer_, String name);

    /** 
    Removes all animations created using this . **/
    public void destroyAllAnimations() {
        _destroyAllAnimations(this.object.pointer);
    }

    private native void _destroyAllAnimations(long _pointer_);

    /** 
    Create an  object for managing application of animations. **/
    public org.ogre4j.IAnimationState createAnimationState(String animName) {
         return new org.ogre4j.AnimationState(new InstancePointer(_createAnimationState__StringR(this.object.pointer, animName)));
    }

    private native long _createAnimationState__StringR(long _pointer_, String animName);

    /** 
    Retrieves animation state as previously created using createAnimationState. **/
    public org.ogre4j.IAnimationState getAnimationState(String animName) {
         return new org.ogre4j.AnimationState(new InstancePointer(_getAnimationState__StringR_const(this.object.pointer, animName)));
    }

    private native long _getAnimationState__StringR_const(long _pointer_, String animName);

    /** 
    Returns whether an animation state with the given name exists. **/
    public boolean hasAnimationState(String name) {
         return _hasAnimationState__StringR_const(this.object.pointer, name);
    }

    private native boolean _hasAnimationState__StringR_const(long _pointer_, String name);

    /** 
    Destroys an . **/
    public void destroyAnimationState(String name) {
        _destroyAnimationState__StringR(this.object.pointer, name);
    }

    private native void _destroyAnimationState__StringR(long _pointer_, String name);

    /** 
    Removes all animation states created using this . **/
    public void destroyAllAnimationStates() {
        _destroyAllAnimationStates(this.object.pointer);
    }

    private native void _destroyAllAnimationStates(long _pointer_);

    /** 
    Manual rendering method, for advanced users only. **/
    public void manualRender(org.ogre4j.IRenderOperation rend, org.ogre4j.IPass pass, org.ogre4j.IViewport vp, org.ogre4j.IMatrix4 worldMatrix, org.ogre4j.IMatrix4 viewMatrix, org.ogre4j.IMatrix4 projMatrix, boolean doBeginEndFrame) {
        _manualRender__RenderOperationpPasspViewportpMatrix4RMatrix4RMatrix4Rbv(this.object.pointer, rend.getInstancePointer().pointer,  pass.getInstancePointer().pointer,  vp.getInstancePointer().pointer,  worldMatrix.getInstancePointer().pointer,  viewMatrix.getInstancePointer().pointer,  projMatrix.getInstancePointer().pointer,  doBeginEndFrame);
    }

    private native void _manualRender__RenderOperationpPasspViewportpMatrix4RMatrix4RMatrix4Rbv(long _pointer_, long rend, long pass, long vp, long worldMatrix, long viewMatrix, long projMatrix, boolean doBeginEndFrame);

    /** 
    Retrieves the internal render queue, for advanced users only. **/
    public org.ogre4j.IRenderQueue getRenderQueue() {
         return new org.ogre4j.RenderQueue(new InstancePointer(_getRenderQueue(this.object.pointer)));
    }

    private native long _getRenderQueue(long _pointer_);

    /** 
    Registers a new  which will be notified when render queues are processed. **/
    public void addRenderQueueListener(org.ogre4j.IRenderQueueListener newListener) {
        _addRenderQueueListener__RenderQueueListenerp(this.object.pointer, newListener.getInstancePointer().pointer);
    }

    private native void _addRenderQueueListener__RenderQueueListenerp(long _pointer_, long newListener);

    /** 
    Removes a listener previously added with addRenderQueueListener. **/
    public void removeRenderQueueListener(org.ogre4j.IRenderQueueListener delListener) {
        _removeRenderQueueListener__RenderQueueListenerp(this.object.pointer, delListener.getInstancePointer().pointer);
    }

    private native void _removeRenderQueueListener__RenderQueueListenerp(long _pointer_, long delListener);

    /** 
    Adds an item to the 'special case' render queue list. **/
    public void addSpecialCaseRenderQueue(short qid) {
        _addSpecialCaseRenderQueue__uint8v(this.object.pointer, qid);
    }

    private native void _addSpecialCaseRenderQueue__uint8v(long _pointer_, short qid);

    /** 
    Removes an item to the 'special case' render queue list. **/
    public void removeSpecialCaseRenderQueue(short qid) {
        _removeSpecialCaseRenderQueue__uint8v(this.object.pointer, qid);
    }

    private native void _removeSpecialCaseRenderQueue__uint8v(long _pointer_, short qid);

    /** 
    Clears the 'special case' render queue list. **/
    public void clearSpecialCaseRenderQueues() {
        _clearSpecialCaseRenderQueues(this.object.pointer);
    }

    private native void _clearSpecialCaseRenderQueues(long _pointer_);

    /** 
    Sets the way the special case render queue list is processed. **/
    public void setSpecialCaseRenderQueueMode(org.ogre4j.SceneManager.SpecialCaseRenderQueueMode mode) {
        _setSpecialCaseRenderQueueMode__SpecialCaseRenderQueueModev(this.object.pointer, mode.getValue());
    }

    private native void _setSpecialCaseRenderQueueMode__SpecialCaseRenderQueueModev(long _pointer_, int mode);

    /** 
    Gets the way the special case render queue list is processed. **/
    public org.ogre4j.SceneManager.SpecialCaseRenderQueueMode getSpecialCaseRenderQueueMode() {
         return org.ogre4j.SceneManager.SpecialCaseRenderQueueMode.toEnum(_getSpecialCaseRenderQueueMode(this.object.pointer));
    }

    private native int _getSpecialCaseRenderQueueMode(long _pointer_);

    /** 
    Returns whether or not the named queue will be rendered based on the current 'special case' render queue list and mode. **/
    public boolean isRenderQueueToBeProcessed(short qid) {
         return _isRenderQueueToBeProcessed__uint8v(this.object.pointer, qid);
    }

    private native boolean _isRenderQueueToBeProcessed__uint8v(long _pointer_, short qid);

    /** 
    Sets the render queue that the world geometry (if any) this  renders will be associated with. **/
    public void setWorldGeometryRenderQueue(short qid) {
        _setWorldGeometryRenderQueue__uint8v(this.object.pointer, qid);
    }

    private native void _setWorldGeometryRenderQueue__uint8v(long _pointer_, short qid);

    /** 
    Gets the render queue that the world geometry (if any) this  renders will be associated with. **/
    public short getWorldGeometryRenderQueue() {
         return _getWorldGeometryRenderQueue(this.object.pointer);
    }

    private native short _getWorldGeometryRenderQueue(long _pointer_);

    /** 
    Allows all bounding boxes of scene nodes to be displayed. **/
    public void showBoundingBoxes(boolean bShow) {
        _showBoundingBoxes__bv(this.object.pointer, bShow);
    }

    private native void _showBoundingBoxes__bv(long _pointer_, boolean bShow);

    /** 
    Returns if all bounding boxes of scene nodes are to be displayed **/
    public boolean getShowBoundingBoxes() {
         return _getShowBoundingBoxes_const(this.object.pointer);
    }

    private native boolean _getShowBoundingBoxes_const(long _pointer_);

    /** 
    Internal method for notifying the manager that a  is autotracking. **/
    public void _notifyAutotrackingSceneNode(org.ogre4j.ISceneNode node, boolean autoTrack) {
        __notifyAutotrackingSceneNode__SceneNodepbv(this.object.pointer, node.getInstancePointer().pointer,  autoTrack);
    }

    private native void __notifyAutotrackingSceneNode__SceneNodepbv(long _pointer_, long node, boolean autoTrack);

    /** 
    Creates an  for this scene manager. **/
    public org.ogre4j.IAxisAlignedBoxSceneQuery createAABBQuery(org.ogre4j.IAxisAlignedBox box, long mask) {
         return new org.ogre4j.AxisAlignedBoxSceneQuery(new InstancePointer(_createAABBQuery__AxisAlignedBoxRLv(this.object.pointer, box.getInstancePointer().pointer,  mask)));
    }

    private native long _createAABBQuery__AxisAlignedBoxRLv(long _pointer_, long box, long mask);

    /** 
    Creates a  for this scene manager. **/
    public org.ogre4j.ISphereSceneQuery createSphereQuery(org.ogre4j.ISphere sphere, long mask) {
         return new org.ogre4j.SphereSceneQuery(new InstancePointer(_createSphereQuery__SphereRLv(this.object.pointer, sphere.getInstancePointer().pointer,  mask)));
    }

    private native long _createSphereQuery__SphereRLv(long _pointer_, long sphere, long mask);

    /** 
    Creates a  for this scene manager. **/
    public org.ogre4j.IPlaneBoundedVolumeListSceneQuery createPlaneBoundedVolumeQuery(org.ogre4j.IPlaneBoundedVolumeList volumes, long mask) {
         return new org.ogre4j.PlaneBoundedVolumeListSceneQuery(new InstancePointer(_createPlaneBoundedVolumeQuery__PlaneBoundedVolumeListRLv(this.object.pointer, volumes.getInstancePointer().pointer,  mask)));
    }

    private native long _createPlaneBoundedVolumeQuery__PlaneBoundedVolumeListRLv(long _pointer_, long volumes, long mask);

    /** 
    Creates a  for this scene manager. **/
    public org.ogre4j.IRaySceneQuery createRayQuery(org.ogre4j.IRay ray, long mask) {
         return new org.ogre4j.RaySceneQuery(new InstancePointer(_createRayQuery__RayRLv(this.object.pointer, ray.getInstancePointer().pointer,  mask)));
    }

    private native long _createRayQuery__RayRLv(long _pointer_, long ray, long mask);

    /** 
    Creates an  for this scene manager. **/
    public org.ogre4j.IIntersectionSceneQuery createIntersectionQuery(long mask) {
         return new org.ogre4j.IntersectionSceneQuery(new InstancePointer(_createIntersectionQuery__Lv(this.object.pointer, mask)));
    }

    private native long _createIntersectionQuery__Lv(long _pointer_, long mask);

    /** 
    Destroys a scene query of any type. **/
    public void destroyQuery(org.ogre4j.ISceneQuery query) {
        _destroyQuery__SceneQueryp(this.object.pointer, query.getInstancePointer().pointer);
    }

    private native void _destroyQuery__SceneQueryp(long _pointer_, long query);

    /** 
    Returns a specialised  over all cameras in the scene. **/
    public void getCameraIterator(org.ogre4j.ISceneManager.ICameraIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getCameraIterator(this.object.pointer)), false);
    }

    private native long _getCameraIterator(long _pointer_);

    /** 
    Returns a specialised  over all animations in the scene. **/
    public void getAnimationIterator(org.ogre4j.ISceneManager.IAnimationIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getAnimationIterator(this.object.pointer)), false);
    }

    private native long _getAnimationIterator(long _pointer_);

    /** 
    Returns a specialised  over all animation states in the scene. **/
    public void getAnimationStateIterator(org.ogre4j.IAnimationStateIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getAnimationStateIterator(this.object.pointer)), false);
    }

    private native long _getAnimationStateIterator(long _pointer_);

    /** 
    Sets the general shadow technique to be used in this scene. **/
    public void setShadowTechnique(org.ogre4j.ShadowTechnique technique) {
        _setShadowTechnique__ShadowTechniquev(this.object.pointer, technique.getValue());
    }

    private native void _setShadowTechnique__ShadowTechniquev(long _pointer_, int technique);

    /** 
    Gets the current shadow technique. **/
    public org.ogre4j.ShadowTechnique getShadowTechnique() {
         return org.ogre4j.ShadowTechnique.toEnum(_getShadowTechnique_const(this.object.pointer));
    }

    private native int _getShadowTechnique_const(long _pointer_);

    /** 
    Enables / disables the rendering of debug information for shadows. **/
    public void setShowDebugShadows(boolean debug) {
        _setShowDebugShadows__bv(this.object.pointer, debug);
    }

    private native void _setShowDebugShadows__bv(long _pointer_, boolean debug);

    /** 
    Are debug shadows shown? **/
    public boolean getShowDebugShadows() {
         return _getShowDebugShadows_const(this.object.pointer);
    }

    private native boolean _getShowDebugShadows_const(long _pointer_);

    /** 
    Set the colour used to modulate areas in shadow. **/
    public void setShadowColour(org.ogre4j.IColourValue colour) {
        _setShadowColour__ColourValueR(this.object.pointer, colour.getInstancePointer().pointer);
    }

    private native void _setShadowColour__ColourValueR(long _pointer_, long colour);

    /** 
    Get the colour used to modulate areas in shadow. **/
    public org.ogre4j.IColourValue getShadowColour() {
         return new org.ogre4j.ColourValue(new InstancePointer(_getShadowColour_const(this.object.pointer)));
    }

    private native long _getShadowColour_const(long _pointer_);

    /** 
    Sets the distance a shadow volume is extruded for a directional light. **/
    public void setShadowDirectionalLightExtrusionDistance(float dist) {
        _setShadowDirectionalLightExtrusionDistance__Realv(this.object.pointer, dist);
    }

    private native void _setShadowDirectionalLightExtrusionDistance__Realv(long _pointer_, float dist);

    /** 
    Gets the distance a shadow volume is extruded for a directional light. **/
    public float getShadowDirectionalLightExtrusionDistance() {
         return _getShadowDirectionalLightExtrusionDistance_const(this.object.pointer);
    }

    private native float _getShadowDirectionalLightExtrusionDistance_const(long _pointer_);

    /** 
    Sets the default maximum distance away from the camera that shadows will be visible. You have to call this function before you create lights or the default distance of zero will be used. **/
    public void setShadowFarDistance(float distance) {
        _setShadowFarDistance__Realv(this.object.pointer, distance);
    }

    private native void _setShadowFarDistance__Realv(long _pointer_, float distance);

    /** 
    Gets the default maximum distance away from the camera that shadows will be visible. **/
    public float getShadowFarDistance() {
         return _getShadowFarDistance_const(this.object.pointer);
    }

    private native float _getShadowFarDistance_const(long _pointer_);

    /** **/
    public float getShadowFarDistanceSquared() {
         return _getShadowFarDistanceSquared_const(this.object.pointer);
    }

    private native float _getShadowFarDistanceSquared_const(long _pointer_);

    /** 
    Sets the maximum size of the index buffer used to render shadow primitives. **/
    public void setShadowIndexBufferSize(int size) {
        _setShadowIndexBufferSize__iv(this.object.pointer, size);
    }

    private native void _setShadowIndexBufferSize__iv(long _pointer_, int size);

    /** **/
    public int getShadowIndexBufferSize() {
         return _getShadowIndexBufferSize_const(this.object.pointer);
    }

    private native int _getShadowIndexBufferSize_const(long _pointer_);

    /** 
    Set the size of the texture used for all texture-based shadows. **/
    public void setShadowTextureSize(int size) {
        _setShadowTextureSize__Hv(this.object.pointer, size);
    }

    private native void _setShadowTextureSize__Hv(long _pointer_, int size);

    /** 
    Set the detailed configuration for a shadow texture. **/
    public void setShadowTextureConfig(int shadowIndex, int width, int height, org.ogre4j.PixelFormat format) {
        _setShadowTextureConfig__ivHvHvPixelFormatv(this.object.pointer, shadowIndex,  width,  height,  format.getValue());
    }

    private native void _setShadowTextureConfig__ivHvHvPixelFormatv(long _pointer_, int shadowIndex, int width, int height, int format);

    /** 
    Set the detailed configuration for a shadow texture. **/
    public void setShadowTextureConfig(int shadowIndex, org.ogre4j.IShadowTextureConfig config) {
        _setShadowTextureConfig__ivShadowTextureConfigR(this.object.pointer, shadowIndex,  config.getInstancePointer().pointer);
    }

    private native void _setShadowTextureConfig__ivShadowTextureConfigR(long _pointer_, int shadowIndex, long config);

    /** 
    Get an iterator over the current shadow texture settings. **/
    public void getShadowTextureConfigIterator(org.ogre4j.IConstShadowTextureConfigIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getShadowTextureConfigIterator_const(this.object.pointer)), false);
    }

    private native long _getShadowTextureConfigIterator_const(long _pointer_);

    /** 
    Set the pixel format of the textures used for texture-based shadows. **/
    public void setShadowTexturePixelFormat(org.ogre4j.PixelFormat fmt) {
        _setShadowTexturePixelFormat__PixelFormatv(this.object.pointer, fmt.getValue());
    }

    private native void _setShadowTexturePixelFormat__PixelFormatv(long _pointer_, int fmt);

    /** 
    Set the number of textures allocated for texture-based shadows. **/
    public void setShadowTextureCount(int count) {
        _setShadowTextureCount__iv(this.object.pointer, count);
    }

    private native void _setShadowTextureCount__iv(long _pointer_, int count);

    /** **/
    public int getShadowTextureCount() {
         return _getShadowTextureCount_const(this.object.pointer);
    }

    private native int _getShadowTextureCount_const(long _pointer_);

    /** 
    Set the number of shadow textures a light type uses. **/
    public void setShadowTextureCountPerLightType(org.ogre4j.Light.LightTypes type, int count) {
        _setShadowTextureCountPerLightType__Light_LightTypesviv(this.object.pointer, type.getValue(),  count);
    }

    private native void _setShadowTextureCountPerLightType__Light_LightTypesviv(long _pointer_, int type, int count);

    /** **/
    public int getShadowTextureCountPerLightType(org.ogre4j.Light.LightTypes type) {
         return _getShadowTextureCountPerLightType__Light_LightTypesv_const(this.object.pointer, type.getValue());
    }

    private native int _getShadowTextureCountPerLightType__Light_LightTypesv_const(long _pointer_, int type);

    /** 
    Sets the size and count of textures used in texture-based shadows. **/
    public void setShadowTextureSettings(int size, int count, org.ogre4j.PixelFormat fmt) {
        _setShadowTextureSettings__HvHvPixelFormatv(this.object.pointer, size,  count,  fmt.getValue());
    }

    private native void _setShadowTextureSettings__HvHvPixelFormatv(long _pointer_, int size, int count, int fmt);

    /** 
    Get a reference to the shadow texture currently in use at the given index. **/
    public org.ogre4j.ITexturePtr getShadowTexture(int shadowIndex) {
         return new org.ogre4j.TexturePtr(new InstancePointer(_getShadowTexture__iv(this.object.pointer, shadowIndex)));
    }

    private native long _getShadowTexture__iv(long _pointer_, int shadowIndex);

    /** 
    Sets the proportional distance which a texture shadow which is generated from a directional light will be offset into the camera view to make best use of texture space. **/
    public void setShadowDirLightTextureOffset(float offset) {
        _setShadowDirLightTextureOffset__Realv(this.object.pointer, offset);
    }

    private native void _setShadowDirLightTextureOffset__Realv(long _pointer_, float offset);

    /** 
    Gets the proportional distance which a texture shadow which is generated from a directional light will be offset into the camera view to make best use of texture space. **/
    public float getShadowDirLightTextureOffset() {
         return _getShadowDirLightTextureOffset_const(this.object.pointer);
    }

    private native float _getShadowDirLightTextureOffset_const(long _pointer_);

    /** 
    Sets the proportional distance at which texture shadows begin to fade out. **/
    public void setShadowTextureFadeStart(float fadeStart) {
        _setShadowTextureFadeStart__Realv(this.object.pointer, fadeStart);
    }

    private native void _setShadowTextureFadeStart__Realv(long _pointer_, float fadeStart);

    /** 
    Sets the proportional distance at which texture shadows finish to fading out. **/
    public void setShadowTextureFadeEnd(float fadeEnd) {
        _setShadowTextureFadeEnd__Realv(this.object.pointer, fadeEnd);
    }

    private native void _setShadowTextureFadeEnd__Realv(long _pointer_, float fadeEnd);

    /** 
    Sets whether or not texture shadows should attempt to self-shadow. **/
    public void setShadowTextureSelfShadow(boolean selfShadow) {
        _setShadowTextureSelfShadow__bv(this.object.pointer, selfShadow);
    }

    private native void _setShadowTextureSelfShadow__bv(long _pointer_, boolean selfShadow);

    /** **/
    public boolean getShadowTextureSelfShadow() {
         return _getShadowTextureSelfShadow_const(this.object.pointer);
    }

    private native boolean _getShadowTextureSelfShadow_const(long _pointer_);

    /** 
    Sets the default material to use for rendering shadow casters. **/
    public void setShadowTextureCasterMaterial(String name) {
        _setShadowTextureCasterMaterial__StringR(this.object.pointer, name);
    }

    private native void _setShadowTextureCasterMaterial__StringR(long _pointer_, String name);

    /** 
    Sets the default material to use for rendering shadow receivers. **/
    public void setShadowTextureReceiverMaterial(String name) {
        _setShadowTextureReceiverMaterial__StringR(this.object.pointer, name);
    }

    private native void _setShadowTextureReceiverMaterial__StringR(long _pointer_, String name);

    /** 
    Sets whether or not shadow casters should be rendered into shadow textures using their back faces rather than their front faces. **/
    public void setShadowCasterRenderBackFaces(boolean bf) {
        _setShadowCasterRenderBackFaces__bv(this.object.pointer, bf);
    }

    private native void _setShadowCasterRenderBackFaces__bv(long _pointer_, boolean bf);

    /** 
    Gets whether or not shadow casters should be rendered into shadow textures using their back faces rather than their front faces. **/
    public boolean getShadowCasterRenderBackFaces() {
         return _getShadowCasterRenderBackFaces_const(this.object.pointer);
    }

    private native boolean _getShadowCasterRenderBackFaces_const(long _pointer_);

    /** 
    Set the shadow camera setup to use for all lights which don't have their own shadow camera setup. **/
    public void setShadowCameraSetup(org.ogre4j.IShadowCameraSetupPtr shadowSetup) {
        _setShadowCameraSetup__ShadowCameraSetupPtrR(this.object.pointer, shadowSetup.getInstancePointer().pointer);
    }

    private native void _setShadowCameraSetup__ShadowCameraSetupPtrR(long _pointer_, long shadowSetup);

    /** 
    Get the shadow camera setup in use for all lights which don't have their own shadow camera setup. **/
    public org.ogre4j.IShadowCameraSetupPtr getShadowCameraSetup() {
         return new org.ogre4j.ShadowCameraSetupPtr(new InstancePointer(_getShadowCameraSetup_const(this.object.pointer)));
    }

    private native long _getShadowCameraSetup_const(long _pointer_);

    /** 
    Sets whether we should use an inifinite camera far plane when rendering stencil shadows. **/
    public void setShadowUseInfiniteFarPlane(boolean enable) {
        _setShadowUseInfiniteFarPlane__bv(this.object.pointer, enable);
    }

    private native void _setShadowUseInfiniteFarPlane__bv(long _pointer_, boolean enable);

    /** 
    Is there a stencil shadow based shadowing technique in use? **/
    public boolean isShadowTechniqueStencilBased() {
         return _isShadowTechniqueStencilBased_const(this.object.pointer);
    }

    private native boolean _isShadowTechniqueStencilBased_const(long _pointer_);

    /** 
    Is there a texture shadow based shadowing technique in use? **/
    public boolean isShadowTechniqueTextureBased() {
         return _isShadowTechniqueTextureBased_const(this.object.pointer);
    }

    private native boolean _isShadowTechniqueTextureBased_const(long _pointer_);

    /** 
    Is there a modulative shadowing technique in use? **/
    public boolean isShadowTechniqueModulative() {
         return _isShadowTechniqueModulative_const(this.object.pointer);
    }

    private native boolean _isShadowTechniqueModulative_const(long _pointer_);

    /** 
    Is there an additive shadowing technique in use? **/
    public boolean isShadowTechniqueAdditive() {
         return _isShadowTechniqueAdditive_const(this.object.pointer);
    }

    private native boolean _isShadowTechniqueAdditive_const(long _pointer_);

    /** 
    Is the shadow technique integrated into primary materials? **/
    public boolean isShadowTechniqueIntegrated() {
         return _isShadowTechniqueIntegrated_const(this.object.pointer);
    }

    private native boolean _isShadowTechniqueIntegrated_const(long _pointer_);

    /** 
    Is there any shadowing technique in use? **/
    public boolean isShadowTechniqueInUse() {
         return _isShadowTechniqueInUse_const(this.object.pointer);
    }

    private native boolean _isShadowTechniqueInUse_const(long _pointer_);

    /** 
    Sets whether when using a built-in additive shadow mode, user clip planes should be used to restrict light rendering. **/
    public void setShadowUseLightClipPlanes(boolean enabled) {
        _setShadowUseLightClipPlanes__bv(this.object.pointer, enabled);
    }

    private native void _setShadowUseLightClipPlanes__bv(long _pointer_, boolean enabled);

    /** 
    Gets whether when using a built-in additive shadow mode, user clip planes should be used to restrict light rendering. **/
    public boolean getShadowUseLightClipPlanes() {
         return _getShadowUseLightClipPlanes_const(this.object.pointer);
    }

    private native boolean _getShadowUseLightClipPlanes_const(long _pointer_);

    /** 
    Add a listener which will get called back on scene manager events. **/
    public void addListener(org.ogre4j.ISceneManager.IListener s) {
        _addListener__Listenerp(this.object.pointer, s.getInstancePointer().pointer);
    }

    private native void _addListener__Listenerp(long _pointer_, long s);

    /** 
    Remove a listener **/
    public void removeListener(org.ogre4j.ISceneManager.IListener s) {
        _removeListener__Listenerp(this.object.pointer, s.getInstancePointer().pointer);
    }

    private native void _removeListener__Listenerp(long _pointer_, long s);

    /** 
    Creates a  instance suitable for use with this . **/
    public org.ogre4j.IStaticGeometry createStaticGeometry(String name) {
         return new org.ogre4j.StaticGeometry(new InstancePointer(_createStaticGeometry__StringR(this.object.pointer, name)));
    }

    private native long _createStaticGeometry__StringR(long _pointer_, String name);

    /** 
    Retrieve a previously created  instance. **/
    public org.ogre4j.IStaticGeometry getStaticGeometry(String name) {
         return new org.ogre4j.StaticGeometry(new InstancePointer(_getStaticGeometry__StringR_const(this.object.pointer, name)));
    }

    private native long _getStaticGeometry__StringR_const(long _pointer_, String name);

    /** 
    Returns whether a static geometry instance with the given name exists. **/
    public boolean hasStaticGeometry(String name) {
         return _hasStaticGeometry__StringR_const(this.object.pointer, name);
    }

    private native boolean _hasStaticGeometry__StringR_const(long _pointer_, String name);

    /** 
    Remove & destroy a  instance. **/
    public void destroyStaticGeometry(org.ogre4j.IStaticGeometry geom) {
        _destroyStaticGeometry__StaticGeometryp(this.object.pointer, geom.getInstancePointer().pointer);
    }

    private native void _destroyStaticGeometry__StaticGeometryp(long _pointer_, long geom);

    /** 
    Remove & destroy a  instance. **/
    public void destroyStaticGeometry(String name) {
        _destroyStaticGeometry__StringR(this.object.pointer, name);
    }

    private native void _destroyStaticGeometry__StringR(long _pointer_, String name);

    /** 
    Remove & destroy all  instances. **/
    public void destroyAllStaticGeometry() {
        _destroyAllStaticGeometry(this.object.pointer);
    }

    private native void _destroyAllStaticGeometry(long _pointer_);

    /** 
    Creates a  instance suitable for use with this . **/
    public org.ogre4j.IInstancedGeometry createInstancedGeometry(String name) {
         return new org.ogre4j.InstancedGeometry(new InstancePointer(_createInstancedGeometry__StringR(this.object.pointer, name)));
    }

    private native long _createInstancedGeometry__StringR(long _pointer_, String name);

    /** 
    Retrieve a previously created  instance. **/
    public org.ogre4j.IInstancedGeometry getInstancedGeometry(String name) {
         return new org.ogre4j.InstancedGeometry(new InstancePointer(_getInstancedGeometry__StringR_const(this.object.pointer, name)));
    }

    private native long _getInstancedGeometry__StringR_const(long _pointer_, String name);

    /** 
    Remove & destroy a  instance. **/
    public void destroyInstancedGeometry(org.ogre4j.IInstancedGeometry geom) {
        _destroyInstancedGeometry__InstancedGeometryp(this.object.pointer, geom.getInstancePointer().pointer);
    }

    private native void _destroyInstancedGeometry__InstancedGeometryp(long _pointer_, long geom);

    /** 
    Remove & destroy a  instance. **/
    public void destroyInstancedGeometry(String name) {
        _destroyInstancedGeometry__StringR(this.object.pointer, name);
    }

    private native void _destroyInstancedGeometry__StringR(long _pointer_, String name);

    /** 
    Remove & destroy all  instances. **/
    public void destroyAllInstancedGeometry() {
        _destroyAllInstancedGeometry(this.object.pointer);
    }

    private native void _destroyAllInstancedGeometry(long _pointer_);

    /** 
    Create a movable object of the type specified. **/
    public org.ogre4j.IMovableObject createMovableObject(String name, String typeName, org.ogre4j.INameValuePairList params) {
         return new org.ogre4j.MovableObject(new InstancePointer(_createMovableObject__StringRStringRNameValuePairListP(this.object.pointer, name,  typeName,  params.getInstancePointer().pointer)));
    }

    private native long _createMovableObject__StringRStringRNameValuePairListP(long _pointer_, String name, String typeName, long params);

    /** 
    Destroys a  with the name specified, of the type specified. **/
    public void destroyMovableObject(String name, String typeName) {
        _destroyMovableObject__StringRStringR(this.object.pointer, name,  typeName);
    }

    private native void _destroyMovableObject__StringRStringR(long _pointer_, String name, String typeName);

    /** 
    Destroys a . **/
    public void destroyMovableObject(org.ogre4j.IMovableObject m) {
        _destroyMovableObject__MovableObjectp(this.object.pointer, m.getInstancePointer().pointer);
    }

    private native void _destroyMovableObject__MovableObjectp(long _pointer_, long m);

    /** 
    Destroy all MovableObjects of a given type. **/
    public void destroyAllMovableObjectsByType(String typeName) {
        _destroyAllMovableObjectsByType__StringR(this.object.pointer, typeName);
    }

    private native void _destroyAllMovableObjectsByType__StringR(long _pointer_, String typeName);

    /** 
    Destroy all MovableObjects. **/
    public void destroyAllMovableObjects() {
        _destroyAllMovableObjects(this.object.pointer);
    }

    private native void _destroyAllMovableObjects(long _pointer_);

    /** 
    Get a reference to a previously created . **/
    public org.ogre4j.IMovableObject getMovableObject(String name, String typeName) {
         return new org.ogre4j.MovableObject(new InstancePointer(_getMovableObject__StringRStringR_const(this.object.pointer, name,  typeName)));
    }

    private native long _getMovableObject__StringRStringR_const(long _pointer_, String name, String typeName);

    /** 
    Returns whether a movable object instance with the given name exists. **/
    public boolean hasMovableObject(String name, String typeName) {
         return _hasMovableObject__StringRStringR_const(this.object.pointer, name,  typeName);
    }

    private native boolean _hasMovableObject__StringRStringR_const(long _pointer_, String name, String typeName);

    /** 
    Get an iterator over all MovableObect instances of a given type. **/
    public void getMovableObjectIterator(org.ogre4j.ISceneManager.IMovableObjectIterator returnValue, String typeName) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getMovableObjectIterator__StringR(this.object.pointer, typeName)), false);
    }

    private native long _getMovableObjectIterator__StringR(long _pointer_, String typeName);

    /** 
    Inject a  instance created externally. **/
    public void injectMovableObject(org.ogre4j.IMovableObject m) {
        _injectMovableObject__MovableObjectp(this.object.pointer, m.getInstancePointer().pointer);
    }

    private native void _injectMovableObject__MovableObjectp(long _pointer_, long m);

    /** 
    Extract a previously injected . **/
    public void extractMovableObject(String name, String typeName) {
        _extractMovableObject__StringRStringR(this.object.pointer, name,  typeName);
    }

    private native void _extractMovableObject__StringRStringR(long _pointer_, String name, String typeName);

    /** 
    Extract a previously injected . **/
    public void extractMovableObject(org.ogre4j.IMovableObject m) {
        _extractMovableObject__MovableObjectp(this.object.pointer, m.getInstancePointer().pointer);
    }

    private native void _extractMovableObject__MovableObjectp(long _pointer_, long m);

    /** 
    Extract all injected MovableObjects of a given type. **/
    public void extractAllMovableObjectsByType(String typeName) {
        _extractAllMovableObjectsByType__StringR(this.object.pointer, typeName);
    }

    private native void _extractAllMovableObjectsByType__StringR(long _pointer_, String typeName);

    /** 
    Sets a mask which is bitwise 'and'ed with objects own visibility masks to determine if the object is visible. **/
    public void setVisibilityMask(long vmask) {
        _setVisibilityMask__uint32v(this.object.pointer, vmask);
    }

    private native void _setVisibilityMask__uint32v(long _pointer_, long vmask);

    /** 
    Gets a mask which is bitwise 'and'ed with objects own visibility masks to determine if the object is visible. **/
    public long getVisibilityMask() {
         return _getVisibilityMask(this.object.pointer);
    }

    private native long _getVisibilityMask(long _pointer_);

    /** 
    Internal method for getting the combination between the global visibility mask and the per-viewport visibility mask. **/
    public long _getCombinedVisibilityMask() {
         return __getCombinedVisibilityMask_const(this.object.pointer);
    }

    private native long __getCombinedVisibilityMask_const(long _pointer_);

    /** 
    Sets whether the  should search for visible objects, or whether they are being manually handled. **/
    public void setFindVisibleObjects(boolean find) {
        _setFindVisibleObjects__bv(this.object.pointer, find);
    }

    private native void _setFindVisibleObjects__bv(long _pointer_, boolean find);

    /** 
    Gets whether the  should search for visible objects, or whether they are being manually handled. **/
    public boolean getFindVisibleObjects() {
         return _getFindVisibleObjects(this.object.pointer);
    }

    private native boolean _getFindVisibleObjects(long _pointer_);

    /** 
    Set whether to automatically normalise normals on objects whenever they are scaled. **/
    public void setNormaliseNormalsOnScale(boolean n) {
        _setNormaliseNormalsOnScale__bv(this.object.pointer, n);
    }

    private native void _setNormaliseNormalsOnScale__bv(long _pointer_, boolean n);

    /** 
    Get whether to automatically normalise normals on objects whenever they are scaled. **/
    public boolean getNormaliseNormalsOnScale() {
         return _getNormaliseNormalsOnScale_const(this.object.pointer);
    }

    private native boolean _getNormaliseNormalsOnScale_const(long _pointer_);

    /** 
    Set whether to automatically flip the culling mode on objects whenever they are negatively scaled. **/
    public void setFlipCullingOnNegativeScale(boolean n) {
        _setFlipCullingOnNegativeScale__bv(this.object.pointer, n);
    }

    private native void _setFlipCullingOnNegativeScale__bv(long _pointer_, boolean n);

    /** 
    Get whether to automatically flip the culling mode on objects whenever they are negatively scaled. **/
    public boolean getFlipCullingOnNegativeScale() {
         return _getFlipCullingOnNegativeScale_const(this.object.pointer);
    }

    private native boolean _getFlipCullingOnNegativeScale_const(long _pointer_);

    /** 
    Render something as if it came from the current queue. **/
    public void _injectRenderWithPass(org.ogre4j.IPass pass, org.ogre4j.IRenderable rend, boolean shadowDerivation) {
        __injectRenderWithPass__PasspRenderablepbv(this.object.pointer, pass.getInstancePointer().pointer,  rend.getInstancePointer().pointer,  shadowDerivation);
    }

    private native void __injectRenderWithPass__PasspRenderablepbv(long _pointer_, long pass, long rend, boolean shadowDerivation);

    /** 
    Indicates to the  whether it should suppress changing the  states when rendering objects. **/
    public void _suppressRenderStateChanges(boolean suppress) {
        __suppressRenderStateChanges__bv(this.object.pointer, suppress);
    }

    private native void __suppressRenderStateChanges__bv(long _pointer_, boolean suppress);

    /** 
    Are render state changes suppressed? **/
    public boolean _areRenderStateChangesSuppressed() {
         return __areRenderStateChangesSuppressed_const(this.object.pointer);
    }

    private native boolean __areRenderStateChangesSuppressed_const(long _pointer_);

    /** 
    Internal method for setting up the renderstate for a rendering pass. **/
    public org.ogre4j.IPass _setPass(org.ogre4j.IPass pass, boolean evenIfSuppressed, boolean shadowDerivation) {
         return new org.ogre4j.Pass(new InstancePointer(__setPass__PassPbvbv(this.object.pointer, pass.getInstancePointer().pointer,  evenIfSuppressed,  shadowDerivation)));
    }

    private native long __setPass__PassPbvbv(long _pointer_, long pass, boolean evenIfSuppressed, boolean shadowDerivation);

    /** 
    Indicates to the  whether it should suppress the active shadow rendering technique until told otherwise. **/
    public void _suppressShadows(boolean suppress) {
        __suppressShadows__bv(this.object.pointer, suppress);
    }

    private native void __suppressShadows__bv(long _pointer_, boolean suppress);

    /** 
    Are shadows suppressed? **/
    public boolean _areShadowsSuppressed() {
         return __areShadowsSuppressed_const(this.object.pointer);
    }

    private native boolean __areShadowsSuppressed_const(long _pointer_);

    /** 
    Render the objects in a given queue group **/
    public void _renderQueueGroupObjects(org.ogre4j.IRenderQueueGroup group, org.ogre4j.QueuedRenderableCollection.OrganisationMode om) {
        __renderQueueGroupObjects__RenderQueueGrouppQueuedRenderableCollection_OrganisationModev(this.object.pointer, group.getInstancePointer().pointer,  om.getValue());
    }

    private native void __renderQueueGroupObjects__RenderQueueGrouppQueuedRenderableCollection_OrganisationModev(long _pointer_, long group, int om);

    /** 
    Advanced method for supplying an alternative visitor, used for parsing the render queues and sending the results to the renderer. **/
    public void setQueuedRenderableVisitor(org.ogre4j.ISceneManager.ISceneMgrQueuedRenderableVisitor visitor) {
        _setQueuedRenderableVisitor__SceneMgrQueuedRenderableVisitorp(this.object.pointer, visitor.getInstancePointer().pointer);
    }

    private native void _setQueuedRenderableVisitor__SceneMgrQueuedRenderableVisitorp(long _pointer_, long visitor);

    /** 
    Gets the current visitor object which processes queued renderables. **/
    public org.ogre4j.ISceneManager.ISceneMgrQueuedRenderableVisitor getQueuedRenderableVisitor() {
         return new org.ogre4j.SceneManager.SceneMgrQueuedRenderableVisitor(new InstancePointer(_getQueuedRenderableVisitor_const(this.object.pointer)));
    }

    private native long _getQueuedRenderableVisitor_const(long _pointer_);

    /** 
    Get the rendersystem subclass to which the output of this Scene Manager gets sent **/
    public org.ogre4j.IRenderSystem getDestinationRenderSystem() {
         return new org.ogre4j.RenderSystem(new InstancePointer(_getDestinationRenderSystem(this.object.pointer)));
    }

    private native long _getDestinationRenderSystem(long _pointer_);

    /** 
    Gets the current viewport being rendered (advanced use only, only valid during viewport update. **/
    public org.ogre4j.IViewport getCurrentViewport() {
         return new org.ogre4j.Viewport(new InstancePointer(_getCurrentViewport_const(this.object.pointer)));
    }

    private native long _getCurrentViewport_const(long _pointer_);

    /** 
    Returns a visibility boundary box for a specific camera. **/
    public org.ogre4j.IVisibleObjectsBoundsInfo getVisibleObjectsBoundsInfo(org.ogre4j.ICamera cam) {
         return new org.ogre4j.VisibleObjectsBoundsInfo(new InstancePointer(_getVisibleObjectsBoundsInfo__CameraP_const(this.object.pointer, cam.getInstancePointer().pointer)));
    }

    private native long _getVisibleObjectsBoundsInfo__CameraP_const(long _pointer_, long cam);

    /** 
    Returns the shadow caster AAB for a specific light-camera combination **/
    public org.ogre4j.IVisibleObjectsBoundsInfo getShadowCasterBoundsInfo(org.ogre4j.ILight light, int iteration) {
         return new org.ogre4j.VisibleObjectsBoundsInfo(new InstancePointer(_getShadowCasterBoundsInfo__LightPiv_const(this.object.pointer, light.getInstancePointer().pointer,  iteration)));
    }

    private native long _getShadowCasterBoundsInfo__LightPiv_const(long _pointer_, long light, int iteration);

    /** 
    Set whether to use camera-relative co-ordinates when rendering, ie to always place the camera at the origin and move the world around it. **/
    public void setCameraRelativeRendering(boolean rel) {
        _setCameraRelativeRendering__bv(this.object.pointer, rel);
    }

    private native void _setCameraRelativeRendering__bv(long _pointer_, boolean rel);

    /** 
    Get whether to use camera-relative co-ordinates when rendering, ie to always place the camera at the origin and move the world around it. **/
    public boolean getCameraRelativeRendering() {
         return _getCameraRelativeRendering_const(this.object.pointer);
    }

    private native boolean _getCameraRelativeRendering_const(long _pointer_);

    /** **/
    public static long getWORLD_GEOMETRY_TYPE_MASK() {
         return _getWORLD_GEOMETRY_TYPE_MASK();
    }

    private native static long _getWORLD_GEOMETRY_TYPE_MASK();

    /** **/
    public static void setWORLD_GEOMETRY_TYPE_MASK(long _jni_value_) {
        _setWORLD_GEOMETRY_TYPE_MASK( _jni_value_);
    }

    private native static void _setWORLD_GEOMETRY_TYPE_MASK(long _jni_value_);

    /** **/
    public static long getENTITY_TYPE_MASK() {
         return _getENTITY_TYPE_MASK();
    }

    private native static long _getENTITY_TYPE_MASK();

    /** **/
    public static void setENTITY_TYPE_MASK(long _jni_value_) {
        _setENTITY_TYPE_MASK( _jni_value_);
    }

    private native static void _setENTITY_TYPE_MASK(long _jni_value_);

    /** **/
    public static long getFX_TYPE_MASK() {
         return _getFX_TYPE_MASK();
    }

    private native static long _getFX_TYPE_MASK();

    /** **/
    public static void setFX_TYPE_MASK(long _jni_value_) {
        _setFX_TYPE_MASK( _jni_value_);
    }

    private native static void _setFX_TYPE_MASK(long _jni_value_);

    /** **/
    public static long getSTATICGEOMETRY_TYPE_MASK() {
         return _getSTATICGEOMETRY_TYPE_MASK();
    }

    private native static long _getSTATICGEOMETRY_TYPE_MASK();

    /** **/
    public static void setSTATICGEOMETRY_TYPE_MASK(long _jni_value_) {
        _setSTATICGEOMETRY_TYPE_MASK( _jni_value_);
    }

    private native static void _setSTATICGEOMETRY_TYPE_MASK(long _jni_value_);

    /** **/
    public static long getLIGHT_TYPE_MASK() {
         return _getLIGHT_TYPE_MASK();
    }

    private native static long _getLIGHT_TYPE_MASK();

    /** **/
    public static void setLIGHT_TYPE_MASK(long _jni_value_) {
        _setLIGHT_TYPE_MASK( _jni_value_);
    }

    private native static void _setLIGHT_TYPE_MASK(long _jni_value_);

    /** **/
    public static long getFRUSTUM_TYPE_MASK() {
         return _getFRUSTUM_TYPE_MASK();
    }

    private native static long _getFRUSTUM_TYPE_MASK();

    /** **/
    public static void setFRUSTUM_TYPE_MASK(long _jni_value_) {
        _setFRUSTUM_TYPE_MASK( _jni_value_);
    }

    private native static void _setFRUSTUM_TYPE_MASK(long _jni_value_);

    /** **/
    public static long getUSER_TYPE_MASK_LIMIT() {
         return _getUSER_TYPE_MASK_LIMIT();
    }

    private native static long _getUSER_TYPE_MASK_LIMIT();

    /** **/
    public static void setUSER_TYPE_MASK_LIMIT(long _jni_value_) {
        _setUSER_TYPE_MASK_LIMIT( _jni_value_);
    }

    private native static void _setUSER_TYPE_MASK_LIMIT(long _jni_value_);

}
