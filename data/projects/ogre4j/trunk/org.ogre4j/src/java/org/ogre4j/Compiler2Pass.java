/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class Compiler2Pass extends org.xbig.base.NativeObject implements org.ogre4j.ICompiler2Pass {
static { System.loadLibrary("ogre4j");}
protected static class LexemeTokenDef extends org.xbig.base.NativeObject implements org.ogre4j.ICompiler2Pass.ILexemeTokenDef {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public LexemeTokenDef(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected LexemeTokenDef(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public LexemeTokenDef(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public LexemeTokenDef() {
         super( new org.xbig.base.InstancePointer(__createLexemeTokenDef()), false);
    }

    private native static long __createLexemeTokenDef();

    /** **/
    public LexemeTokenDef(int ID, String lexeme, boolean hasAction, boolean caseSensitive) {
         super( new org.xbig.base.InstancePointer(__createLexemeTokenDef__iVStringRbVbV( ID,  lexeme,  hasAction,  caseSensitive)), false);
    }

    private native static long __createLexemeTokenDef__iVStringRbVbV(int ID, String lexeme, boolean hasAction, boolean caseSensitive);

    /** **/
    public int getID() {
         return _getID(this.object.pointer);
    }

    private native int _getID(long _pointer_);

    /** **/
    public void setID(int _jni_value_) {
        _setID(this.object.pointer, _jni_value_);
    }

    private native void _setID(long _pointer_, int _jni_value_);

    /** **/
    public boolean gethasAction() {
         return _gethasAction(this.object.pointer);
    }

    private native boolean _gethasAction(long _pointer_);

    /** **/
    public void sethasAction(boolean _jni_value_) {
        _sethasAction(this.object.pointer, _jni_value_);
    }

    private native void _sethasAction(long _pointer_, boolean _jni_value_);

    /** **/
    public boolean getisNonTerminal() {
         return _getisNonTerminal(this.object.pointer);
    }

    private native boolean _getisNonTerminal(long _pointer_);

    /** **/
    public void setisNonTerminal(boolean _jni_value_) {
        _setisNonTerminal(this.object.pointer, _jni_value_);
    }

    private native void _setisNonTerminal(long _pointer_, boolean _jni_value_);

    /** **/
    public int getruleID() {
         return _getruleID(this.object.pointer);
    }

    private native int _getruleID(long _pointer_);

    /** **/
    public void setruleID(int _jni_value_) {
        _setruleID(this.object.pointer, _jni_value_);
    }

    private native void _setruleID(long _pointer_, int _jni_value_);

    /** **/
    public boolean getisCaseSensitive() {
         return _getisCaseSensitive(this.object.pointer);
    }

    private native boolean _getisCaseSensitive(long _pointer_);

    /** **/
    public void setisCaseSensitive(boolean _jni_value_) {
        _setisCaseSensitive(this.object.pointer, _jni_value_);
    }

    private native void _setisCaseSensitive(long _pointer_, boolean _jni_value_);

    /** **/
    public String getlexeme() {
         return _getlexeme(this.object.pointer);
    }

    private native String _getlexeme(long _pointer_);

    /** **/
    public void setlexeme(String _jni_value_) {
        _setlexeme(this.object.pointer, _jni_value_);
    }

    private native void _setlexeme(long _pointer_, String _jni_value_);

}
protected static class TokenInst extends org.xbig.base.NativeObject implements org.ogre4j.ICompiler2Pass.ITokenInst {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public TokenInst(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected TokenInst(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public TokenInst(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public TokenInst() {
         super( new org.xbig.base.InstancePointer(__createTokenInst()), false);
    }

    private native static long __createTokenInst();

    /** **/
    public int getNTTRuleID() {
         return _getNTTRuleID(this.object.pointer);
    }

    private native int _getNTTRuleID(long _pointer_);

    /** **/
    public void setNTTRuleID(int _jni_value_) {
        _setNTTRuleID(this.object.pointer, _jni_value_);
    }

    private native void _setNTTRuleID(long _pointer_, int _jni_value_);

    /** **/
    public int gettokenID() {
         return _gettokenID(this.object.pointer);
    }

    private native int _gettokenID(long _pointer_);

    /** **/
    public void settokenID(int _jni_value_) {
        _settokenID(this.object.pointer, _jni_value_);
    }

    private native void _settokenID(long _pointer_, int _jni_value_);

    /** **/
    public int getline() {
         return _getline(this.object.pointer);
    }

    private native int _getline(long _pointer_);

    /** **/
    public void setline(int _jni_value_) {
        _setline(this.object.pointer, _jni_value_);
    }

    private native void _setline(long _pointer_, int _jni_value_);

    /** **/
    public int getpos() {
         return _getpos(this.object.pointer);
    }

    private native int _getpos(long _pointer_);

    /** **/
    public void setpos(int _jni_value_) {
        _setpos(this.object.pointer, _jni_value_);
    }

    private native void _setpos(long _pointer_, int _jni_value_);

    /** **/
    public boolean getfound() {
         return _getfound(this.object.pointer);
    }

    private native boolean _getfound(long _pointer_);

    /** **/
    public void setfound(boolean _jni_value_) {
        _setfound(this.object.pointer, _jni_value_);
    }

    private native void _setfound(long _pointer_, boolean _jni_value_);

}
protected static class TokenRule extends org.xbig.base.NativeObject implements org.ogre4j.ICompiler2Pass.ITokenRule {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public TokenRule(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected TokenRule(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public TokenRule(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public TokenRule() {
         super( new org.xbig.base.InstancePointer(__createTokenRule()), false);
    }

    private native static long __createTokenRule();

    /** **/
    public org.ogre4j.Compiler2Pass.OperationType getoperation() {
         return org.ogre4j.Compiler2Pass.OperationType.toEnum(_getoperation(this.object.pointer));
    }

    private native int _getoperation(long _pointer_);

    /** **/
    public void setoperation(org.ogre4j.Compiler2Pass.OperationType _jni_value_) {
        _setoperation(this.object.pointer, _jni_value_.getValue());
    }

    private native void _setoperation(long _pointer_, int _jni_value_);

    /** **/
    public int gettokenID() {
         return _gettokenID(this.object.pointer);
    }

    private native int _gettokenID(long _pointer_);

    /** **/
    public void settokenID(int _jni_value_) {
        _settokenID(this.object.pointer, _jni_value_);
    }

    private native void _settokenID(long _pointer_, int _jni_value_);

}
protected static class TokenState extends org.xbig.base.NativeObject implements org.ogre4j.ICompiler2Pass.ITokenState {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public TokenState(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected TokenState(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public TokenState(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public TokenState() {
         super( new org.xbig.base.InstancePointer(__createTokenState()), false);
    }

    private native static long __createTokenState();

    /** **/
    public void gettokenQue(org.ogre4j.ICompiler2Pass.ITokenInstContainer returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_gettokenQue(this.object.pointer)), false);
    }

    private native long _gettokenQue(long _pointer_);

    /** **/
    public void settokenQue(org.ogre4j.ICompiler2Pass.ITokenInstContainer _jni_value_) {
        _settokenQue(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _settokenQue(long _pointer_, long _jni_value_);

    /** **/
    public void getlexemeTokenDefinitions(org.ogre4j.ICompiler2Pass.ILexemeTokenDefContainer returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getlexemeTokenDefinitions(this.object.pointer)), false);
    }

    private native long _getlexemeTokenDefinitions(long _pointer_);

    /** **/
    public void setlexemeTokenDefinitions(org.ogre4j.ICompiler2Pass.ILexemeTokenDefContainer _jni_value_) {
        _setlexemeTokenDefinitions(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setlexemeTokenDefinitions(long _pointer_, long _jni_value_);

    /** **/
    public void getrootRulePath(org.ogre4j.ICompiler2Pass.ITokenRuleContainer returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getrootRulePath(this.object.pointer)), false);
    }

    private native long _getrootRulePath(long _pointer_);

    /** **/
    public void setrootRulePath(org.ogre4j.ICompiler2Pass.ITokenRuleContainer _jni_value_) {
        _setrootRulePath(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setrootRulePath(long _pointer_, long _jni_value_);

    /** **/
    public void getlexemeTokenMap(org.ogre4j.ICompiler2Pass.ILexemeTokenMap returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getlexemeTokenMap(this.object.pointer)), false);
    }

    private native long _getlexemeTokenMap(long _pointer_);

    /** **/
    public void setlexemeTokenMap(org.ogre4j.ICompiler2Pass.ILexemeTokenMap _jni_value_) {
        _setlexemeTokenMap(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setlexemeTokenMap(long _pointer_, long _jni_value_);

}
protected enum OperationType implements INativeEnum < OperationType > {
    otUNKNOWN(OperationTypeHelper.ENUM_VALUES[0]),
    otRULE(OperationTypeHelper.ENUM_VALUES[1]),
    otAND(OperationTypeHelper.ENUM_VALUES[2]),
    otOR(OperationTypeHelper.ENUM_VALUES[3]),
    otOPTIONAL(OperationTypeHelper.ENUM_VALUES[4]),
    otREPEAT(OperationTypeHelper.ENUM_VALUES[5]),
    otDATA(OperationTypeHelper.ENUM_VALUES[6]),
    otNOT_TEST(OperationTypeHelper.ENUM_VALUES[7]),
    otINSERT_TOKEN(OperationTypeHelper.ENUM_VALUES[8]),
    otEND(OperationTypeHelper.ENUM_VALUES[9]);

    private int value;

    OperationType(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public OperationType getEnum(int val) {
        return toEnum(val);
    }

    public static final OperationType toEnum(int retval) {
    if (retval ==otUNKNOWN.value)
        return OperationType.otUNKNOWN;
    else if (retval ==otRULE.value)
        return OperationType.otRULE;
    else if (retval ==otAND.value)
        return OperationType.otAND;
    else if (retval ==otOR.value)
        return OperationType.otOR;
    else if (retval ==otOPTIONAL.value)
        return OperationType.otOPTIONAL;
    else if (retval ==otREPEAT.value)
        return OperationType.otREPEAT;
    else if (retval ==otDATA.value)
        return OperationType.otDATA;
    else if (retval ==otNOT_TEST.value)
        return OperationType.otNOT_TEST;
    else if (retval ==otINSERT_TOKEN.value)
        return OperationType.otINSERT_TOKEN;
    else if (retval ==otEND.value)
        return OperationType.otEND;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class OperationTypeHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

protected enum SystemRuleToken implements INativeEnum < SystemRuleToken > {
    _no_token_(SystemRuleTokenHelper.ENUM_VALUES[0]),
    _character_(SystemRuleTokenHelper.ENUM_VALUES[1]),
    _value_(SystemRuleTokenHelper.ENUM_VALUES[2]),
    _no_space_skip_(SystemRuleTokenHelper.ENUM_VALUES[3]);

    private int value;

    SystemRuleToken(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public SystemRuleToken getEnum(int val) {
        return toEnum(val);
    }

    public static final SystemRuleToken toEnum(int retval) {
    if (retval ==_no_token_.value)
        return SystemRuleToken._no_token_;
    else if (retval ==_character_.value)
        return SystemRuleToken._character_;
    else if (retval ==_value_.value)
        return SystemRuleToken._value_;
    else if (retval ==_no_space_skip_.value)
        return SystemRuleToken._no_space_skip_;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class SystemRuleTokenHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

protected enum BNF_ID implements INativeEnum < BNF_ID > {
    BNF_UNKOWN(BNF_IDHelper.ENUM_VALUES[0]),
    BNF_SYNTAX(BNF_IDHelper.ENUM_VALUES[1]),
    BNF_RULE(BNF_IDHelper.ENUM_VALUES[2]),
    BNF_IDENTIFIER(BNF_IDHelper.ENUM_VALUES[3]),
    BNF_IDENTIFIER_RIGHT(BNF_IDHelper.ENUM_VALUES[4]),
    BNF_IDENTIFIER_CHARACTERS(BNF_IDHelper.ENUM_VALUES[5]),
    BNF_ID_BEGIN(BNF_IDHelper.ENUM_VALUES[6]),
    BNF_ID_END(BNF_IDHelper.ENUM_VALUES[7]),
    BNF_CONSTANT_BEGIN(BNF_IDHelper.ENUM_VALUES[8]),
    BNF_SET_RULE(BNF_IDHelper.ENUM_VALUES[9]),
    BNF_EXPRESSION(BNF_IDHelper.ENUM_VALUES[10]),
    BNF_AND_TERM(BNF_IDHelper.ENUM_VALUES[11]),
    BNF_OR_TERM(BNF_IDHelper.ENUM_VALUES[12]),
    BNF_TERM(BNF_IDHelper.ENUM_VALUES[13]),
    BNF_TERM_ID(BNF_IDHelper.ENUM_VALUES[14]),
    BNF_CONSTANT(BNF_IDHelper.ENUM_VALUES[15]),
    BNF_OR(BNF_IDHelper.ENUM_VALUES[16]),
    BNF_TERMINAL_SYMBOL(BNF_IDHelper.ENUM_VALUES[17]),
    BNF_TERMINAL_START(BNF_IDHelper.ENUM_VALUES[18]),
    BNF_REPEAT_EXPRESSION(BNF_IDHelper.ENUM_VALUES[19]),
    BNF_REPEAT_BEGIN(BNF_IDHelper.ENUM_VALUES[20]),
    BNF_REPEAT_END(BNF_IDHelper.ENUM_VALUES[21]),
    BNF_SET(BNF_IDHelper.ENUM_VALUES[22]),
    BNF_SET_BEGIN(BNF_IDHelper.ENUM_VALUES[23]),
    BNF_SET_END(BNF_IDHelper.ENUM_VALUES[24]),
    BNF_NOT_TEST(BNF_IDHelper.ENUM_VALUES[25]),
    BNF_NOT_TEST_BEGIN(BNF_IDHelper.ENUM_VALUES[26]),
    BNF_CONDITIONAL_TOKEN_INSERT(BNF_IDHelper.ENUM_VALUES[27]),
    BNF_OPTIONAL_EXPRESSION(BNF_IDHelper.ENUM_VALUES[28]),
    BNF_NOT_EXPRESSION(BNF_IDHelper.ENUM_VALUES[29]),
    BNF_NOT_CHK(BNF_IDHelper.ENUM_VALUES[30]),
    BNF_OPTIONAL_BEGIN(BNF_IDHelper.ENUM_VALUES[31]),
    BNF_OPTIONAL_END(BNF_IDHelper.ENUM_VALUES[32]),
    BNF_NO_TOKEN_START(BNF_IDHelper.ENUM_VALUES[33]),
    BNF_SINGLEQUOTE(BNF_IDHelper.ENUM_VALUES[34]),
    BNF_SINGLE_QUOTE_EXC(BNF_IDHelper.ENUM_VALUES[35]),
    BNF_SET_END_EXC(BNF_IDHelper.ENUM_VALUES[36]),
    BNF_ANY_CHARACTER(BNF_IDHelper.ENUM_VALUES[37]),
    BNF_SPECIAL_CHARACTERS1(BNF_IDHelper.ENUM_VALUES[38]),
    BNF_SPECIAL_CHARACTERS2(BNF_IDHelper.ENUM_VALUES[39]),
    BNF_WHITE_SPACE_CHK(BNF_IDHelper.ENUM_VALUES[40]),
    BNF_LETTER(BNF_IDHelper.ENUM_VALUES[41]),
    BNF_LETTER_DIGIT(BNF_IDHelper.ENUM_VALUES[42]),
    BNF_DIGIT(BNF_IDHelper.ENUM_VALUES[43]),
    BNF_WHITE_SPACE(BNF_IDHelper.ENUM_VALUES[44]),
    BNF_ALPHA_SET(BNF_IDHelper.ENUM_VALUES[45]),
    BNF_NUMBER_SET(BNF_IDHelper.ENUM_VALUES[46]),
    BNF_SPECIAL_CHARACTER_SET1(BNF_IDHelper.ENUM_VALUES[47]),
    BNF_SPECIAL_CHARACTER_SET2(BNF_IDHelper.ENUM_VALUES[48]),
    BNF_SPECIAL_CHARACTER_SET3(BNF_IDHelper.ENUM_VALUES[49]),
    BNF_NOT_CHARS(BNF_IDHelper.ENUM_VALUES[50]),
    BNF_AUTOTOKENSTART(BNF_IDHelper.ENUM_VALUES[51]);

    private int value;

    BNF_ID(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public BNF_ID getEnum(int val) {
        return toEnum(val);
    }

    public static final BNF_ID toEnum(int retval) {
    if (retval ==BNF_UNKOWN.value)
        return BNF_ID.BNF_UNKOWN;
    else if (retval ==BNF_SYNTAX.value)
        return BNF_ID.BNF_SYNTAX;
    else if (retval ==BNF_RULE.value)
        return BNF_ID.BNF_RULE;
    else if (retval ==BNF_IDENTIFIER.value)
        return BNF_ID.BNF_IDENTIFIER;
    else if (retval ==BNF_IDENTIFIER_RIGHT.value)
        return BNF_ID.BNF_IDENTIFIER_RIGHT;
    else if (retval ==BNF_IDENTIFIER_CHARACTERS.value)
        return BNF_ID.BNF_IDENTIFIER_CHARACTERS;
    else if (retval ==BNF_ID_BEGIN.value)
        return BNF_ID.BNF_ID_BEGIN;
    else if (retval ==BNF_ID_END.value)
        return BNF_ID.BNF_ID_END;
    else if (retval ==BNF_CONSTANT_BEGIN.value)
        return BNF_ID.BNF_CONSTANT_BEGIN;
    else if (retval ==BNF_SET_RULE.value)
        return BNF_ID.BNF_SET_RULE;
    else if (retval ==BNF_EXPRESSION.value)
        return BNF_ID.BNF_EXPRESSION;
    else if (retval ==BNF_AND_TERM.value)
        return BNF_ID.BNF_AND_TERM;
    else if (retval ==BNF_OR_TERM.value)
        return BNF_ID.BNF_OR_TERM;
    else if (retval ==BNF_TERM.value)
        return BNF_ID.BNF_TERM;
    else if (retval ==BNF_TERM_ID.value)
        return BNF_ID.BNF_TERM_ID;
    else if (retval ==BNF_CONSTANT.value)
        return BNF_ID.BNF_CONSTANT;
    else if (retval ==BNF_OR.value)
        return BNF_ID.BNF_OR;
    else if (retval ==BNF_TERMINAL_SYMBOL.value)
        return BNF_ID.BNF_TERMINAL_SYMBOL;
    else if (retval ==BNF_TERMINAL_START.value)
        return BNF_ID.BNF_TERMINAL_START;
    else if (retval ==BNF_REPEAT_EXPRESSION.value)
        return BNF_ID.BNF_REPEAT_EXPRESSION;
    else if (retval ==BNF_REPEAT_BEGIN.value)
        return BNF_ID.BNF_REPEAT_BEGIN;
    else if (retval ==BNF_REPEAT_END.value)
        return BNF_ID.BNF_REPEAT_END;
    else if (retval ==BNF_SET.value)
        return BNF_ID.BNF_SET;
    else if (retval ==BNF_SET_BEGIN.value)
        return BNF_ID.BNF_SET_BEGIN;
    else if (retval ==BNF_SET_END.value)
        return BNF_ID.BNF_SET_END;
    else if (retval ==BNF_NOT_TEST.value)
        return BNF_ID.BNF_NOT_TEST;
    else if (retval ==BNF_NOT_TEST_BEGIN.value)
        return BNF_ID.BNF_NOT_TEST_BEGIN;
    else if (retval ==BNF_CONDITIONAL_TOKEN_INSERT.value)
        return BNF_ID.BNF_CONDITIONAL_TOKEN_INSERT;
    else if (retval ==BNF_OPTIONAL_EXPRESSION.value)
        return BNF_ID.BNF_OPTIONAL_EXPRESSION;
    else if (retval ==BNF_NOT_EXPRESSION.value)
        return BNF_ID.BNF_NOT_EXPRESSION;
    else if (retval ==BNF_NOT_CHK.value)
        return BNF_ID.BNF_NOT_CHK;
    else if (retval ==BNF_OPTIONAL_BEGIN.value)
        return BNF_ID.BNF_OPTIONAL_BEGIN;
    else if (retval ==BNF_OPTIONAL_END.value)
        return BNF_ID.BNF_OPTIONAL_END;
    else if (retval ==BNF_NO_TOKEN_START.value)
        return BNF_ID.BNF_NO_TOKEN_START;
    else if (retval ==BNF_SINGLEQUOTE.value)
        return BNF_ID.BNF_SINGLEQUOTE;
    else if (retval ==BNF_SINGLE_QUOTE_EXC.value)
        return BNF_ID.BNF_SINGLE_QUOTE_EXC;
    else if (retval ==BNF_SET_END_EXC.value)
        return BNF_ID.BNF_SET_END_EXC;
    else if (retval ==BNF_ANY_CHARACTER.value)
        return BNF_ID.BNF_ANY_CHARACTER;
    else if (retval ==BNF_SPECIAL_CHARACTERS1.value)
        return BNF_ID.BNF_SPECIAL_CHARACTERS1;
    else if (retval ==BNF_SPECIAL_CHARACTERS2.value)
        return BNF_ID.BNF_SPECIAL_CHARACTERS2;
    else if (retval ==BNF_WHITE_SPACE_CHK.value)
        return BNF_ID.BNF_WHITE_SPACE_CHK;
    else if (retval ==BNF_LETTER.value)
        return BNF_ID.BNF_LETTER;
    else if (retval ==BNF_LETTER_DIGIT.value)
        return BNF_ID.BNF_LETTER_DIGIT;
    else if (retval ==BNF_DIGIT.value)
        return BNF_ID.BNF_DIGIT;
    else if (retval ==BNF_WHITE_SPACE.value)
        return BNF_ID.BNF_WHITE_SPACE;
    else if (retval ==BNF_ALPHA_SET.value)
        return BNF_ID.BNF_ALPHA_SET;
    else if (retval ==BNF_NUMBER_SET.value)
        return BNF_ID.BNF_NUMBER_SET;
    else if (retval ==BNF_SPECIAL_CHARACTER_SET1.value)
        return BNF_ID.BNF_SPECIAL_CHARACTER_SET1;
    else if (retval ==BNF_SPECIAL_CHARACTER_SET2.value)
        return BNF_ID.BNF_SPECIAL_CHARACTER_SET2;
    else if (retval ==BNF_SPECIAL_CHARACTER_SET3.value)
        return BNF_ID.BNF_SPECIAL_CHARACTER_SET3;
    else if (retval ==BNF_NOT_CHARS.value)
        return BNF_ID.BNF_NOT_CHARS;
    else if (retval ==BNF_AUTOTOKENSTART.value)
        return BNF_ID.BNF_AUTOTOKENSTART;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class BNF_IDHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

protected static class TokenRuleContainer extends org.xbig.base.NativeObject implements org.ogre4j.ICompiler2Pass.ITokenRuleContainer {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public TokenRuleContainer(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected TokenRuleContainer(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public TokenRuleContainer(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public TokenRuleContainer() {
         super( new org.xbig.base.InstancePointer(__createTokenRuleContainer()), false);
    }

    private native static long __createTokenRuleContainer();

    /** **/
    public void assign(int num, org.ogre4j.ICompiler2Pass.ITokenRule val) {
        _assign__ivOgre_Compiler2Pass_TokenRuleR(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_Compiler2Pass_TokenRuleR(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.ICompiler2Pass.ITokenRule at(int loc) {
         return new org.ogre4j.Compiler2Pass.TokenRule(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.ICompiler2Pass.ITokenRule back() {
         return new org.ogre4j.Compiler2Pass.TokenRule(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.ICompiler2Pass.ITokenRule front() {
         return new org.ogre4j.Compiler2Pass.TokenRule(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.ICompiler2Pass.ITokenRule val) {
        _push_back__Ogre_Compiler2Pass_TokenRuleR(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_Compiler2Pass_TokenRuleR(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
protected static class LexemeTokenDefContainer extends org.xbig.base.NativeObject implements org.ogre4j.ICompiler2Pass.ILexemeTokenDefContainer {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public LexemeTokenDefContainer(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected LexemeTokenDefContainer(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public LexemeTokenDefContainer(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public LexemeTokenDefContainer() {
         super( new org.xbig.base.InstancePointer(__createLexemeTokenDefContainer()), false);
    }

    private native static long __createLexemeTokenDefContainer();

    /** **/
    public void assign(int num, org.ogre4j.ICompiler2Pass.ILexemeTokenDef val) {
        _assign__ivOgre_Compiler2Pass_LexemeTokenDefR(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_Compiler2Pass_LexemeTokenDefR(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.ICompiler2Pass.ILexemeTokenDef at(int loc) {
         return new org.ogre4j.Compiler2Pass.LexemeTokenDef(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.ICompiler2Pass.ILexemeTokenDef back() {
         return new org.ogre4j.Compiler2Pass.LexemeTokenDef(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.ICompiler2Pass.ILexemeTokenDef front() {
         return new org.ogre4j.Compiler2Pass.LexemeTokenDef(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.ICompiler2Pass.ILexemeTokenDef val) {
        _push_back__Ogre_Compiler2Pass_LexemeTokenDefR(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_Compiler2Pass_LexemeTokenDefR(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
protected static class LexemeTokenMap extends org.xbig.base.NativeObject implements org.ogre4j.ICompiler2Pass.ILexemeTokenMap {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public LexemeTokenMap(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected LexemeTokenMap(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public LexemeTokenMap(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public LexemeTokenMap() {
         super( new org.xbig.base.InstancePointer(__createLexemeTokenMap()), false);
    }

    private native static long __createLexemeTokenMap();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public IntegerPointer get(String key) {
         return new IntegerPointer(new InstancePointer(_get__sR(this.object.pointer, key)));
    }

    private native long _get__sR(long _pointer_, String key);

    /** **/
    public void insert(String key, IntegerPointer value) {
        _insert__sRir(this.object.pointer, key,  value.object.pointer);
    }

    private native void _insert__sRir(long _pointer_, String key, long value);

}
protected static class TokenInstContainer extends org.xbig.base.NativeObject implements org.ogre4j.ICompiler2Pass.ITokenInstContainer {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public TokenInstContainer(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected TokenInstContainer(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public TokenInstContainer(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public TokenInstContainer() {
         super( new org.xbig.base.InstancePointer(__createTokenInstContainer()), false);
    }

    private native static long __createTokenInstContainer();

    /** **/
    public void assign(int num, org.ogre4j.ICompiler2Pass.ITokenInst val) {
        _assign__ivOgre_Compiler2Pass_TokenInstR(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_Compiler2Pass_TokenInstR(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.ICompiler2Pass.ITokenInst at(int loc) {
         return new org.ogre4j.Compiler2Pass.TokenInst(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.ICompiler2Pass.ITokenInst back() {
         return new org.ogre4j.Compiler2Pass.TokenInst(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.ICompiler2Pass.ITokenInst front() {
         return new org.ogre4j.Compiler2Pass.TokenInst(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.ICompiler2Pass.ITokenInst val) {
        _push_back__Ogre_Compiler2Pass_TokenInstR(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_Compiler2Pass_TokenInstR(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
protected static class LabelContainer extends org.xbig.base.NativeObject implements org.ogre4j.ICompiler2Pass.ILabelContainer {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public LabelContainer(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected LabelContainer(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public LabelContainer(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public LabelContainer() {
         super( new org.xbig.base.InstancePointer(__createLabelContainer()), false);
    }

    private native static long __createLabelContainer();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(int key) {
         return _count__iR(this.object.pointer, key);
    }

    private native int _count__iR(long _pointer_, int key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(int key) {
         return _erase__iR(this.object.pointer, key);
    }

    private native int _erase__iR(long _pointer_, int key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public StringPointer get(int key) {
         return new StringPointer(new InstancePointer(_get__iR(this.object.pointer, key)));
    }

    private native long _get__iR(long _pointer_, int key);

    /** **/
    public void insert(int key, StringPointer value) {
        _insert__iRsr(this.object.pointer, key,  value.object.pointer);
    }

    private native void _insert__iRsr(long _pointer_, int key, long value);

}
private static class TokenStateContainer extends org.xbig.base.NativeObject implements org.ogre4j.ICompiler2Pass.ITokenStateContainer {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public TokenStateContainer(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected TokenStateContainer(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public TokenStateContainer(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public TokenStateContainer() {
         super( new org.xbig.base.InstancePointer(__createTokenStateContainer()), false);
    }

    private native static long __createTokenStateContainer();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.ICompiler2Pass.ITokenState get(String key) {
         return new org.ogre4j.Compiler2Pass.TokenState(new InstancePointer(_get__sR(this.object.pointer, key)));
    }

    private native long _get__sR(long _pointer_, String key);

    /** **/
    public void insert(String key, org.ogre4j.ICompiler2Pass.ITokenState value) {
        _insert__sROgre_Compiler2Pass_TokenStater(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__sROgre_Compiler2Pass_TokenStater(long _pointer_, String key, long value);

}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public Compiler2Pass(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected Compiler2Pass(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public Compiler2Pass(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** 
    compile the source - performs 2 passes. First pass is to tokenize, check semantics and context. The second pass is performed by using tokens to look up function implementors and executing them which convert tokens to application specific instructions. **/
    public boolean compile(String source, String sourceName) {
         return _compile__StringRStringR(this.object.pointer, source,  sourceName);
    }

    private native boolean _compile__StringRStringR(long _pointer_, String source, String sourceName);

    /** 
    gets BNF Grammar. Gets called when BNF grammar has to be compiled for the first time. **/
    public String getClientBNFGrammer() {
         return _getClientBNFGrammer_const(this.object.pointer);
    }

    private native String _getClientBNFGrammer_const(long _pointer_);

    /** 
    get the name of the BNF grammar. **/
    public String getClientGrammerName() {
         return _getClientGrammerName_const(this.object.pointer);
    }

    private native String _getClientGrammerName_const(long _pointer_);

}
