/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class Math extends org.xbig.base.NativeObject implements org.ogre4j.IMath {
static { System.loadLibrary("ogre4j");}
public enum AngleUnit implements INativeEnum < AngleUnit > {
    AU_DEGREE(AngleUnitHelper.ENUM_VALUES[0]),
    AU_RADIAN(AngleUnitHelper.ENUM_VALUES[1]);

    private int value;

    AngleUnit(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public AngleUnit getEnum(int val) {
        return toEnum(val);
    }

    public static final AngleUnit toEnum(int retval) {
    if (retval ==AU_DEGREE.value)
        return AngleUnit.AU_DEGREE;
    else if (retval ==AU_RADIAN.value)
        return AngleUnit.AU_RADIAN;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class AngleUnitHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public Math(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected Math(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public Math(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** 
    Default constructor. **/
    public Math(long trigTableSize) {
         super( new org.xbig.base.InstancePointer(__createMath__Iv( trigTableSize)), false);
    }

    private native static long __createMath__Iv(long trigTableSize);

    /** **/
    public static int IAbs(int iValue) {
         return _IAbs__iv( iValue);
    }

    private native static int _IAbs__iv(int iValue);

    /** **/
    public static int ICeil(float fValue) {
         return _ICeil__Fv( fValue);
    }

    private native static int _ICeil__Fv(float fValue);

    /** **/
    public static int IFloor(float fValue) {
         return _IFloor__Fv( fValue);
    }

    private native static int _IFloor__Fv(float fValue);

    /** **/
    public static int ISign(int iValue) {
         return _ISign__iv( iValue);
    }

    private native static int _ISign__iv(int iValue);

    /** **/
    public static float Abs(float fValue) {
         return _Abs__Realv( fValue);
    }

    private native static float _Abs__Realv(float fValue);

    /** **/
    public static void Abs(org.ogre4j.IDegree returnValue, org.ogre4j.IDegree dValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_Abs__DegreeR( dValue.getInstancePointer().pointer)), false);
    }

    private native static long _Abs__DegreeR(long dValue);

    /** **/
    public static void Abs(org.ogre4j.IRadian returnValue, org.ogre4j.IRadian rValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_Abs__RadianR( rValue.getInstancePointer().pointer)), false);
    }

    private native static long _Abs__RadianR(long rValue);

    /** **/
    public static void ACos(org.ogre4j.IRadian returnValue, float fValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_ACos__Realv( fValue)), false);
    }

    private native static long _ACos__Realv(float fValue);

    /** **/
    public static void ASin(org.ogre4j.IRadian returnValue, float fValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_ASin__Realv( fValue)), false);
    }

    private native static long _ASin__Realv(float fValue);

    /** **/
    public static void ATan(org.ogre4j.IRadian returnValue, float fValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_ATan__Realv( fValue)), false);
    }

    private native static long _ATan__Realv(float fValue);

    /** **/
    public static void ATan2(org.ogre4j.IRadian returnValue, float fY, float fX) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_ATan2__RealvRealv( fY,  fX)), false);
    }

    private native static long _ATan2__RealvRealv(float fY, float fX);

    /** **/
    public static float Ceil(float fValue) {
         return _Ceil__Realv( fValue);
    }

    private native static float _Ceil__Realv(float fValue);

    /** 
    Cosine function. **/
    public static float Cos(org.ogre4j.IRadian fValue, boolean useTables) {
         return _Cos__RadianRbv( fValue.getInstancePointer().pointer,  useTables);
    }

    private native static float _Cos__RadianRbv(long fValue, boolean useTables);

    /** 
    Cosine function. **/
    public static float Cos(float fValue, boolean useTables) {
         return _Cos__Realvbv( fValue,  useTables);
    }

    private native static float _Cos__Realvbv(float fValue, boolean useTables);

    /** **/
    public static float Exp(float fValue) {
         return _Exp__Realv( fValue);
    }

    private native static float _Exp__Realv(float fValue);

    /** **/
    public static float Floor(float fValue) {
         return _Floor__Realv( fValue);
    }

    private native static float _Floor__Realv(float fValue);

    /** **/
    public static float Log(float fValue) {
         return _Log__Realv( fValue);
    }

    private native static float _Log__Realv(float fValue);

    /** **/
    public static float Pow(float fBase, float fExponent) {
         return _Pow__RealvRealv( fBase,  fExponent);
    }

    private native static float _Pow__RealvRealv(float fBase, float fExponent);

    /** **/
    public static float Sign(float fValue) {
         return _Sign__Realv( fValue);
    }

    private native static float _Sign__Realv(float fValue);

    /** **/
    public static void Sign(org.ogre4j.IRadian returnValue, org.ogre4j.IRadian rValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_Sign__RadianR( rValue.getInstancePointer().pointer)), false);
    }

    private native static long _Sign__RadianR(long rValue);

    /** **/
    public static void Sign(org.ogre4j.IDegree returnValue, org.ogre4j.IDegree dValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_Sign__DegreeR( dValue.getInstancePointer().pointer)), false);
    }

    private native static long _Sign__DegreeR(long dValue);

    /** 
    Sine function. **/
    public static float Sin(org.ogre4j.IRadian fValue, boolean useTables) {
         return _Sin__RadianRbv( fValue.getInstancePointer().pointer,  useTables);
    }

    private native static float _Sin__RadianRbv(long fValue, boolean useTables);

    /** 
    Sine function. **/
    public static float Sin(float fValue, boolean useTables) {
         return _Sin__Realvbv( fValue,  useTables);
    }

    private native static float _Sin__Realvbv(float fValue, boolean useTables);

    /** **/
    public static float Sqr(float fValue) {
         return _Sqr__Realv( fValue);
    }

    private native static float _Sqr__Realv(float fValue);

    /** **/
    public static float Sqrt(float fValue) {
         return _Sqrt__Realv( fValue);
    }

    private native static float _Sqrt__Realv(float fValue);

    /** **/
    public static void Sqrt(org.ogre4j.IRadian returnValue, org.ogre4j.IRadian fValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_Sqrt__RadianR( fValue.getInstancePointer().pointer)), false);
    }

    private native static long _Sqrt__RadianR(long fValue);

    /** **/
    public static void Sqrt(org.ogre4j.IDegree returnValue, org.ogre4j.IDegree fValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_Sqrt__DegreeR( fValue.getInstancePointer().pointer)), false);
    }

    private native static long _Sqrt__DegreeR(long fValue);

    /** 
    Inverse square root i.e. 1 / Sqrt(x), good for vector normalisation. **/
    public static float InvSqrt(float fValue) {
         return _InvSqrt__Realv( fValue);
    }

    private native static float _InvSqrt__Realv(float fValue);

    /** **/
    public static float UnitRandom() {
         return _UnitRandom();
    }

    private native static float _UnitRandom();

    /** **/
    public static float RangeRandom(float fLow, float fHigh) {
         return _RangeRandom__RealvRealv( fLow,  fHigh);
    }

    private native static float _RangeRandom__RealvRealv(float fLow, float fHigh);

    /** **/
    public static float SymmetricRandom() {
         return _SymmetricRandom();
    }

    private native static float _SymmetricRandom();

    /** 
    Tangent function. **/
    public static float Tan(org.ogre4j.IRadian fValue, boolean useTables) {
         return _Tan__RadianRbv( fValue.getInstancePointer().pointer,  useTables);
    }

    private native static float _Tan__RadianRbv(long fValue, boolean useTables);

    /** 
    Tangent function. **/
    public static float Tan(float fValue, boolean useTables) {
         return _Tan__Realvbv( fValue,  useTables);
    }

    private native static float _Tan__Realvbv(float fValue, boolean useTables);

    /** **/
    public static float DegreesToRadians(float degrees) {
         return _DegreesToRadians__Realv( degrees);
    }

    private native static float _DegreesToRadians__Realv(float degrees);

    /** **/
    public static float RadiansToDegrees(float radians) {
         return _RadiansToDegrees__Realv( radians);
    }

    private native static float _RadiansToDegrees__Realv(float radians);

    /** 
    These functions used to set the assumed angle units (radians or degrees) expected when using the  type. **/
    public static void setAngleUnit(org.ogre4j.Math.AngleUnit unit) {
        _setAngleUnit__AngleUnitv( unit.getValue());
    }

    private native static void _setAngleUnit__AngleUnitv(int unit);

    /** 
    Get the unit being used for angles. **/
    public static org.ogre4j.Math.AngleUnit getAngleUnit() {
         return org.ogre4j.Math.AngleUnit.toEnum(_getAngleUnit());
    }

    private native static int _getAngleUnit();

    /** 
    Convert from the current AngleUnit to radians. **/
    public static float AngleUnitsToRadians(float units) {
         return _AngleUnitsToRadians__Realv( units);
    }

    private native static float _AngleUnitsToRadians__Realv(float units);

    /** 
    Convert from radians to the current AngleUnit . **/
    public static float RadiansToAngleUnits(float radians) {
         return _RadiansToAngleUnits__Realv( radians);
    }

    private native static float _RadiansToAngleUnits__Realv(float radians);

    /** 
    Convert from the current AngleUnit to degrees. **/
    public static float AngleUnitsToDegrees(float units) {
         return _AngleUnitsToDegrees__Realv( units);
    }

    private native static float _AngleUnitsToDegrees__Realv(float units);

    /** 
    Convert from degrees to the current AngleUnit. **/
    public static float DegreesToAngleUnits(float degrees) {
         return _DegreesToAngleUnits__Realv( degrees);
    }

    private native static float _DegreesToAngleUnits__Realv(float degrees);

    /** 
    Checks whether a given point is inside a triangle, in a 2-dimensional (Cartesian) space. **/
    public static boolean pointInTri2D(org.ogre4j.IVector2 p, org.ogre4j.IVector2 a, org.ogre4j.IVector2 b, org.ogre4j.IVector2 c) {
         return _pointInTri2D__Vector2RVector2RVector2RVector2R( p.getInstancePointer().pointer,  a.getInstancePointer().pointer,  b.getInstancePointer().pointer,  c.getInstancePointer().pointer);
    }

    private native static boolean _pointInTri2D__Vector2RVector2RVector2RVector2R(long p, long a, long b, long c);

    /** 
    Checks whether a given 3D point is inside a triangle. **/
    public static boolean pointInTri3D(org.ogre4j.IVector3 p, org.ogre4j.IVector3 a, org.ogre4j.IVector3 b, org.ogre4j.IVector3 c, org.ogre4j.IVector3 normal) {
         return _pointInTri3D__Vector3RVector3RVector3RVector3RVector3R( p.getInstancePointer().pointer,  a.getInstancePointer().pointer,  b.getInstancePointer().pointer,  c.getInstancePointer().pointer,  normal.getInstancePointer().pointer);
    }

    private native static boolean _pointInTri3D__Vector3RVector3RVector3RVector3RVector3R(long p, long a, long b, long c, long normal);

    /** 
     / plane intersection, returns boolean result and distance. **/
    public static void intersects(org.std.Ipair< Boolean, Float > returnValue, org.ogre4j.IRay ray, org.ogre4j.IPlane plane) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_intersects__RayRPlaneR( ray.getInstancePointer().pointer,  plane.getInstancePointer().pointer)), false);
    }

    private native static long _intersects__RayRPlaneR(long ray, long plane);

    /** 
     / sphere intersection, returns boolean result and distance. **/
    public static void intersects(org.std.Ipair< Boolean, Float > returnValue, org.ogre4j.IRay ray, org.ogre4j.ISphere sphere, boolean discardInside) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_intersects__RayRSphereRbv( ray.getInstancePointer().pointer,  sphere.getInstancePointer().pointer,  discardInside)), false);
    }

    private native static long _intersects__RayRSphereRbv(long ray, long sphere, boolean discardInside);

    /** 
     / box intersection, returns boolean result and distance. **/
    public static void intersects(org.std.Ipair< Boolean, Float > returnValue, org.ogre4j.IRay ray, org.ogre4j.IAxisAlignedBox box) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_intersects__RayRAxisAlignedBoxR( ray.getInstancePointer().pointer,  box.getInstancePointer().pointer)), false);
    }

    private native static long _intersects__RayRAxisAlignedBoxR(long ray, long box);

    /** 
     / box intersection, returns boolean result and two intersection distance. **/
    public static boolean intersects(org.ogre4j.IRay ray, org.ogre4j.IAxisAlignedBox box, FloatPointer d1, FloatPointer d2) {
         return _intersects__RayRAxisAlignedBoxRRealpRealp( ray.getInstancePointer().pointer,  box.getInstancePointer().pointer,  d1.object.pointer,  d2.object.pointer);
    }

    private native static boolean _intersects__RayRAxisAlignedBoxRRealpRealp(long ray, long box, long d1, long d2);

    /** 
     / triangle intersection, returns boolean result and distance. **/
    public static void intersects(org.std.Ipair< Boolean, Float > returnValue, org.ogre4j.IRay ray, org.ogre4j.IVector3 a, org.ogre4j.IVector3 b, org.ogre4j.IVector3 c, org.ogre4j.IVector3 normal, boolean positiveSide, boolean negativeSide) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_intersects__RayRVector3RVector3RVector3RVector3Rbvbv( ray.getInstancePointer().pointer,  a.getInstancePointer().pointer,  b.getInstancePointer().pointer,  c.getInstancePointer().pointer,  normal.getInstancePointer().pointer,  positiveSide,  negativeSide)), false);
    }

    private native static long _intersects__RayRVector3RVector3RVector3RVector3Rbvbv(long ray, long a, long b, long c, long normal, boolean positiveSide, boolean negativeSide);

    /** 
     / triangle intersection, returns boolean result and distance. **/
    public static void intersects(org.std.Ipair< Boolean, Float > returnValue, org.ogre4j.IRay ray, org.ogre4j.IVector3 a, org.ogre4j.IVector3 b, org.ogre4j.IVector3 c, boolean positiveSide, boolean negativeSide) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_intersects__RayRVector3RVector3RVector3Rbvbv( ray.getInstancePointer().pointer,  a.getInstancePointer().pointer,  b.getInstancePointer().pointer,  c.getInstancePointer().pointer,  positiveSide,  negativeSide)), false);
    }

    private native static long _intersects__RayRVector3RVector3RVector3Rbvbv(long ray, long a, long b, long c, boolean positiveSide, boolean negativeSide);

    /** 
     / box intersection test. **/
    public static boolean intersects(org.ogre4j.ISphere sphere, org.ogre4j.IAxisAlignedBox box) {
         return _intersects__SphereRAxisAlignedBoxR( sphere.getInstancePointer().pointer,  box.getInstancePointer().pointer);
    }

    private native static boolean _intersects__SphereRAxisAlignedBoxR(long sphere, long box);

    /** 
     / box intersection test. **/
    public static boolean intersects(org.ogre4j.IPlane plane, org.ogre4j.IAxisAlignedBox box) {
         return _intersects__PlaneRAxisAlignedBoxR( plane.getInstancePointer().pointer,  box.getInstancePointer().pointer);
    }

    private native static boolean _intersects__PlaneRAxisAlignedBoxR(long plane, long box);

    /** 
     / convex plane list intersection test. **/
    public static void intersects(org.std.Ipair< Boolean, Float > returnValue, org.ogre4j.IRay ray, org.std.Ivector< org.ogre4j.IPlane > planeList, boolean normalIsOutside) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_intersects__RayRstd_vector__Plane__rbv( ray.getInstancePointer().pointer,  planeList.getInstancePointer().pointer,  normalIsOutside)), false);
    }

    private native static long _intersects__RayRstd_vector__Plane__rbv(long ray, long planeList, boolean normalIsOutside);

    /** 
     / convex plane list intersection test. **/
    public static void intersects(org.std.Ipair< Boolean, Float > returnValue, org.ogre4j.IRay ray, org.std.Ilist< org.ogre4j.IPlane > planeList, boolean normalIsOutside) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_intersects__RayRstd_list__Plane__rbv( ray.getInstancePointer().pointer,  planeList.getInstancePointer().pointer,  normalIsOutside)), false);
    }

    private native static long _intersects__RayRstd_list__Plane__rbv(long ray, long planeList, boolean normalIsOutside);

    /** 
     / plane intersection test. **/
    public static boolean intersects(org.ogre4j.ISphere sphere, org.ogre4j.IPlane plane) {
         return _intersects__SphereRPlaneR( sphere.getInstancePointer().pointer,  plane.getInstancePointer().pointer);
    }

    private native static boolean _intersects__SphereRPlaneR(long sphere, long plane);

    /** 
    Compare 2 reals, using tolerance for inaccuracies. **/
    public static boolean RealEqual(float a, float b, float tolerance) {
         return _RealEqual__RealvRealvRealv( a,  b,  tolerance);
    }

    private native static boolean _RealEqual__RealvRealvRealv(float a, float b, float tolerance);

    /** 
    Calculates the tangent space vector for a given set of positions / texture coords. **/
    public static void calculateTangentSpaceVector(org.ogre4j.IVector3 returnValue, org.ogre4j.IVector3 position1, org.ogre4j.IVector3 position2, org.ogre4j.IVector3 position3, float u1, float v1, float u2, float v2, float u3, float v3) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_calculateTangentSpaceVector__Vector3RVector3RVector3RRealvRealvRealvRealvRealvRealv( position1.getInstancePointer().pointer,  position2.getInstancePointer().pointer,  position3.getInstancePointer().pointer,  u1,  v1,  u2,  v2,  u3,  v3)), false);
    }

    private native static long _calculateTangentSpaceVector__Vector3RVector3RVector3RRealvRealvRealvRealvRealvRealv(long position1, long position2, long position3, float u1, float v1, float u2, float v2, float u3, float v3);

    /** 
    Build a reflection matrix for the passed in plane. **/
    public static void buildReflectionMatrix(org.ogre4j.IMatrix4 returnValue, org.ogre4j.IPlane p) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_buildReflectionMatrix__PlaneR( p.getInstancePointer().pointer)), false);
    }

    private native static long _buildReflectionMatrix__PlaneR(long p);

    /** 
    Calculate a face normal, including the w component which is the offset from the origin. **/
    public static void calculateFaceNormal(org.ogre4j.IVector4 returnValue, org.ogre4j.IVector3 v1, org.ogre4j.IVector3 v2, org.ogre4j.IVector3 v3) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_calculateFaceNormal__Vector3RVector3RVector3R( v1.getInstancePointer().pointer,  v2.getInstancePointer().pointer,  v3.getInstancePointer().pointer)), false);
    }

    private native static long _calculateFaceNormal__Vector3RVector3RVector3R(long v1, long v2, long v3);

    /** 
    Calculate a face normal, no w-information. **/
    public static void calculateBasicFaceNormal(org.ogre4j.IVector3 returnValue, org.ogre4j.IVector3 v1, org.ogre4j.IVector3 v2, org.ogre4j.IVector3 v3) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_calculateBasicFaceNormal__Vector3RVector3RVector3R( v1.getInstancePointer().pointer,  v2.getInstancePointer().pointer,  v3.getInstancePointer().pointer)), false);
    }

    private native static long _calculateBasicFaceNormal__Vector3RVector3RVector3R(long v1, long v2, long v3);

    /** 
    Calculate a face normal without normalize, including the w component which is the offset from the origin. **/
    public static void calculateFaceNormalWithoutNormalize(org.ogre4j.IVector4 returnValue, org.ogre4j.IVector3 v1, org.ogre4j.IVector3 v2, org.ogre4j.IVector3 v3) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_calculateFaceNormalWithoutNormalize__Vector3RVector3RVector3R( v1.getInstancePointer().pointer,  v2.getInstancePointer().pointer,  v3.getInstancePointer().pointer)), false);
    }

    private native static long _calculateFaceNormalWithoutNormalize__Vector3RVector3RVector3R(long v1, long v2, long v3);

    /** 
    Calculate a face normal without normalize, no w-information. **/
    public static void calculateBasicFaceNormalWithoutNormalize(org.ogre4j.IVector3 returnValue, org.ogre4j.IVector3 v1, org.ogre4j.IVector3 v2, org.ogre4j.IVector3 v3) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_calculateBasicFaceNormalWithoutNormalize__Vector3RVector3RVector3R( v1.getInstancePointer().pointer,  v2.getInstancePointer().pointer,  v3.getInstancePointer().pointer)), false);
    }

    private native static long _calculateBasicFaceNormalWithoutNormalize__Vector3RVector3RVector3R(long v1, long v2, long v3);

    /** 
    Generates a value based on the Gaussian (normal) distribution function with the given offset and scale parameters. **/
    public static float gaussianDistribution(float x, float offset, float scale) {
         return _gaussianDistribution__RealvRealvRealv( x,  offset,  scale);
    }

    private native static float _gaussianDistribution__RealvRealvRealv(float x, float offset, float scale);

    /** **/
    public static void makeViewMatrix(org.ogre4j.IMatrix4 returnValue, org.ogre4j.IVector3 position, org.ogre4j.IQuaternion orientation, org.ogre4j.IMatrix4 reflectMatrix) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_makeViewMatrix__Vector3RQuaternionRMatrix4P( position.getInstancePointer().pointer,  orientation.getInstancePointer().pointer,  reflectMatrix.getInstancePointer().pointer)), false);
    }

    private native static long _makeViewMatrix__Vector3RQuaternionRMatrix4P(long position, long orientation, long reflectMatrix);

    /** **/
    public static float getPOS_INFINITY() {
         return _getPOS_INFINITY();
    }

    private native static float _getPOS_INFINITY();

    /** **/
    public static float getNEG_INFINITY() {
         return _getNEG_INFINITY();
    }

    private native static float _getNEG_INFINITY();

    /** **/
    public static float getPI() {
         return _getPI();
    }

    private native static float _getPI();

    /** **/
    public static float getTWO_PI() {
         return _getTWO_PI();
    }

    private native static float _getTWO_PI();

    /** **/
    public static float getHALF_PI() {
         return _getHALF_PI();
    }

    private native static float _getHALF_PI();

    /** **/
    public static float getfDeg2Rad() {
         return _getfDeg2Rad();
    }

    private native static float _getfDeg2Rad();

    /** **/
    public static float getfRad2Deg() {
         return _getfRad2Deg();
    }

    private native static float _getfRad2Deg();

}
