/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class Mesh extends org.xbig.base.NativeObject implements org.ogre4j.IMesh {
static { System.loadLibrary("ogre4j");}
public static class LodDistanceList extends org.xbig.base.NativeObject implements org.ogre4j.IMesh.ILodDistanceList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public LodDistanceList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected LodDistanceList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public LodDistanceList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public LodDistanceList() {
         super( new org.xbig.base.InstancePointer(__createLodDistanceList()), false);
    }

    private native static long __createLodDistanceList();

    /** **/
    public void assign(int num, float val) {
        _assign__ivFR(this.object.pointer, num,  val);
    }

    private native void _assign__ivFR(long _pointer_, int num, float val);

    /** **/
    public FloatPointer at(int loc) {
         return new FloatPointer(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public FloatPointer back() {
         return new FloatPointer(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public FloatPointer front() {
         return new FloatPointer(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(float val) {
        _push_back__FR(this.object.pointer, val);
    }

    private native void _push_back__FR(long _pointer_, float val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
public static class VertexBoneAssignmentList extends org.xbig.base.NativeObject implements org.ogre4j.IMesh.IVertexBoneAssignmentList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public VertexBoneAssignmentList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected VertexBoneAssignmentList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public VertexBoneAssignmentList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public VertexBoneAssignmentList() {
         super( new org.xbig.base.InstancePointer(__createVertexBoneAssignmentList()), false);
    }

    private native static long __createVertexBoneAssignmentList();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(int key) {
         return _count__iR(this.object.pointer, key);
    }

    private native int _count__iR(long _pointer_, int key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(int key) {
         return _erase__iR(this.object.pointer, key);
    }

    private native int _erase__iR(long _pointer_, int key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

}
public static class BoneAssignmentIterator extends org.xbig.base.NativeObject implements org.ogre4j.IMesh.IBoneAssignmentIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public BoneAssignmentIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected BoneAssignmentIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public BoneAssignmentIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public BoneAssignmentIterator(org.ogre4j.IMesh.IVertexBoneAssignmentList c) {
         super( new org.xbig.base.InstancePointer(__createBoneAssignmentIterator__Ogre_Mesh_VertexBoneAssignmentListr( c.getInstancePointer().pointer)), false);
    }

    private native static long __createBoneAssignmentIterator__Ogre_Mesh_VertexBoneAssignmentListr(long c);

    /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public void getNext(org.ogre4j.IVertexBoneAssignment_s returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getNext(this.object.pointer)), false);
    }

    private native long _getNext(long _pointer_);

    /** **/
    public void peekNextValue(org.ogre4j.IVertexBoneAssignment_s returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_peekNextValue(this.object.pointer)), false);
    }

    private native long _peekNextValue(long _pointer_);

    /** **/
    public int peekNextKey() {
         return _peekNextKey(this.object.pointer);
    }

    private native int _peekNextKey(long _pointer_);

    /** **/
    public org.ogre4j.IMesh.IBoneAssignmentIterator operatorAssignment(org.ogre4j.IMesh.IBoneAssignmentIterator rhs) {
         return new org.ogre4j.Mesh.BoneAssignmentIterator(new InstancePointer(_operatorAssignment___Ogre_Mesh_BoneAssignmentIteratorr(this.object.pointer, rhs.getInstancePointer().pointer)));
    }

    private native long _operatorAssignment___Ogre_Mesh_BoneAssignmentIteratorr(long _pointer_, long rhs);

    /** **/
    public org.ogre4j.IVertexBoneAssignment_s peekNextValuePtr() {
         return new org.ogre4j.VertexBoneAssignment_s(new InstancePointer(_peekNextValuePtr(this.object.pointer)));
    }

    private native long _peekNextValuePtr(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext(this.object.pointer);
    }

    private native void _moveNext(long _pointer_);

}
public static class SubMeshList extends org.xbig.base.NativeObject implements org.ogre4j.IMesh.ISubMeshList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public SubMeshList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected SubMeshList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public SubMeshList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public SubMeshList() {
         super( new org.xbig.base.InstancePointer(__createSubMeshList()), false);
    }

    private native static long __createSubMeshList();

    /** **/
    public void assign(int num, org.ogre4j.ISubMesh val) {
        _assign__ivOgre_SubMeshP(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_SubMeshP(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.ISubMesh at(int loc) {
         return new org.ogre4j.SubMesh(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.ISubMesh back() {
         return new org.ogre4j.SubMesh(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.ISubMesh front() {
         return new org.ogre4j.SubMesh(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.ISubMesh val) {
        _push_back__Ogre_SubMeshP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_SubMeshP(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
public static class IndexMap extends org.xbig.base.NativeObject implements org.ogre4j.IMesh.IIndexMap {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public IndexMap(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected IndexMap(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public IndexMap(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public IndexMap() {
         super( new org.xbig.base.InstancePointer(__createIndexMap()), false);
    }

    private native static long __createIndexMap();

    /** **/
    public void assign(int num, int val) {
        _assign__ivHR(this.object.pointer, num,  val);
    }

    private native void _assign__ivHR(long _pointer_, int num, int val);

    /** **/
    public IntegerPointer at(int loc) {
         return new IntegerPointer(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public IntegerPointer back() {
         return new IntegerPointer(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public IntegerPointer front() {
         return new IntegerPointer(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(int val) {
        _push_back__HR(this.object.pointer, val);
    }

    private native void _push_back__HR(long _pointer_, int val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
public static class SubMeshNameMap extends org.xbig.base.NativeObject implements org.ogre4j.IMesh.ISubMeshNameMap {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public SubMeshNameMap(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected SubMeshNameMap(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public SubMeshNameMap(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public SubMeshNameMap() {
         super( new org.xbig.base.InstancePointer(__createSubMeshNameMap()), false);
    }

    private native static long __createSubMeshNameMap();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public IntegerPointer get(String key) {
         return new IntegerPointer(new InstancePointer(_get__sR(this.object.pointer, key)));
    }

    private native long _get__sR(long _pointer_, String key);

    /** **/
    public void insert(String key, IntegerPointer value) {
        _insert__sRHr(this.object.pointer, key,  value.object.pointer);
    }

    private native void _insert__sRHr(long _pointer_, String key, long value);

}
public static class SubMeshIterator extends org.xbig.base.NativeObject implements org.ogre4j.IMesh.ISubMeshIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public SubMeshIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected SubMeshIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public SubMeshIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public SubMeshIterator(org.ogre4j.IMesh.ISubMeshList c) {
         super( new org.xbig.base.InstancePointer(__createSubMeshIterator__Ogre_Mesh_SubMeshListr( c.getInstancePointer().pointer)), false);
    }

    private native static long __createSubMeshIterator__Ogre_Mesh_SubMeshListr(long c);

    /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public org.ogre4j.ISubMesh getNext() {
         return new org.ogre4j.SubMesh(new InstancePointer(_getNext(this.object.pointer)));
    }

    private native long _getNext(long _pointer_);

    /** **/
    public org.ogre4j.ISubMesh peekNext() {
         return new org.ogre4j.SubMesh(new InstancePointer(_peekNext(this.object.pointer)));
    }

    private native long _peekNext(long _pointer_);

    /** **/
    public NativeObjectPointer<org.ogre4j.ISubMesh> peekNextPtr() {
         return new NativeObjectPointer<org.ogre4j.ISubMesh>(new InstancePointer(_peekNextPtr(this.object.pointer)));
    }

    private native long _peekNextPtr(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext(this.object.pointer);
    }

    private native void _moveNext(long _pointer_);

}
public static class PoseIterator extends org.xbig.base.NativeObject implements org.ogre4j.IMesh.IPoseIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public PoseIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected PoseIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public PoseIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public PoseIterator(org.ogre4j.IPoseList c) {
         super( new org.xbig.base.InstancePointer(__createPoseIterator__Ogre_PoseListr( c.getInstancePointer().pointer)), false);
    }

    private native static long __createPoseIterator__Ogre_PoseListr(long c);

    /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public org.ogre4j.IPose getNext() {
         return new org.ogre4j.Pose(new InstancePointer(_getNext(this.object.pointer)));
    }

    private native long _getNext(long _pointer_);

    /** **/
    public org.ogre4j.IPose peekNext() {
         return new org.ogre4j.Pose(new InstancePointer(_peekNext(this.object.pointer)));
    }

    private native long _peekNext(long _pointer_);

    /** **/
    public NativeObjectPointer<org.ogre4j.IPose> peekNextPtr() {
         return new NativeObjectPointer<org.ogre4j.IPose>(new InstancePointer(_peekNextPtr(this.object.pointer)));
    }

    private native long _peekNextPtr(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext(this.object.pointer);
    }

    private native void _moveNext(long _pointer_);

}
public static class ConstPoseIterator extends org.xbig.base.NativeObject implements org.ogre4j.IMesh.IConstPoseIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public ConstPoseIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected ConstPoseIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public ConstPoseIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public ConstPoseIterator(org.ogre4j.IPoseList c) {
         super( new org.xbig.base.InstancePointer(__createConstPoseIterator__Ogre_PoseListR( c.getInstancePointer().pointer)), false);
    }

    private native static long __createConstPoseIterator__Ogre_PoseListR(long c);

    /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public org.ogre4j.IPose getNext() {
         return new org.ogre4j.Pose(new InstancePointer(_getNext(this.object.pointer)));
    }

    private native long _getNext(long _pointer_);

    /** **/
    public org.ogre4j.IPose peekNext() {
         return new org.ogre4j.Pose(new InstancePointer(_peekNext_const(this.object.pointer)));
    }

    private native long _peekNext_const(long _pointer_);

    /** **/
    public NativeObjectPointer<org.ogre4j.IPose> peekNextPtr() {
         return new NativeObjectPointer<org.ogre4j.IPose>(new InstancePointer(_peekNextPtr_const(this.object.pointer)));
    }

    private native long _peekNextPtr_const(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext_const(this.object.pointer);
    }

    private native void _moveNext_const(long _pointer_);

}
protected static class MeshLodUsageList extends org.xbig.base.NativeObject implements org.ogre4j.IMesh.IMeshLodUsageList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public MeshLodUsageList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected MeshLodUsageList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public MeshLodUsageList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public MeshLodUsageList() {
         super( new org.xbig.base.InstancePointer(__createMeshLodUsageList()), false);
    }

    private native static long __createMeshLodUsageList();

    /** **/
    public void assign(int num, org.ogre4j.IMeshLodUsage val) {
        _assign__ivOgre_MeshLodUsageR(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_MeshLodUsageR(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.IMeshLodUsage at(int loc) {
         return new org.ogre4j.MeshLodUsage(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.IMeshLodUsage back() {
         return new org.ogre4j.MeshLodUsage(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.IMeshLodUsage front() {
         return new org.ogre4j.MeshLodUsage(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.IMeshLodUsage val) {
        _push_back__Ogre_MeshLodUsageR(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_MeshLodUsageR(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
protected static class AnimationList extends org.xbig.base.NativeObject implements org.ogre4j.IMesh.IAnimationList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public AnimationList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected AnimationList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public AnimationList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public AnimationList() {
         super( new org.xbig.base.InstancePointer(__createAnimationList()), false);
    }

    private native static long __createAnimationList();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.IAnimation get(String key) {
         return new org.ogre4j.Animation(new InstancePointer(_get__sR(this.object.pointer, key)));
    }

    private native long _get__sR(long _pointer_, String key);

    /** **/
    public void insert(String key, org.ogre4j.IAnimation value) {
        _insert__sROgre_Animationp(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__sROgre_Animationp(long _pointer_, String key, long value);

}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public Mesh(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected Mesh(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public Mesh(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** 
    Default constructor - used by **/
    public Mesh(org.ogre4j.IResourceManager creator, String name, long handle, String group, boolean isManual, org.ogre4j.IManualResourceLoader loader) {
         super( new org.xbig.base.InstancePointer(__createMesh__ResourceManagerpStringRResourceHandlevStringRbvManualResourceLoaderp( creator.getInstancePointer().pointer,  name,  handle,  group,  isManual,  loader.getInstancePointer().pointer)), false);
    }

    private native static long __createMesh__ResourceManagerpStringRResourceHandlevStringRbvManualResourceLoaderp(long creator, String name, long handle, String group, boolean isManual, long loader);

    /** 
    Creates a new . **/
    public org.ogre4j.ISubMesh createSubMesh() {
         return new org.ogre4j.SubMesh(new InstancePointer(_createSubMesh(this.object.pointer)));
    }

    private native long _createSubMesh(long _pointer_);

    /** 
    Creates a new  and gives it a name **/
    public org.ogre4j.ISubMesh createSubMesh(String name) {
         return new org.ogre4j.SubMesh(new InstancePointer(_createSubMesh__StringR(this.object.pointer, name)));
    }

    private native long _createSubMesh__StringR(long _pointer_, String name);

    /** 
    Gives a name to a **/
    public void nameSubMesh(String name, int index) {
        _nameSubMesh__StringRushortv(this.object.pointer, name,  index);
    }

    private native void _nameSubMesh__StringRushortv(long _pointer_, String name, int index);

    /** 
    Gets the index of a submesh with a given name. **/
    public int _getSubMeshIndex(String name) {
         return __getSubMeshIndex__StringR_const(this.object.pointer, name);
    }

    private native int __getSubMeshIndex__StringR_const(long _pointer_, String name);

    /** 
    Gets the number of sub meshes which comprise this mesh. **/
    public int getNumSubMeshes() {
         return _getNumSubMeshes_const(this.object.pointer);
    }

    private native int _getNumSubMeshes_const(long _pointer_);

    /** 
    Gets a pointer to the submesh indicated by the index. **/
    public org.ogre4j.ISubMesh getSubMesh(int index) {
         return new org.ogre4j.SubMesh(new InstancePointer(_getSubMesh__Hv_const(this.object.pointer, index)));
    }

    private native long _getSubMesh__Hv_const(long _pointer_, int index);

    /** 
    Gets a  by name **/
    public org.ogre4j.ISubMesh getSubMesh(String name) {
         return new org.ogre4j.SubMesh(new InstancePointer(_getSubMesh__StringR_const(this.object.pointer, name)));
    }

    private native long _getSubMesh__StringR_const(long _pointer_, String name);

    /** **/
    public void getSubMeshIterator(org.ogre4j.IMesh.ISubMeshIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getSubMeshIterator(this.object.pointer)), false);
    }

    private native long _getSubMeshIterator(long _pointer_);

    /** 
    Makes a copy of this mesh object and gives it a new name. **/
    public void clone(org.ogre4j.IMeshPtr returnValue, String newName, String newGroup) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_clone__StringRStringR(this.object.pointer, newName,  newGroup)), false);
    }

    private native long _clone__StringRStringR(long _pointer_, String newName, String newGroup);

    /** 
    Get the axis-aligned bounding box for this mesh. **/
    public org.ogre4j.IAxisAlignedBox getBounds() {
         return new org.ogre4j.AxisAlignedBox(new InstancePointer(_getBounds_const(this.object.pointer)));
    }

    private native long _getBounds_const(long _pointer_);

    /** 
    Gets the radius of the bounding sphere surrounding this mesh. **/
    public float getBoundingSphereRadius() {
         return _getBoundingSphereRadius_const(this.object.pointer);
    }

    private native float _getBoundingSphereRadius_const(long _pointer_);

    /** 
    Manually set the bounding box for this . **/
    public void _setBounds(org.ogre4j.IAxisAlignedBox bounds, boolean pad) {
        __setBounds__AxisAlignedBoxRbv(this.object.pointer, bounds.getInstancePointer().pointer,  pad);
    }

    private native void __setBounds__AxisAlignedBoxRbv(long _pointer_, long bounds, boolean pad);

    /** 
    Manually set the bounding radius. **/
    public void _setBoundingSphereRadius(float radius) {
        __setBoundingSphereRadius__Realv(this.object.pointer, radius);
    }

    private native void __setBoundingSphereRadius__Realv(long _pointer_, float radius);

    /** 
    Sets the name of the skeleton this  uses for animation. **/
    public void setSkeletonName(String skelName) {
        _setSkeletonName__StringR(this.object.pointer, skelName);
    }

    private native void _setSkeletonName__StringR(long _pointer_, String skelName);

    /** 
    Returns true if this  has a linked . **/
    public boolean hasSkeleton() {
         return _hasSkeleton_const(this.object.pointer);
    }

    private native boolean _hasSkeleton_const(long _pointer_);

    /** 
    Returns whether or not this mesh has some kind of vertex animation. **/
    public boolean hasVertexAnimation() {
         return _hasVertexAnimation_const(this.object.pointer);
    }

    private native boolean _hasVertexAnimation_const(long _pointer_);

    /** 
    Gets a pointer to any linked . **/
    public org.ogre4j.ISkeletonPtr getSkeleton() {
         return new org.ogre4j.SkeletonPtr(new InstancePointer(_getSkeleton_const(this.object.pointer)));
    }

    private native long _getSkeleton_const(long _pointer_);

    /** 
    Gets the name of any linked **/
    public String getSkeletonName() {
         return _getSkeletonName_const(this.object.pointer);
    }

    private native String _getSkeletonName_const(long _pointer_);

    /** 
    Initialise an animation set suitable for use with this mesh. **/
    public void _initAnimationState(org.ogre4j.IAnimationStateSet animSet) {
        __initAnimationState__AnimationStateSetp(this.object.pointer, animSet.getInstancePointer().pointer);
    }

    private native void __initAnimationState__AnimationStateSetp(long _pointer_, long animSet);

    /** 
    Refresh an animation set suitable for use with this mesh. **/
    public void _refreshAnimationState(org.ogre4j.IAnimationStateSet animSet) {
        __refreshAnimationState__AnimationStateSetp(this.object.pointer, animSet.getInstancePointer().pointer);
    }

    private native void __refreshAnimationState__AnimationStateSetp(long _pointer_, long animSet);

    /** 
    Assigns a vertex to a bone with a given weight, for skeletal animation. **/
    public void addBoneAssignment(org.ogre4j.IVertexBoneAssignment_s vertBoneAssign) {
        _addBoneAssignment__VertexBoneAssignmentR(this.object.pointer, vertBoneAssign.getInstancePointer().pointer);
    }

    private native void _addBoneAssignment__VertexBoneAssignmentR(long _pointer_, long vertBoneAssign);

    /** 
    Removes all bone assignments for this mesh. **/
    public void clearBoneAssignments() {
        _clearBoneAssignments(this.object.pointer);
    }

    private native void _clearBoneAssignments(long _pointer_);

    /** 
    Internal notification, used to tell the  which  to use without loading it. **/
    public void _notifySkeleton(org.ogre4j.ISkeletonPtr pSkel) {
        __notifySkeleton__SkeletonPtrr(this.object.pointer, pSkel.getInstancePointer().pointer);
    }

    private native void __notifySkeleton__SkeletonPtrr(long _pointer_, long pSkel);

    /** 
    Gets an iterator for access all bone assignments. **/
    public void getBoneAssignmentIterator(org.ogre4j.IMesh.IBoneAssignmentIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getBoneAssignmentIterator(this.object.pointer)), false);
    }

    private native long _getBoneAssignmentIterator(long _pointer_);

    /** 
    Gets a const reference to the list of bone assignments **/
    public org.ogre4j.IMesh.IVertexBoneAssignmentList getBoneAssignments() {
         return new org.ogre4j.Mesh.VertexBoneAssignmentList(new InstancePointer(_getBoneAssignments_const(this.object.pointer)));
    }

    private native long _getBoneAssignments_const(long _pointer_);

    /** 
    Automatically generates lower level of detail versions of this mesh for use when a simpler version of the model is acceptable for rendering. **/
    public void generateLodLevels(org.ogre4j.IMesh.ILodDistanceList lodDistances, org.ogre4j.ProgressiveMesh.VertexReductionQuota reductionMethod, float reductionValue) {
        _generateLodLevels__LodDistanceListRProgressiveMesh_VertexReductionQuotavRealv(this.object.pointer, lodDistances.getInstancePointer().pointer,  reductionMethod.getValue(),  reductionValue);
    }

    private native void _generateLodLevels__LodDistanceListRProgressiveMesh_VertexReductionQuotavRealv(long _pointer_, long lodDistances, int reductionMethod, float reductionValue);

    /** 
    Returns the number of levels of detail that this mesh supports. **/
    public int getNumLodLevels() {
         return _getNumLodLevels_const(this.object.pointer);
    }

    private native int _getNumLodLevels_const(long _pointer_);

    /** 
    Gets details of the numbered level of detail entry. **/
    public org.ogre4j.IMeshLodUsage getLodLevel(int index) {
         return new org.ogre4j.MeshLodUsage(new InstancePointer(_getLodLevel__ushortv_const(this.object.pointer, index)));
    }

    private native long _getLodLevel__ushortv_const(long _pointer_, int index);

    /** 
    Adds a new manual level-of-detail entry to this . **/
    public void createManualLodLevel(float fromDepth, String meshName) {
        _createManualLodLevel__RealvStringR(this.object.pointer, fromDepth,  meshName);
    }

    private native void _createManualLodLevel__RealvStringR(long _pointer_, float fromDepth, String meshName);

    /** 
    Changes the alternate mesh to use as a manual LOD at the given index. **/
    public void updateManualLodLevel(int index, String meshName) {
        _updateManualLodLevel__ushortvStringR(this.object.pointer, index,  meshName);
    }

    private native void _updateManualLodLevel__ushortvStringR(long _pointer_, int index, String meshName);

    /** 
    Retrieves the level of detail index for the given depth value. **/
    public int getLodIndex(float depth) {
         return _getLodIndex__Realv_const(this.object.pointer, depth);
    }

    private native int _getLodIndex__Realv_const(long _pointer_, float depth);

    /** 
    Retrieves the level of detail index for the given squared depth value. **/
    public int getLodIndexSquaredDepth(float squaredDepth) {
         return _getLodIndexSquaredDepth__Realv_const(this.object.pointer, squaredDepth);
    }

    private native int _getLodIndexSquaredDepth__Realv_const(long _pointer_, float squaredDepth);

    /** 
    Returns true if this mesh is using manual LOD. **/
    public boolean isLodManual() {
         return _isLodManual_const(this.object.pointer);
    }

    private native boolean _isLodManual_const(long _pointer_);

    /** 
    Internal methods for loading LOD, do not use. **/
    public void _setLodInfo(int numLevels, boolean isManual) {
        __setLodInfo__Hvbv(this.object.pointer, numLevels,  isManual);
    }

    private native void __setLodInfo__Hvbv(long _pointer_, int numLevels, boolean isManual);

    /** 
    Internal methods for loading LOD, do not use. **/
    public void _setLodUsage(int level, org.ogre4j.IMeshLodUsage usage) {
        __setLodUsage__HvMeshLodUsager(this.object.pointer, level,  usage.getInstancePointer().pointer);
    }

    private native void __setLodUsage__HvMeshLodUsager(long _pointer_, int level, long usage);

    /** 
    Internal methods for loading LOD, do not use. **/
    public void _setSubMeshLodFaceList(int subIdx, int level, org.ogre4j.IIndexData facedata) {
        __setSubMeshLodFaceList__HvHvIndexDatap(this.object.pointer, subIdx,  level,  facedata.getInstancePointer().pointer);
    }

    private native void __setSubMeshLodFaceList__HvHvIndexDatap(long _pointer_, int subIdx, int level, long facedata);

    /** 
    Removes all LOD data from this . **/
    public void removeLodLevels() {
        _removeLodLevels(this.object.pointer);
    }

    private native void _removeLodLevels(long _pointer_);

    /** 
    Sets the policy for the vertex buffers to be used when loading this . **/
    public void setVertexBufferPolicy(org.ogre4j.HardwareBuffer.Usage usage, boolean shadowBuffer) {
        _setVertexBufferPolicy__HardwareBuffer_Usagevbv(this.object.pointer, usage.getValue(),  shadowBuffer);
    }

    private native void _setVertexBufferPolicy__HardwareBuffer_Usagevbv(long _pointer_, int usage, boolean shadowBuffer);

    /** 
    Sets the policy for the index buffers to be used when loading this . **/
    public void setIndexBufferPolicy(org.ogre4j.HardwareBuffer.Usage usage, boolean shadowBuffer) {
        _setIndexBufferPolicy__HardwareBuffer_Usagevbv(this.object.pointer, usage.getValue(),  shadowBuffer);
    }

    private native void _setIndexBufferPolicy__HardwareBuffer_Usagevbv(long _pointer_, int usage, boolean shadowBuffer);

    /** 
    Gets the usage setting for this meshes vertex buffers. **/
    public org.ogre4j.HardwareBuffer.Usage getVertexBufferUsage() {
         return org.ogre4j.HardwareBuffer.Usage.toEnum(_getVertexBufferUsage_const(this.object.pointer));
    }

    private native int _getVertexBufferUsage_const(long _pointer_);

    /** 
    Gets the usage setting for this meshes index buffers. **/
    public org.ogre4j.HardwareBuffer.Usage getIndexBufferUsage() {
         return org.ogre4j.HardwareBuffer.Usage.toEnum(_getIndexBufferUsage_const(this.object.pointer));
    }

    private native int _getIndexBufferUsage_const(long _pointer_);

    /** 
    Gets whether or not this meshes vertex buffers are shadowed. **/
    public boolean isVertexBufferShadowed() {
         return _isVertexBufferShadowed_const(this.object.pointer);
    }

    private native boolean _isVertexBufferShadowed_const(long _pointer_);

    /** 
    Gets whether or not this meshes index buffers are shadowed. **/
    public boolean isIndexBufferShadowed() {
         return _isIndexBufferShadowed_const(this.object.pointer);
    }

    private native boolean _isIndexBufferShadowed_const(long _pointer_);

    /** 
    Rationalises the passed in bone assignment list. **/
    public int _rationaliseBoneAssignments(int vertexCount, org.ogre4j.IMesh.IVertexBoneAssignmentList assignments) {
         return __rationaliseBoneAssignments__ivVertexBoneAssignmentListr(this.object.pointer, vertexCount,  assignments.getInstancePointer().pointer);
    }

    private native int __rationaliseBoneAssignments__ivVertexBoneAssignmentListr(long _pointer_, int vertexCount, long assignments);

    /** 
    Internal method, be called once to compile bone assignments into geometry buffer. **/
    public void _compileBoneAssignments() {
        __compileBoneAssignments(this.object.pointer);
    }

    private native void __compileBoneAssignments(long _pointer_);

    /** 
    Internal method, be called once to update the compiled bone assignments. **/
    public void _updateCompiledBoneAssignments() {
        __updateCompiledBoneAssignments(this.object.pointer);
    }

    private native void __updateCompiledBoneAssignments(long _pointer_);

    /** 
    This method builds a set of tangent vectors for a given mesh into a 3D texture coordinate buffer. **/
    public void buildTangentVectors(org.ogre4j.VertexElementSemantic targetSemantic, int sourceTexCoordSet, int index, boolean splitMirrored, boolean splitRotated, boolean storeParityInW) {
        _buildTangentVectors__VertexElementSemanticvHvHvbvbvbv(this.object.pointer, targetSemantic.getValue(),  sourceTexCoordSet,  index,  splitMirrored,  splitRotated,  storeParityInW);
    }

    private native void _buildTangentVectors__VertexElementSemanticvHvHvbvbvbv(long _pointer_, int targetSemantic, int sourceTexCoordSet, int index, boolean splitMirrored, boolean splitRotated, boolean storeParityInW);

    /** 
    Ask the mesh to suggest parameters to a future buildTangentVectors call, should you wish to use texture coordinates to store the tangents. **/
    public boolean suggestTangentVectorBuildParams(org.ogre4j.VertexElementSemantic targetSemantic, IntegerPointer outSourceCoordSet, IntegerPointer outIndex) {
         return _suggestTangentVectorBuildParams__VertexElementSemanticvHrHr(this.object.pointer, targetSemantic.getValue(),  outSourceCoordSet.object.pointer,  outIndex.object.pointer);
    }

    private native boolean _suggestTangentVectorBuildParams__VertexElementSemanticvHrHr(long _pointer_, int targetSemantic, long outSourceCoordSet, long outIndex);

    /** 
    Builds an edge list for this mesh, which can be used for generating a shadow volume among other things. **/
    public void buildEdgeList() {
        _buildEdgeList(this.object.pointer);
    }

    private native void _buildEdgeList(long _pointer_);

    /** 
    Destroys and frees the edge lists this mesh has built. **/
    public void freeEdgeList() {
        _freeEdgeList(this.object.pointer);
    }

    private native void _freeEdgeList(long _pointer_);

    /** 
    This method prepares the mesh for generating a renderable shadow volume. **/
    public void prepareForShadowVolume() {
        _prepareForShadowVolume(this.object.pointer);
    }

    private native void _prepareForShadowVolume(long _pointer_);

    /** 
    Return the edge list for this mesh, building it if required. **/
    public org.ogre4j.IEdgeData getEdgeList(long lodIndex) {
         return new org.ogre4j.EdgeData(new InstancePointer(_getEdgeList__Iv(this.object.pointer, lodIndex)));
    }

    private native long _getEdgeList__Iv(long _pointer_, long lodIndex);

    /** **/
    public org.ogre4j.IEdgeData getEdgeList_const(long lodIndex) {
         return new org.ogre4j.EdgeData(new InstancePointer(_getEdgeList_const__Iv_const(this.object.pointer, lodIndex)));
    }

    private native long _getEdgeList_const__Iv_const(long _pointer_, long lodIndex);

    /** 
    Returns whether this mesh has already had it's geometry prepared for use in rendering shadow volumes. **/
    public boolean isPreparedForShadowVolumes() {
         return _isPreparedForShadowVolumes_const(this.object.pointer);
    }

    private native boolean _isPreparedForShadowVolumes_const(long _pointer_);

    /** 
    Returns whether this mesh has an attached edge list. **/
    public boolean isEdgeListBuilt() {
         return _isEdgeListBuilt_const(this.object.pointer);
    }

    private native boolean _isEdgeListBuilt_const(long _pointer_);

    /** 
    Gets a reference to the optional name assignments of the SubMeshes. **/
    public org.ogre4j.IMesh.ISubMeshNameMap getSubMeshNameMap() {
         return new org.ogre4j.Mesh.SubMeshNameMap(new InstancePointer(_getSubMeshNameMap_const(this.object.pointer)));
    }

    private native long _getSubMeshNameMap_const(long _pointer_);

    /** 
    Sets whether or not this  should automatically build edge lists when asked for them, or whether it should never build them if they are not already provided. **/
    public void setAutoBuildEdgeLists(boolean autobuild) {
        _setAutoBuildEdgeLists__bv(this.object.pointer, autobuild);
    }

    private native void _setAutoBuildEdgeLists__bv(long _pointer_, boolean autobuild);

    /** 
    Sets whether or not this  should automatically build edge lists when asked for them, or whether it should never build them if they are not already provided. **/
    public boolean getAutoBuildEdgeLists() {
         return _getAutoBuildEdgeLists_const(this.object.pointer);
    }

    private native boolean _getAutoBuildEdgeLists_const(long _pointer_);

    /** 
    Gets the type of vertex animation the shared vertex data of this mesh supports. **/
    public org.ogre4j.VertexAnimationType getSharedVertexDataAnimationType() {
         return org.ogre4j.VertexAnimationType.toEnum(_getSharedVertexDataAnimationType_const(this.object.pointer));
    }

    private native int _getSharedVertexDataAnimationType_const(long _pointer_);

    /** 
    Creates a new  object for vertex animating this mesh. **/
    public org.ogre4j.IAnimation createAnimation(String name, float length) {
         return new org.ogre4j.Animation(new InstancePointer(_createAnimation__StringRRealv(this.object.pointer, name,  length)));
    }

    private native long _createAnimation__StringRRealv(long _pointer_, String name, float length);

    /** 
    Returns the named vertex  object. **/
    public org.ogre4j.IAnimation getAnimation(String name) {
         return new org.ogre4j.Animation(new InstancePointer(_getAnimation__StringR_const(this.object.pointer, name)));
    }

    private native long _getAnimation__StringR_const(long _pointer_, String name);

    /** 
    Internal access to the named vertex  object - returns null if it does not exist. **/
    public org.ogre4j.IAnimation _getAnimationImpl(String name) {
         return new org.ogre4j.Animation(new InstancePointer(__getAnimationImpl__StringR_const(this.object.pointer, name)));
    }

    private native long __getAnimationImpl__StringR_const(long _pointer_, String name);

    /** 
    Returns whether this mesh contains the named vertex animation. **/
    public boolean hasAnimation(String name) {
         return _hasAnimation__StringR(this.object.pointer, name);
    }

    private native boolean _hasAnimation__StringR(long _pointer_, String name);

    /** 
    Removes vertex  from this mesh. **/
    public void removeAnimation(String name) {
        _removeAnimation__StringR(this.object.pointer, name);
    }

    private native void _removeAnimation__StringR(long _pointer_, String name);

    /** 
    Gets the number of morph animations in this mesh. **/
    public int getNumAnimations() {
         return _getNumAnimations_const(this.object.pointer);
    }

    private native int _getNumAnimations_const(long _pointer_);

    /** 
    Gets a single morph animation by index. **/
    public org.ogre4j.IAnimation getAnimation(int index) {
         return new org.ogre4j.Animation(new InstancePointer(_getAnimation__Hv_const(this.object.pointer, index)));
    }

    private native long _getAnimation__Hv_const(long _pointer_, int index);

    /** 
    Removes all morph Animations from this mesh. **/
    public void removeAllAnimations() {
        _removeAllAnimations(this.object.pointer);
    }

    private native void _removeAllAnimations(long _pointer_);

    /** 
    Gets a pointer to a vertex data element based on a morph animation track handle. **/
    public org.ogre4j.IVertexData getVertexDataByTrackHandle(int handle) {
         return new org.ogre4j.VertexData(new InstancePointer(_getVertexDataByTrackHandle__Hv(this.object.pointer, handle)));
    }

    private native long _getVertexDataByTrackHandle__Hv(long _pointer_, int handle);

    /** 
    Iterates through all submeshes and requests them to apply their texture aliases to the material they use. **/
    public void updateMaterialForAllSubMeshes() {
        _updateMaterialForAllSubMeshes(this.object.pointer);
    }

    private native void _updateMaterialForAllSubMeshes(long _pointer_);

    /** 
    Internal method which, if animation types have not been determined, scans any vertex animations and determines the type for each set of vertex data (cannot have 2 different types). **/
    public void _determineAnimationTypes() {
        __determineAnimationTypes_const(this.object.pointer);
    }

    private native void __determineAnimationTypes_const(long _pointer_);

    /** 
    Are the derived animation types out of date? **/
    public boolean _getAnimationTypesDirty() {
         return __getAnimationTypesDirty_const(this.object.pointer);
    }

    private native boolean __getAnimationTypesDirty_const(long _pointer_);

    /** 
    Create a new  for this mesh or one of its submeshes. **/
    public org.ogre4j.IPose createPose(int target, String name) {
         return new org.ogre4j.Pose(new InstancePointer(_createPose__ushortvStringR(this.object.pointer, target,  name)));
    }

    private native long _createPose__ushortvStringR(long _pointer_, int target, String name);

    /** 
    Get the number of poses. **/
    public int getPoseCount() {
         return _getPoseCount_const(this.object.pointer);
    }

    private native int _getPoseCount_const(long _pointer_);

    /** 
    Retrieve an existing  by index. **/
    public org.ogre4j.IPose getPose(int index) {
         return new org.ogre4j.Pose(new InstancePointer(_getPose__ushortv(this.object.pointer, index)));
    }

    private native long _getPose__ushortv(long _pointer_, int index);

    /** 
    Retrieve an existing  by name. **/
    public org.ogre4j.IPose getPose(String name) {
         return new org.ogre4j.Pose(new InstancePointer(_getPose__StringR(this.object.pointer, name)));
    }

    private native long _getPose__StringR(long _pointer_, String name);

    /** 
    Destroy a pose by index. **/
    public void removePose(int index) {
        _removePose__ushortv(this.object.pointer, index);
    }

    private native void _removePose__ushortv(long _pointer_, int index);

    /** 
    Destroy a pose by name. **/
    public void removePose(String name) {
        _removePose__StringR(this.object.pointer, name);
    }

    private native void _removePose__StringR(long _pointer_, String name);

    /** 
    Destroy all poses **/
    public void removeAllPoses() {
        _removeAllPoses(this.object.pointer);
    }

    private native void _removeAllPoses(long _pointer_);

    /** 
    Get an iterator over all the poses defined. **/
    public void getPoseIterator(org.ogre4j.IMesh.IPoseIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getPoseIterator(this.object.pointer)), false);
    }

    private native long _getPoseIterator(long _pointer_);

    /** **/
    public void getPoseIterator_const(org.ogre4j.IMesh.IConstPoseIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getPoseIterator_const_const(this.object.pointer)), false);
    }

    private native long _getPoseIterator_const_const(long _pointer_);

    /** 
    Get pose list **/
    public org.ogre4j.IPoseList getPoseList() {
         return new org.ogre4j.PoseList(new InstancePointer(_getPoseList_const(this.object.pointer)));
    }

    private native long _getPoseList_const(long _pointer_);

    /** 
    Prepare matrices for software indexed vertex blend. **/
    public static void prepareMatricesForVertexBlend(NativeObjectPointer<org.ogre4j.IMatrix4> blendMatrices, org.ogre4j.IMatrix4 boneMatrices, org.ogre4j.IMesh.IIndexMap indexMap) {
        _prepareMatricesForVertexBlend__Matrix4PMatrix4PIndexMapR( blendMatrices.getInstancePointer().pointer,  boneMatrices.getInstancePointer().pointer,  indexMap.getInstancePointer().pointer);
    }

    private native static void _prepareMatricesForVertexBlend__Matrix4PMatrix4PIndexMapR(long blendMatrices, long boneMatrices, long indexMap);

    /** 
    Performs a software indexed vertex blend, of the kind used for skeletal animation although it can be used for other purposes. **/
    public static void softwareVertexBlend(org.ogre4j.IVertexData sourceVertexData, org.ogre4j.IVertexData targetVertexData, NativeObjectPointer<org.ogre4j.IMatrix4> blendMatrices, int numMatrices, boolean blendNormals) {
        _softwareVertexBlend__VertexDataPVertexDataPMatrix4Pivbv( sourceVertexData.getInstancePointer().pointer,  targetVertexData.getInstancePointer().pointer,  blendMatrices.getInstancePointer().pointer,  numMatrices,  blendNormals);
    }

    private native static void _softwareVertexBlend__VertexDataPVertexDataPMatrix4Pivbv(long sourceVertexData, long targetVertexData, long blendMatrices, int numMatrices, boolean blendNormals);

    /** 
    Performs a software vertex morph, of the kind used for morph animation although it can be used for other purposes. **/
    public static void softwareVertexMorph(float t, org.ogre4j.IHardwareVertexBufferSharedPtr b1, org.ogre4j.IHardwareVertexBufferSharedPtr b2, org.ogre4j.IVertexData targetVertexData) {
        _softwareVertexMorph__RealvHardwareVertexBufferSharedPtrRHardwareVertexBufferSharedPtrRVertexDatap( t,  b1.getInstancePointer().pointer,  b2.getInstancePointer().pointer,  targetVertexData.getInstancePointer().pointer);
    }

    private native static void _softwareVertexMorph__RealvHardwareVertexBufferSharedPtrRHardwareVertexBufferSharedPtrRVertexDatap(float t, long b1, long b2, long targetVertexData);

    /** 
    Performs a software vertex pose blend, of the kind used for morph animation although it can be used for other purposes. **/
    public static void softwareVertexPoseBlend(float weight, org.std.Imap< Integer, org.ogre4j.IVector3 > vertexOffsetMap, org.ogre4j.IVertexData targetVertexData) {
        _softwareVertexPoseBlend__Realvstd_map__size_t__Vector3__rVertexDatap( weight,  vertexOffsetMap.getInstancePointer().pointer,  targetVertexData.getInstancePointer().pointer);
    }

    private native static void _softwareVertexPoseBlend__Realvstd_map__size_t__Vector3__rVertexDatap(float weight, long vertexOffsetMap, long targetVertexData);

    /** 
    Prepares the resource for load, if it is not already. One can call  before , but this is not required as  will call  itself, if needed. When OGRE_THREAD_SUPPORT==1 both  and  are thread-safe. When OGRE_THREAD_SUPPORT==2 however, only  is thread-safe. The reason for this function is to allow a background thread to do some of the loading work, without requiring the whole render system to be thread-safe. The background thread would call  while the main render loop would later call . So long as  remains thread-safe, subclasses can arbitrarily split the work of loading a resource between  and . It is best to try and do as much work in , however, since this will leave less work for the main render thread to do and thus increase FPS. **/
    public void prepare() {
        _prepare(this.object.pointer);
    }

    private native void _prepare(long _pointer_);

    /** 
    Loads the resource, if it is not already. **/
    public void load(boolean backgroundThread) {
        _load__bv(this.object.pointer, backgroundThread);
    }

    private native void _load__bv(long _pointer_, boolean backgroundThread);

    /** 
    Reloads the resource, if it is already loaded. **/
    public void reload() {
        _reload(this.object.pointer);
    }

    private native void _reload(long _pointer_);

    /** 
    Returns true if the  is reloadable, false otherwise. **/
    public boolean isReloadable() {
         return _isReloadable_const(this.object.pointer);
    }

    private native boolean _isReloadable_const(long _pointer_);

    /** 
    Is this resource manually loaded? **/
    public boolean isManuallyLoaded() {
         return _isManuallyLoaded_const(this.object.pointer);
    }

    private native boolean _isManuallyLoaded_const(long _pointer_);

    /** 
    Unloads the resource; this is not permanent, the resource can be reloaded later if required. **/
    public void unload() {
        _unload(this.object.pointer);
    }

    private native void _unload(long _pointer_);

    /** 
    Retrieves info about the size of the resource. **/
    public int getSize() {
         return _getSize_const(this.object.pointer);
    }

    private native int _getSize_const(long _pointer_);

    /** 
    'Touches' the resource to indicate it has been used. **/
    public void touch() {
        _touch(this.object.pointer);
    }

    private native void _touch(long _pointer_);

    /** 
    Gets resource name. **/
    public String getName() {
         return _getName_const(this.object.pointer);
    }

    private native String _getName_const(long _pointer_);

    /** **/
    public long getHandle() {
         return _getHandle_const(this.object.pointer);
    }

    private native long _getHandle_const(long _pointer_);

    /** 
    Returns true if the  has been prepared, false otherwise. **/
    public boolean isPrepared() {
         return _isPrepared_const(this.object.pointer);
    }

    private native boolean _isPrepared_const(long _pointer_);

    /** 
    Returns true if the  has been loaded, false otherwise. **/
    public boolean isLoaded() {
         return _isLoaded_const(this.object.pointer);
    }

    private native boolean _isLoaded_const(long _pointer_);

    /** 
    Returns whether the resource is currently in the process of background loading. **/
    public boolean isLoading() {
         return _isLoading_const(this.object.pointer);
    }

    private native boolean _isLoading_const(long _pointer_);

    /** 
    Returns the current loading state. **/
    public org.ogre4j.Resource.LoadingState getLoadingState() {
         return org.ogre4j.Resource.LoadingState.toEnum(_getLoadingState_const(this.object.pointer));
    }

    private native int _getLoadingState_const(long _pointer_);

    /** 
    Returns whether this  has been earmarked for background loading. **/
    public boolean isBackgroundLoaded() {
         return _isBackgroundLoaded_const(this.object.pointer);
    }

    private native boolean _isBackgroundLoaded_const(long _pointer_);

    /** 
    Tells the resource whether it is background loaded or not. **/
    public void setBackgroundLoaded(boolean bl) {
        _setBackgroundLoaded__bv(this.object.pointer, bl);
    }

    private native void _setBackgroundLoaded__bv(long _pointer_, boolean bl);

    /** 
    Escalates the loading of a background loaded resource. **/
    public void escalateLoading() {
        _escalateLoading(this.object.pointer);
    }

    private native void _escalateLoading(long _pointer_);

    /** 
    Register a listener on this resource. **/
    public void addListener(org.ogre4j.IResource.IListener lis) {
        _addListener__Listenerp(this.object.pointer, lis.getInstancePointer().pointer);
    }

    private native void _addListener__Listenerp(long _pointer_, long lis);

    /** 
    Remove a listener on this resource. **/
    public void removeListener(org.ogre4j.IResource.IListener lis) {
        _removeListener__Listenerp(this.object.pointer, lis.getInstancePointer().pointer);
    }

    private native void _removeListener__Listenerp(long _pointer_, long lis);

    /** **/
    public String getGroup() {
         return _getGroup(this.object.pointer);
    }

    private native String _getGroup(long _pointer_);

    /** 
    Change the resource group ownership of a . **/
    public void changeGroupOwnership(String newGroup) {
        _changeGroupOwnership__StringR(this.object.pointer, newGroup);
    }

    private native void _changeGroupOwnership__StringR(long _pointer_, String newGroup);

    /** **/
    public org.ogre4j.IResourceManager getCreator() {
         return new org.ogre4j.ResourceManager(new InstancePointer(_getCreator(this.object.pointer)));
    }

    private native long _getCreator(long _pointer_);

    /** 
    Get the origin of this resource, e.g. a script file name. **/
    public String getOrigin() {
         return _getOrigin_const(this.object.pointer);
    }

    private native String _getOrigin_const(long _pointer_);

    /** **/
    public void _notifyOrigin(String origin) {
        __notifyOrigin__StringR(this.object.pointer, origin);
    }

    private native void __notifyOrigin__StringR(long _pointer_, String origin);

    /** 
    Returns the number of times this resource has changed state, which generally means the number of times it has been loaded. Objects that build derived data based on the resource can check this value against a copy they kept last time they built this derived data, in order to know whether it needs rebuilding. This is a nice way of monitoring changes without having a tightly-bound callback. **/
    public int getStateCount() {
         return _getStateCount_const(this.object.pointer);
    }

    private native int _getStateCount_const(long _pointer_);

    /** 
    Manually mark the state of this resource as having been changed. **/
    public void _dirtyState() {
        __dirtyState(this.object.pointer);
    }

    private native void __dirtyState(long _pointer_);

    /** 
    Firing of background loading complete event **/
    public void _fireBackgroundLoadingComplete() {
        __fireBackgroundLoadingComplete(this.object.pointer);
    }

    private native void __fireBackgroundLoadingComplete(long _pointer_);

    /** 
    Firing of background preparing complete event **/
    public void _fireBackgroundPreparingComplete() {
        __fireBackgroundPreparingComplete(this.object.pointer);
    }

    private native void __fireBackgroundPreparingComplete(long _pointer_);

    /** 
    Retrieves the parameter dictionary for this class. **/
    public org.ogre4j.IParamDictionary getParamDictionary() {
         return new org.ogre4j.ParamDictionary(new InstancePointer(_getParamDictionary(this.object.pointer)));
    }

    private native long _getParamDictionary(long _pointer_);

    /** **/
    public org.ogre4j.IParamDictionary getParamDictionary_const() {
         return new org.ogre4j.ParamDictionary(new InstancePointer(_getParamDictionary_const_const(this.object.pointer)));
    }

    private native long _getParamDictionary_const_const(long _pointer_);

    /** 
    Retrieves a list of parameters valid for this object. **/
    public org.ogre4j.IParameterList getParameters() {
         return new org.ogre4j.ParameterList(new InstancePointer(_getParameters_const(this.object.pointer)));
    }

    private native long _getParameters_const(long _pointer_);

    /** 
    Generic parameter setting method. **/
    public boolean setParameter(String name, String value) {
         return _setParameter__StringRStringR(this.object.pointer, name,  value);
    }

    private native boolean _setParameter__StringRStringR(long _pointer_, String name, String value);

    /** 
    Generic multiple parameter setting method. **/
    public void setParameterList(org.ogre4j.INameValuePairList paramList) {
        _setParameterList__NameValuePairListR(this.object.pointer, paramList.getInstancePointer().pointer);
    }

    private native void _setParameterList__NameValuePairListR(long _pointer_, long paramList);

    /** 
    Generic parameter retrieval method. **/
    public String getParameter(String name) {
         return _getParameter__StringR_const(this.object.pointer, name);
    }

    private native String _getParameter__StringR_const(long _pointer_, String name);

    /** 
    Method for copying this object's parameters to another object. **/
    public void copyParametersTo(org.ogre4j.IStringInterface dest) {
        _copyParametersTo__StringInterfacep_const(this.object.pointer, dest.getInstancePointer().pointer);
    }

    private native void _copyParametersTo__StringInterfacep_const(long _pointer_, long dest);

    /** 
    Cleans up the static 'msDictionary' required to reset , otherwise the containers are left with invalid pointers, which will lead to a crash as soon as one of the  implementers (e.g. ) initializes. **/
    public static void cleanupDictionary() {
        _cleanupDictionary();
    }

    private native static void _cleanupDictionary();

    /** **/
    public org.ogre4j.IVertexData getsharedVertexData() {
         return new org.ogre4j.VertexData(new InstancePointer(_getsharedVertexData(this.object.pointer)));
    }

    private native long _getsharedVertexData(long _pointer_);

    /** **/
    public void setsharedVertexData(org.ogre4j.IVertexData _jni_value_) {
        _setsharedVertexData(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setsharedVertexData(long _pointer_, long _jni_value_);

    /** **/
    public void getsharedBlendIndexToBoneIndexMap(org.ogre4j.IMesh.IIndexMap returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getsharedBlendIndexToBoneIndexMap(this.object.pointer)), false);
    }

    private native long _getsharedBlendIndexToBoneIndexMap(long _pointer_);

    /** **/
    public void setsharedBlendIndexToBoneIndexMap(org.ogre4j.IMesh.IIndexMap _jni_value_) {
        _setsharedBlendIndexToBoneIndexMap(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setsharedBlendIndexToBoneIndexMap(long _pointer_, long _jni_value_);

}
