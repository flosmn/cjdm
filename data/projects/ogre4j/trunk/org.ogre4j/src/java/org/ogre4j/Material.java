/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class Material extends org.xbig.base.NativeObject implements org.ogre4j.IMaterial {
static { System.loadLibrary("ogre4j");}
public static class LodDistanceList extends org.xbig.base.NativeObject implements org.ogre4j.IMaterial.ILodDistanceList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public LodDistanceList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected LodDistanceList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public LodDistanceList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public LodDistanceList() {
         super( new org.xbig.base.InstancePointer(__createLodDistanceList()), false);
    }

    private native static long __createLodDistanceList();

    /** **/
    public void assign(int num, float val) {
        _assign__ivFR(this.object.pointer, num,  val);
    }

    private native void _assign__ivFR(long _pointer_, int num, float val);

    /** **/
    public FloatPointer at(int loc) {
         return new FloatPointer(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public FloatPointer back() {
         return new FloatPointer(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public FloatPointer front() {
         return new FloatPointer(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(float val) {
        _push_back__FR(this.object.pointer, val);
    }

    private native void _push_back__FR(long _pointer_, float val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
public static class LodDistanceIterator extends org.xbig.base.NativeObject implements org.ogre4j.IMaterial.ILodDistanceIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public LodDistanceIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected LodDistanceIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public LodDistanceIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public LodDistanceIterator(org.ogre4j.IMaterial.ILodDistanceList c) {
         super( new org.xbig.base.InstancePointer(__createLodDistanceIterator__Ogre_Material_LodDistanceListR( c.getInstancePointer().pointer)), false);
    }

    private native static long __createLodDistanceIterator__Ogre_Material_LodDistanceListR(long c);

    /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public float getNext() {
         return _getNext(this.object.pointer);
    }

    private native float _getNext(long _pointer_);

    /** **/
    public float peekNext() {
         return _peekNext_const(this.object.pointer);
    }

    private native float _peekNext_const(long _pointer_);

    /** **/
    public FloatPointer peekNextPtr() {
         return new FloatPointer(new InstancePointer(_peekNextPtr_const(this.object.pointer)));
    }

    private native long _peekNextPtr_const(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext_const(this.object.pointer);
    }

    private native void _moveNext_const(long _pointer_);

}
public static class TechniqueIterator extends org.xbig.base.NativeObject implements org.ogre4j.IMaterial.ITechniqueIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public TechniqueIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected TechniqueIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public TechniqueIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public org.ogre4j.ITechnique getNext() {
         return new org.ogre4j.Technique(new InstancePointer(_getNext(this.object.pointer)));
    }

    private native long _getNext(long _pointer_);

    /** **/
    public org.ogre4j.ITechnique peekNext() {
         return new org.ogre4j.Technique(new InstancePointer(_peekNext(this.object.pointer)));
    }

    private native long _peekNext(long _pointer_);

    /** **/
    public NativeObjectPointer<org.ogre4j.ITechnique> peekNextPtr() {
         return new NativeObjectPointer<org.ogre4j.ITechnique>(new InstancePointer(_peekNextPtr(this.object.pointer)));
    }

    private native long _peekNextPtr(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext(this.object.pointer);
    }

    private native void _moveNext(long _pointer_);

}
protected static class Techniques extends org.xbig.base.NativeObject implements org.ogre4j.IMaterial.ITechniques {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public Techniques(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected Techniques(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public Techniques(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public Techniques() {
         super( new org.xbig.base.InstancePointer(__createTechniques()), false);
    }

    private native static long __createTechniques();

    /** **/
    public void assign(int num, org.ogre4j.ITechnique val) {
        _assign__ivOgre_TechniqueP(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_TechniqueP(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.ITechnique at(int loc) {
         return new org.ogre4j.Technique(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.ITechnique back() {
         return new org.ogre4j.Technique(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.ITechnique front() {
         return new org.ogre4j.Technique(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.ITechnique val) {
        _push_back__Ogre_TechniqueP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_TechniqueP(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
protected static class LodTechniques extends org.xbig.base.NativeObject implements org.ogre4j.IMaterial.ILodTechniques {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public LodTechniques(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected LodTechniques(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public LodTechniques(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public LodTechniques() {
         super( new org.xbig.base.InstancePointer(__createLodTechniques()), false);
    }

    private native static long __createLodTechniques();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(int key) {
         return _count__HR(this.object.pointer, key);
    }

    private native int _count__HR(long _pointer_, int key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(int key) {
         return _erase__HR(this.object.pointer, key);
    }

    private native int _erase__HR(long _pointer_, int key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.ITechnique get(int key) {
         return new org.ogre4j.Technique(new InstancePointer(_get__HR(this.object.pointer, key)));
    }

    private native long _get__HR(long _pointer_, int key);

    /** **/
    public void insert(int key, org.ogre4j.ITechnique value) {
        _insert__HROgre_Techniquep(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__HROgre_Techniquep(long _pointer_, int key, long value);

}
protected static class BestTechniquesBySchemeList extends org.xbig.base.NativeObject implements org.ogre4j.IMaterial.IBestTechniquesBySchemeList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public BestTechniquesBySchemeList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected BestTechniquesBySchemeList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public BestTechniquesBySchemeList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public BestTechniquesBySchemeList() {
         super( new org.xbig.base.InstancePointer(__createBestTechniquesBySchemeList()), false);
    }

    private native static long __createBestTechniquesBySchemeList();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(int key) {
         return _count__HR(this.object.pointer, key);
    }

    private native int _count__HR(long _pointer_, int key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(int key) {
         return _erase__HR(this.object.pointer, key);
    }

    private native int _erase__HR(long _pointer_, int key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.IMaterial.ILodTechniques get(int key) {
         return new org.ogre4j.Material.LodTechniques(new InstancePointer(_get__HR(this.object.pointer, key)));
    }

    private native long _get__HR(long _pointer_, int key);

    /** **/
    public void insert(int key, org.ogre4j.IMaterial.ILodTechniques value) {
        _insert__HROgre_Material_LodTechniquesp(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__HROgre_Material_LodTechniquesp(long _pointer_, int key, long value);

}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public Material(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected Material(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public Material(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** 
    Constructor - use resource manager's create method rather than this. **/
    public Material(org.ogre4j.IResourceManager creator, String name, long handle, String group, boolean isManual, org.ogre4j.IManualResourceLoader loader) {
         super( new org.xbig.base.InstancePointer(__createMaterial__ResourceManagerpStringRResourceHandlevStringRbvManualResourceLoaderp( creator.getInstancePointer().pointer,  name,  handle,  group,  isManual,  loader.getInstancePointer().pointer)), false);
    }

    private native static long __createMaterial__ResourceManagerpStringRResourceHandlevStringRbvManualResourceLoaderp(long creator, String name, long handle, String group, boolean isManual, long loader);

    /** 
    Assignment operator to allow easy copying between materials. **/
    public org.ogre4j.IMaterial operatorAssignment(org.ogre4j.IMaterial rhs) {
         return new org.ogre4j.Material(new InstancePointer(_operatorAssignment__MaterialR(this.object.pointer, rhs.getInstancePointer().pointer)));
    }

    private native long _operatorAssignment__MaterialR(long _pointer_, long rhs);

    /** 
    Determines if the material has any transparency with the rest of the scene (derived from whether any Techniques say they involve transparency). **/
    public boolean isTransparent() {
         return _isTransparent_const(this.object.pointer);
    }

    private native boolean _isTransparent_const(long _pointer_);

    /** 
    Sets whether objects using this material will receive shadows. **/
    public void setReceiveShadows(boolean enabled) {
        _setReceiveShadows__bv(this.object.pointer, enabled);
    }

    private native void _setReceiveShadows__bv(long _pointer_, boolean enabled);

    /** 
    Returns whether or not objects using this material will receive shadows. **/
    public boolean getReceiveShadows() {
         return _getReceiveShadows_const(this.object.pointer);
    }

    private native boolean _getReceiveShadows_const(long _pointer_);

    /** 
    Sets whether objects using this material be classified as opaque to the shadow caster system. **/
    public void setTransparencyCastsShadows(boolean enabled) {
        _setTransparencyCastsShadows__bv(this.object.pointer, enabled);
    }

    private native void _setTransparencyCastsShadows__bv(long _pointer_, boolean enabled);

    /** 
    Returns whether or not objects using this material be classified as opaque to the shadow caster system. **/
    public boolean getTransparencyCastsShadows() {
         return _getTransparencyCastsShadows_const(this.object.pointer);
    }

    private native boolean _getTransparencyCastsShadows_const(long _pointer_);

    /** 
    Creates a new  for this . **/
    public org.ogre4j.ITechnique createTechnique() {
         return new org.ogre4j.Technique(new InstancePointer(_createTechnique(this.object.pointer)));
    }

    private native long _createTechnique(long _pointer_);

    /** 
    Gets the indexed technique. **/
    public org.ogre4j.ITechnique getTechnique(int index) {
         return new org.ogre4j.Technique(new InstancePointer(_getTechnique__Hv(this.object.pointer, index)));
    }

    private native long _getTechnique__Hv(long _pointer_, int index);

    /** 
    searches for the named technique. Return 0 if technique with name is not found **/
    public org.ogre4j.ITechnique getTechnique(String name) {
         return new org.ogre4j.Technique(new InstancePointer(_getTechnique__StringR(this.object.pointer, name)));
    }

    private native long _getTechnique__StringR(long _pointer_, String name);

    /** 
    Retrieves the number of techniques. **/
    public int getNumTechniques() {
         return _getNumTechniques_const(this.object.pointer);
    }

    private native int _getNumTechniques_const(long _pointer_);

    /** 
    Removes the technique at the given index. **/
    public void removeTechnique(int index) {
        _removeTechnique__Hv(this.object.pointer, index);
    }

    private native void _removeTechnique__Hv(long _pointer_, int index);

    /** 
    Removes all the techniques in this . **/
    public void removeAllTechniques() {
        _removeAllTechniques(this.object.pointer);
    }

    private native void _removeAllTechniques(long _pointer_);

    /** 
    Get an iterator over the Techniques in this . **/
    public void getTechniqueIterator(org.ogre4j.IMaterial.ITechniqueIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getTechniqueIterator(this.object.pointer)), false);
    }

    private native long _getTechniqueIterator(long _pointer_);

    /** 
    Gets an iterator over all the Techniques which are supported by the current card. **/
    public void getSupportedTechniqueIterator(org.ogre4j.IMaterial.ITechniqueIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getSupportedTechniqueIterator(this.object.pointer)), false);
    }

    private native long _getSupportedTechniqueIterator(long _pointer_);

    /** 
    Gets the indexed supported technique. **/
    public org.ogre4j.ITechnique getSupportedTechnique(int index) {
         return new org.ogre4j.Technique(new InstancePointer(_getSupportedTechnique__Hv(this.object.pointer, index)));
    }

    private native long _getSupportedTechnique__Hv(long _pointer_, int index);

    /** 
    Retrieves the number of supported techniques. **/
    public int getNumSupportedTechniques() {
         return _getNumSupportedTechniques_const(this.object.pointer);
    }

    private native int _getNumSupportedTechniques_const(long _pointer_);

    /** 
    Gets a string explaining why any techniques are not supported. **/
    public String getUnsupportedTechniquesExplanation() {
         return _getUnsupportedTechniquesExplanation_const(this.object.pointer);
    }

    private native String _getUnsupportedTechniquesExplanation_const(long _pointer_);

    /** 
    Gets the number of levels-of-detail this material has in the given scheme, based on . **/
    public int getNumLodLevels(int schemeIndex) {
         return _getNumLodLevels__Hv_const(this.object.pointer, schemeIndex);
    }

    private native int _getNumLodLevels__Hv_const(long _pointer_, int schemeIndex);

    /** 
    Gets the number of levels-of-detail this material has in the given scheme, based on . **/
    public int getNumLodLevels(String schemeName) {
         return _getNumLodLevels__StringR_const(this.object.pointer, schemeName);
    }

    private native int _getNumLodLevels__StringR_const(long _pointer_, String schemeName);

    /** 
    Gets the best supported technique. **/
    public org.ogre4j.ITechnique getBestTechnique(int lodIndex, org.ogre4j.IRenderable rend) {
         return new org.ogre4j.Technique(new InstancePointer(_getBestTechnique__HvRenderableP(this.object.pointer, lodIndex,  rend.getInstancePointer().pointer)));
    }

    private native long _getBestTechnique__HvRenderableP(long _pointer_, int lodIndex, long rend);

    /** 
    Creates a new copy of this material with the same settings but a new name. **/
    public void clone(org.ogre4j.IMaterialPtr returnValue, String newName, boolean changeGroup, String newGroup) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_clone__StringRbvStringR_const(this.object.pointer, newName,  changeGroup,  newGroup)), false);
    }

    private native long _clone__StringRbvStringR_const(long _pointer_, String newName, boolean changeGroup, String newGroup);

    /** 
    Copies the details of this material into another, preserving the target's handle and name (unlike operator=) but copying everything else. **/
    public void copyDetailsTo(org.ogre4j.IMaterialPtr mat) {
        _copyDetailsTo__MaterialPtrr_const(this.object.pointer, mat.getInstancePointer().pointer);
    }

    private native void _copyDetailsTo__MaterialPtrr_const(long _pointer_, long mat);

    /** 
    'Compiles' this . **/
    public void compile(boolean autoManageTextureUnits) {
        _compile__bv(this.object.pointer, autoManageTextureUnits);
    }

    private native void _compile__bv(long _pointer_, boolean autoManageTextureUnits);

    /** 
    Sets the point size properties for every  in every . **/
    public void setPointSize(float ps) {
        _setPointSize__Realv(this.object.pointer, ps);
    }

    private native void _setPointSize__Realv(long _pointer_, float ps);

    /** 
    Sets the ambient colour reflectance properties for every  in every . **/
    public void setAmbient(float red, float green, float blue) {
        _setAmbient__RealvRealvRealv(this.object.pointer, red,  green,  blue);
    }

    private native void _setAmbient__RealvRealvRealv(long _pointer_, float red, float green, float blue);

    /** 
    Sets the ambient colour reflectance properties for every  in every . **/
    public void setAmbient(org.ogre4j.IColourValue ambient) {
        _setAmbient__ColourValueR(this.object.pointer, ambient.getInstancePointer().pointer);
    }

    private native void _setAmbient__ColourValueR(long _pointer_, long ambient);

    /** 
    Sets the diffuse colour reflectance properties of every  in every . **/
    public void setDiffuse(float red, float green, float blue, float alpha) {
        _setDiffuse__RealvRealvRealvRealv(this.object.pointer, red,  green,  blue,  alpha);
    }

    private native void _setDiffuse__RealvRealvRealvRealv(long _pointer_, float red, float green, float blue, float alpha);

    /** 
    Sets the diffuse colour reflectance properties of every  in every . **/
    public void setDiffuse(org.ogre4j.IColourValue diffuse) {
        _setDiffuse__ColourValueR(this.object.pointer, diffuse.getInstancePointer().pointer);
    }

    private native void _setDiffuse__ColourValueR(long _pointer_, long diffuse);

    /** 
    Sets the specular colour reflectance properties of every  in every . **/
    public void setSpecular(float red, float green, float blue, float alpha) {
        _setSpecular__RealvRealvRealvRealv(this.object.pointer, red,  green,  blue,  alpha);
    }

    private native void _setSpecular__RealvRealvRealvRealv(long _pointer_, float red, float green, float blue, float alpha);

    /** 
    Sets the specular colour reflectance properties of every  in every . **/
    public void setSpecular(org.ogre4j.IColourValue specular) {
        _setSpecular__ColourValueR(this.object.pointer, specular.getInstancePointer().pointer);
    }

    private native void _setSpecular__ColourValueR(long _pointer_, long specular);

    /** 
    Sets the shininess properties of every  in every . **/
    public void setShininess(float val) {
        _setShininess__Realv(this.object.pointer, val);
    }

    private native void _setShininess__Realv(long _pointer_, float val);

    /** 
    Sets the amount of self-illumination of every  in every . **/
    public void setSelfIllumination(float red, float green, float blue) {
        _setSelfIllumination__RealvRealvRealv(this.object.pointer, red,  green,  blue);
    }

    private native void _setSelfIllumination__RealvRealvRealv(long _pointer_, float red, float green, float blue);

    /** 
    Sets the amount of self-illumination of every  in every . **/
    public void setSelfIllumination(org.ogre4j.IColourValue selfIllum) {
        _setSelfIllumination__ColourValueR(this.object.pointer, selfIllum.getInstancePointer().pointer);
    }

    private native void _setSelfIllumination__ColourValueR(long _pointer_, long selfIllum);

    /** 
    Sets whether or not each  renders with depth-buffer checking on or not. **/
    public void setDepthCheckEnabled(boolean enabled) {
        _setDepthCheckEnabled__bv(this.object.pointer, enabled);
    }

    private native void _setDepthCheckEnabled__bv(long _pointer_, boolean enabled);

    /** 
    Sets whether or not each  renders with depth-buffer writing on or not. **/
    public void setDepthWriteEnabled(boolean enabled) {
        _setDepthWriteEnabled__bv(this.object.pointer, enabled);
    }

    private native void _setDepthWriteEnabled__bv(long _pointer_, boolean enabled);

    /** 
    Sets the function used to compare depth values when depth checking is on. **/
    public void setDepthFunction(org.ogre4j.CompareFunction func) {
        _setDepthFunction__CompareFunctionv(this.object.pointer, func.getValue());
    }

    private native void _setDepthFunction__CompareFunctionv(long _pointer_, int func);

    /** 
    Sets whether or not colour buffer writing is enabled for each . **/
    public void setColourWriteEnabled(boolean enabled) {
        _setColourWriteEnabled__bv(this.object.pointer, enabled);
    }

    private native void _setColourWriteEnabled__bv(long _pointer_, boolean enabled);

    /** 
    Sets the culling mode for each pass based on the 'vertex winding'. **/
    public void setCullingMode(org.ogre4j.CullingMode mode) {
        _setCullingMode__CullingModev(this.object.pointer, mode.getValue());
    }

    private native void _setCullingMode__CullingModev(long _pointer_, int mode);

    /** 
    Sets the manual culling mode, performed by CPU rather than hardware. **/
    public void setManualCullingMode(org.ogre4j.ManualCullingMode mode) {
        _setManualCullingMode__ManualCullingModev(this.object.pointer, mode.getValue());
    }

    private native void _setManualCullingMode__ManualCullingModev(long _pointer_, int mode);

    /** 
    Sets whether or not dynamic lighting is enabled for every . **/
    public void setLightingEnabled(boolean enabled) {
        _setLightingEnabled__bv(this.object.pointer, enabled);
    }

    private native void _setLightingEnabled__bv(long _pointer_, boolean enabled);

    /** 
    Sets the type of light shading required **/
    public void setShadingMode(org.ogre4j.ShadeOptions mode) {
        _setShadingMode__ShadeOptionsv(this.object.pointer, mode.getValue());
    }

    private native void _setShadingMode__ShadeOptionsv(long _pointer_, int mode);

    /** 
    Sets the fogging mode applied to each pass. **/
    public void setFog(boolean overrideScene, org.ogre4j.FogMode mode, org.ogre4j.IColourValue colour, float expDensity, float linearStart, float linearEnd) {
        _setFog__bvFogModevColourValueRRealvRealvRealv(this.object.pointer, overrideScene,  mode.getValue(),  colour.getInstancePointer().pointer,  expDensity,  linearStart,  linearEnd);
    }

    private native void _setFog__bvFogModevColourValueRRealvRealvRealv(long _pointer_, boolean overrideScene, int mode, long colour, float expDensity, float linearStart, float linearEnd);

    /** 
    Sets the depth bias to be used for each . **/
    public void setDepthBias(float constantBias, float slopeScaleBias) {
        _setDepthBias__FvFv(this.object.pointer, constantBias,  slopeScaleBias);
    }

    private native void _setDepthBias__FvFv(long _pointer_, float constantBias, float slopeScaleBias);

    /** 
    Set texture filtering for every texture unit in every  and **/
    public void setTextureFiltering(org.ogre4j.TextureFilterOptions filterType) {
        _setTextureFiltering__TextureFilterOptionsv(this.object.pointer, filterType.getValue());
    }

    private native void _setTextureFiltering__TextureFilterOptionsv(long _pointer_, int filterType);

    /** 
    Sets the anisotropy level to be used for all textures. **/
    public void setTextureAnisotropy(int maxAniso) {
        _setTextureAnisotropy__iv(this.object.pointer, maxAniso);
    }

    private native void _setTextureAnisotropy__iv(long _pointer_, int maxAniso);

    /** 
    Sets the kind of blending every pass has with the existing contents of the scene. **/
    public void setSceneBlending(org.ogre4j.SceneBlendType sbt) {
        _setSceneBlending__SceneBlendTypeV(this.object.pointer, sbt.getValue());
    }

    private native void _setSceneBlending__SceneBlendTypeV(long _pointer_, int sbt);

    /** 
    Sets the kind of blending every pass has with the existing contents of the scene, using individual factors for color and alpha channels **/
    public void setSeparateSceneBlending(org.ogre4j.SceneBlendType sbt, org.ogre4j.SceneBlendType sbta) {
        _setSeparateSceneBlending__SceneBlendTypeVSceneBlendTypeV(this.object.pointer, sbt.getValue(),  sbta.getValue());
    }

    private native void _setSeparateSceneBlending__SceneBlendTypeVSceneBlendTypeV(long _pointer_, int sbt, int sbta);

    /** 
    Allows very fine control of blending every  with the existing contents of the scene. **/
    public void setSceneBlending(org.ogre4j.SceneBlendFactor sourceFactor, org.ogre4j.SceneBlendFactor destFactor) {
        _setSceneBlending__SceneBlendFactorVSceneBlendFactorV(this.object.pointer, sourceFactor.getValue(),  destFactor.getValue());
    }

    private native void _setSceneBlending__SceneBlendFactorVSceneBlendFactorV(long _pointer_, int sourceFactor, int destFactor);

    /** 
    Allows very fine control of blending every  with the existing contents of the scene, using individual factors for color and alpha channels **/
    public void setSeparateSceneBlending(org.ogre4j.SceneBlendFactor sourceFactor, org.ogre4j.SceneBlendFactor destFactor, org.ogre4j.SceneBlendFactor sourceFactorAlpha, org.ogre4j.SceneBlendFactor destFactorAlpha) {
        _setSeparateSceneBlending__SceneBlendFactorVSceneBlendFactorVSceneBlendFactorVSceneBlendFactorV(this.object.pointer, sourceFactor.getValue(),  destFactor.getValue(),  sourceFactorAlpha.getValue(),  destFactorAlpha.getValue());
    }

    private native void _setSeparateSceneBlending__SceneBlendFactorVSceneBlendFactorVSceneBlendFactorVSceneBlendFactorV(long _pointer_, int sourceFactor, int destFactor, int sourceFactorAlpha, int destFactorAlpha);

    /** 
    Tells the material that it needs recompilation. **/
    public void _notifyNeedsRecompile() {
        __notifyNeedsRecompile(this.object.pointer);
    }

    private native void __notifyNeedsRecompile(long _pointer_);

    /** 
    Sets the distance at which level-of-detail (LOD) levels come into effect. **/
    public void setLodLevels(org.ogre4j.IMaterial.ILodDistanceList lodDistances) {
        _setLodLevels__LodDistanceListR(this.object.pointer, lodDistances.getInstancePointer().pointer);
    }

    private native void _setLodLevels__LodDistanceListR(long _pointer_, long lodDistances);

    /** 
    Gets an iterator over the list of distances at which each LOD comes into effect. **/
    public void getLodDistanceIterator(org.ogre4j.IMaterial.ILodDistanceIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getLodDistanceIterator_const(this.object.pointer)), false);
    }

    private native long _getLodDistanceIterator_const(long _pointer_);

    /** 
    Gets the LOD index to use at the given distance. **/
    public int getLodIndex(float d) {
         return _getLodIndex__Realv_const(this.object.pointer, d);
    }

    private native int _getLodIndex__Realv_const(long _pointer_, float d);

    /** 
    Gets the LOD index to use at the given squared distance. **/
    public int getLodIndexSquaredDepth(float squaredDepth) {
         return _getLodIndexSquaredDepth__Realv_const(this.object.pointer, squaredDepth);
    }

    private native int _getLodIndexSquaredDepth__Realv_const(long _pointer_, float squaredDepth);

    /** 
    **/
    public void touch() {
        _touch(this.object.pointer);
    }

    private native void _touch(long _pointer_);

    /** 
    Applies texture names to  Unit State with matching texture name aliases. All techniques, passes, and  Unit States within the material are checked. If matching texture aliases are found then true is returned.
    **/
    public boolean applyTextureAliases(org.ogre4j.IAliasTextureNamePairList aliasList, boolean apply) {
         return _applyTextureAliases__AliasTextureNamePairListRbV_const(this.object.pointer, aliasList.getInstancePointer().pointer,  apply);
    }

    private native boolean _applyTextureAliases__AliasTextureNamePairListRbV_const(long _pointer_, long aliasList, boolean apply);

    /** 
    Gets the compilation status of the material. **/
    public boolean getCompilationRequired() {
         return _getCompilationRequired_const(this.object.pointer);
    }

    private native boolean _getCompilationRequired_const(long _pointer_);

    /** 
    Prepares the resource for load, if it is not already. One can call  before , but this is not required as  will call  itself, if needed. When OGRE_THREAD_SUPPORT==1 both  and  are thread-safe. When OGRE_THREAD_SUPPORT==2 however, only  is thread-safe. The reason for this function is to allow a background thread to do some of the loading work, without requiring the whole render system to be thread-safe. The background thread would call  while the main render loop would later call . So long as  remains thread-safe, subclasses can arbitrarily split the work of loading a resource between  and . It is best to try and do as much work in , however, since this will leave less work for the main render thread to do and thus increase FPS. **/
    public void prepare() {
        _prepare(this.object.pointer);
    }

    private native void _prepare(long _pointer_);

    /** 
    Loads the resource, if it is not already. **/
    public void load(boolean backgroundThread) {
        _load__bv(this.object.pointer, backgroundThread);
    }

    private native void _load__bv(long _pointer_, boolean backgroundThread);

    /** 
    Reloads the resource, if it is already loaded. **/
    public void reload() {
        _reload(this.object.pointer);
    }

    private native void _reload(long _pointer_);

    /** 
    Returns true if the  is reloadable, false otherwise. **/
    public boolean isReloadable() {
         return _isReloadable_const(this.object.pointer);
    }

    private native boolean _isReloadable_const(long _pointer_);

    /** 
    Is this resource manually loaded? **/
    public boolean isManuallyLoaded() {
         return _isManuallyLoaded_const(this.object.pointer);
    }

    private native boolean _isManuallyLoaded_const(long _pointer_);

    /** 
    Unloads the resource; this is not permanent, the resource can be reloaded later if required. **/
    public void unload() {
        _unload(this.object.pointer);
    }

    private native void _unload(long _pointer_);

    /** 
    Retrieves info about the size of the resource. **/
    public int getSize() {
         return _getSize_const(this.object.pointer);
    }

    private native int _getSize_const(long _pointer_);

    /** 
    Gets resource name. **/
    public String getName() {
         return _getName_const(this.object.pointer);
    }

    private native String _getName_const(long _pointer_);

    /** **/
    public long getHandle() {
         return _getHandle_const(this.object.pointer);
    }

    private native long _getHandle_const(long _pointer_);

    /** 
    Returns true if the  has been prepared, false otherwise. **/
    public boolean isPrepared() {
         return _isPrepared_const(this.object.pointer);
    }

    private native boolean _isPrepared_const(long _pointer_);

    /** 
    Returns true if the  has been loaded, false otherwise. **/
    public boolean isLoaded() {
         return _isLoaded_const(this.object.pointer);
    }

    private native boolean _isLoaded_const(long _pointer_);

    /** 
    Returns whether the resource is currently in the process of background loading. **/
    public boolean isLoading() {
         return _isLoading_const(this.object.pointer);
    }

    private native boolean _isLoading_const(long _pointer_);

    /** 
    Returns the current loading state. **/
    public org.ogre4j.Resource.LoadingState getLoadingState() {
         return org.ogre4j.Resource.LoadingState.toEnum(_getLoadingState_const(this.object.pointer));
    }

    private native int _getLoadingState_const(long _pointer_);

    /** 
    Returns whether this  has been earmarked for background loading. **/
    public boolean isBackgroundLoaded() {
         return _isBackgroundLoaded_const(this.object.pointer);
    }

    private native boolean _isBackgroundLoaded_const(long _pointer_);

    /** 
    Tells the resource whether it is background loaded or not. **/
    public void setBackgroundLoaded(boolean bl) {
        _setBackgroundLoaded__bv(this.object.pointer, bl);
    }

    private native void _setBackgroundLoaded__bv(long _pointer_, boolean bl);

    /** 
    Escalates the loading of a background loaded resource. **/
    public void escalateLoading() {
        _escalateLoading(this.object.pointer);
    }

    private native void _escalateLoading(long _pointer_);

    /** 
    Register a listener on this resource. **/
    public void addListener(org.ogre4j.IResource.IListener lis) {
        _addListener__Listenerp(this.object.pointer, lis.getInstancePointer().pointer);
    }

    private native void _addListener__Listenerp(long _pointer_, long lis);

    /** 
    Remove a listener on this resource. **/
    public void removeListener(org.ogre4j.IResource.IListener lis) {
        _removeListener__Listenerp(this.object.pointer, lis.getInstancePointer().pointer);
    }

    private native void _removeListener__Listenerp(long _pointer_, long lis);

    /** **/
    public String getGroup() {
         return _getGroup(this.object.pointer);
    }

    private native String _getGroup(long _pointer_);

    /** 
    Change the resource group ownership of a . **/
    public void changeGroupOwnership(String newGroup) {
        _changeGroupOwnership__StringR(this.object.pointer, newGroup);
    }

    private native void _changeGroupOwnership__StringR(long _pointer_, String newGroup);

    /** **/
    public org.ogre4j.IResourceManager getCreator() {
         return new org.ogre4j.ResourceManager(new InstancePointer(_getCreator(this.object.pointer)));
    }

    private native long _getCreator(long _pointer_);

    /** 
    Get the origin of this resource, e.g. a script file name. **/
    public String getOrigin() {
         return _getOrigin_const(this.object.pointer);
    }

    private native String _getOrigin_const(long _pointer_);

    /** **/
    public void _notifyOrigin(String origin) {
        __notifyOrigin__StringR(this.object.pointer, origin);
    }

    private native void __notifyOrigin__StringR(long _pointer_, String origin);

    /** 
    Returns the number of times this resource has changed state, which generally means the number of times it has been loaded. Objects that build derived data based on the resource can check this value against a copy they kept last time they built this derived data, in order to know whether it needs rebuilding. This is a nice way of monitoring changes without having a tightly-bound callback. **/
    public int getStateCount() {
         return _getStateCount_const(this.object.pointer);
    }

    private native int _getStateCount_const(long _pointer_);

    /** 
    Manually mark the state of this resource as having been changed. **/
    public void _dirtyState() {
        __dirtyState(this.object.pointer);
    }

    private native void __dirtyState(long _pointer_);

    /** 
    Firing of background loading complete event **/
    public void _fireBackgroundLoadingComplete() {
        __fireBackgroundLoadingComplete(this.object.pointer);
    }

    private native void __fireBackgroundLoadingComplete(long _pointer_);

    /** 
    Firing of background preparing complete event **/
    public void _fireBackgroundPreparingComplete() {
        __fireBackgroundPreparingComplete(this.object.pointer);
    }

    private native void __fireBackgroundPreparingComplete(long _pointer_);

    /** 
    Retrieves the parameter dictionary for this class. **/
    public org.ogre4j.IParamDictionary getParamDictionary() {
         return new org.ogre4j.ParamDictionary(new InstancePointer(_getParamDictionary(this.object.pointer)));
    }

    private native long _getParamDictionary(long _pointer_);

    /** **/
    public org.ogre4j.IParamDictionary getParamDictionary_const() {
         return new org.ogre4j.ParamDictionary(new InstancePointer(_getParamDictionary_const_const(this.object.pointer)));
    }

    private native long _getParamDictionary_const_const(long _pointer_);

    /** 
    Retrieves a list of parameters valid for this object. **/
    public org.ogre4j.IParameterList getParameters() {
         return new org.ogre4j.ParameterList(new InstancePointer(_getParameters_const(this.object.pointer)));
    }

    private native long _getParameters_const(long _pointer_);

    /** 
    Generic parameter setting method. **/
    public boolean setParameter(String name, String value) {
         return _setParameter__StringRStringR(this.object.pointer, name,  value);
    }

    private native boolean _setParameter__StringRStringR(long _pointer_, String name, String value);

    /** 
    Generic multiple parameter setting method. **/
    public void setParameterList(org.ogre4j.INameValuePairList paramList) {
        _setParameterList__NameValuePairListR(this.object.pointer, paramList.getInstancePointer().pointer);
    }

    private native void _setParameterList__NameValuePairListR(long _pointer_, long paramList);

    /** 
    Generic parameter retrieval method. **/
    public String getParameter(String name) {
         return _getParameter__StringR_const(this.object.pointer, name);
    }

    private native String _getParameter__StringR_const(long _pointer_, String name);

    /** 
    Method for copying this object's parameters to another object. **/
    public void copyParametersTo(org.ogre4j.IStringInterface dest) {
        _copyParametersTo__StringInterfacep_const(this.object.pointer, dest.getInstancePointer().pointer);
    }

    private native void _copyParametersTo__StringInterfacep_const(long _pointer_, long dest);

    /** 
    Cleans up the static 'msDictionary' required to reset , otherwise the containers are left with invalid pointers, which will lead to a crash as soon as one of the  implementers (e.g. ) initializes. **/
    public static void cleanupDictionary() {
        _cleanupDictionary();
    }

    private native static void _cleanupDictionary();

}
