/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public interface IPass extends INativeObject, org.ogre4j.IResourceAllocatedObject {

public static interface IHashFunc extends INativeObject {

    /** **/
    public long operatorFunctionCall(org.ogre4j.IPass p);

}
public interface IPassSet extends INativeObject, org.std.Iset< org.ogre4j.IPass > {

    /** **/
    public void clear();

    /** **/
    public int count(org.ogre4j.IPass key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(org.ogre4j.IPass key);

    /** **/
    public int max_size();

    /** **/
    public int size();

}
public interface ITextureUnitStateIterator extends INativeObject, org.ogre4j.IVectorIterator< org.ogre4j.IPass.ITextureUnitStates > {

    /** **/
    public boolean hasMoreElements();

    /** **/
    public org.ogre4j.ITextureUnitState getNext();

    /** **/
    public org.ogre4j.ITextureUnitState peekNext();

    /** **/
    public NativeObjectPointer<org.ogre4j.ITextureUnitState> peekNextPtr();

    /** **/
    public void moveNext();

}
public interface IConstTextureUnitStateIterator extends INativeObject, org.ogre4j.IConstVectorIterator< org.ogre4j.IPass.ITextureUnitStates > {

    /** **/
    public boolean hasMoreElements();

    /** **/
    public org.ogre4j.ITextureUnitState getNext();

    /** **/
    public org.ogre4j.ITextureUnitState peekNext();

    /** **/
    public NativeObjectPointer<org.ogre4j.ITextureUnitState> peekNextPtr();

    /** **/
    public void moveNext();

}
public interface ITextureUnitStates extends INativeObject, org.std.Ivector< org.ogre4j.ITextureUnitState > {

    /** **/
    public void assign(int num, org.ogre4j.ITextureUnitState val);

    /** **/
    public org.ogre4j.ITextureUnitState at(int loc);

    /** **/
    public org.ogre4j.ITextureUnitState back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public org.ogre4j.ITextureUnitState front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(org.ogre4j.ITextureUnitState val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
public interface IContentTypeLookup extends INativeObject, org.std.Ivector< Integer > {

    /** **/
    public void assign(int num, int val);

    /** **/
    public IntegerPointer at(int loc);

    /** **/
    public IntegerPointer back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public IntegerPointer front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(int val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
    /** **/
    public org.ogre4j.IPass operatorAssignment(org.ogre4j.IPass oth);

    /** **/
    public boolean isProgrammable();

    /** **/
    public boolean hasVertexProgram();

    /** **/
    public boolean hasFragmentProgram();

    /** **/
    public boolean hasGeometryProgram();

    /** **/
    public boolean hasShadowCasterVertexProgram();

    /** **/
    public boolean hasShadowReceiverVertexProgram();

    /** **/
    public boolean hasShadowReceiverFragmentProgram();

    /** **/
    public int getIndex();

    /** **/
    public void setName(String name);

    /** **/
    public String getName();

    /** 
    Sets the ambient colour reflectance properties of this pass. **/
    public void setAmbient(float red, float green, float blue);

    /** 
    Sets the ambient colour reflectance properties of this pass. **/
    public void setAmbient(org.ogre4j.IColourValue ambient);

    /** 
    Sets the diffuse colour reflectance properties of this pass. **/
    public void setDiffuse(float red, float green, float blue, float alpha);

    /** 
    Sets the diffuse colour reflectance properties of this pass. **/
    public void setDiffuse(org.ogre4j.IColourValue diffuse);

    /** 
    Sets the specular colour reflectance properties of this pass. **/
    public void setSpecular(float red, float green, float blue, float alpha);

    /** 
    Sets the specular colour reflectance properties of this pass. **/
    public void setSpecular(org.ogre4j.IColourValue specular);

    /** 
    Sets the shininess of the pass, affecting the size of specular highlights. **/
    public void setShininess(float val);

    /** 
    Sets the amount of self-illumination an object has. **/
    public void setSelfIllumination(float red, float green, float blue);

    /** 
    Sets the amount of self-illumination an object has. **/
    public void setSelfIllumination(org.ogre4j.IColourValue selfIllum);

    /** 
    Sets which material properties follow the vertex colour **/
    public void setVertexColourTracking(int tracking);

    /** 
    Gets the point size of the pass. **/
    public float getPointSize();

    /** 
    Sets the point size of this pass. **/
    public void setPointSize(float ps);

    /** 
    Sets whether or not rendering points using OT_POINT_LIST will render point sprites (textured quads) or plain points (dots). **/
    public void setPointSpritesEnabled(boolean enabled);

    /** 
    Returns whether point sprites are enabled when rendering a point list. **/
    public boolean getPointSpritesEnabled();

    /** 
    Sets how points are attenuated with distance. **/
    public void setPointAttenuation(boolean enabled, float constant, float linear, float quadratic);

    /** 
    Returns whether points are attenuated with distance. **/
    public boolean isPointAttenuationEnabled();

    /** 
    Returns the constant coefficient of point attenuation. **/
    public float getPointAttenuationConstant();

    /** 
    Returns the linear coefficient of point attenuation. **/
    public float getPointAttenuationLinear();

    /** 
    Returns the quadratic coefficient of point attenuation. **/
    public float getPointAttenuationQuadratic();

    /** 
    Set the minimum point size, when point attenuation is in use. **/
    public void setPointMinSize(float _min);

    /** 
    Get the minimum point size, when point attenuation is in use. **/
    public float getPointMinSize();

    /** 
    Set the maximum point size, when point attenuation is in use. **/
    public void setPointMaxSize(float _max);

    /** 
    Get the maximum point size, when point attenuation is in use. **/
    public float getPointMaxSize();

    /** 
    Gets the ambient colour reflectance of the pass. **/
    public org.ogre4j.IColourValue getAmbient();

    /** 
    Gets the diffuse colour reflectance of the pass. **/
    public org.ogre4j.IColourValue getDiffuse();

    /** 
    Gets the specular colour reflectance of the pass. **/
    public org.ogre4j.IColourValue getSpecular();

    /** 
    Gets the self illumination colour of the pass. **/
    public org.ogre4j.IColourValue getSelfIllumination();

    /** 
    Gets the 'shininess' property of the pass (affects specular highlights). **/
    public float getShininess();

    /** 
    Gets which material properties follow the vertex colour **/
    public int getVertexColourTracking();

    /** 
    Inserts a new  object into the . **/
    public org.ogre4j.ITextureUnitState createTextureUnitState();

    /** 
    Inserts a new  object into the . **/
    public org.ogre4j.ITextureUnitState createTextureUnitState(String textureName, int texCoordSet);

    /** 
    Adds the passed in , to the existing . **/
    public void addTextureUnitState(org.ogre4j.ITextureUnitState state);

    /** 
    Retrieves a pointer to a texture unit state so it may be modified. **/
    public org.ogre4j.ITextureUnitState getTextureUnitState(int index);

    /** 
    Retrieves the  Unit State matching name. Returns 0 if name match is not found. **/
    public org.ogre4j.ITextureUnitState getTextureUnitState(String name);

    /** **/
    public org.ogre4j.ITextureUnitState getTextureUnitState_const(int index);

    /** **/
    public org.ogre4j.ITextureUnitState getTextureUnitState_const(String name);

    /** 
    Retrieve the index of the  Unit State in the pass. **/
    public int getTextureUnitStateIndex(org.ogre4j.ITextureUnitState state);

    /** 
    Get an iterator over the TextureUnitStates contained in this . **/
    public void getTextureUnitStateIterator(org.ogre4j.IPass.ITextureUnitStateIterator returnValue);

    /** **/
    public void getTextureUnitStateIterator_const(org.ogre4j.IPass.IConstTextureUnitStateIterator returnValue);

    /** 
    Removes the indexed texture unit state from this pass. **/
    public void removeTextureUnitState(int index);

    /** 
    Removes all texture unit settings. **/
    public void removeAllTextureUnitStates();

    /** 
    Returns the number of texture unit settings. **/
    public int getNumTextureUnitStates();

    /** 
    Sets the kind of blending this pass has with the existing contents of the scene. **/
    public void setSceneBlending(org.ogre4j.SceneBlendType sbt);

    /** 
    Sets the kind of blending this pass has with the existing contents of the scene, separately for color and alpha channels **/
    public void setSeparateSceneBlending(org.ogre4j.SceneBlendType sbt, org.ogre4j.SceneBlendType sbta);

    /** 
    Allows very fine control of blending this  with the existing contents of the scene. **/
    public void setSceneBlending(org.ogre4j.SceneBlendFactor sourceFactor, org.ogre4j.SceneBlendFactor destFactor);

    /** 
    Allows very fine control of blending this  with the existing contents of the scene. **/
    public void setSeparateSceneBlending(org.ogre4j.SceneBlendFactor sourceFactor, org.ogre4j.SceneBlendFactor destFactor, org.ogre4j.SceneBlendFactor sourceFactorAlpha, org.ogre4j.SceneBlendFactor destFactorAlpha);

    /** 
    Return true if this pass uses separate scene blending **/
    public boolean hasSeparateSceneBlending();

    /** 
    Retrieves the source blending factor for the material (as set using Materiall::setSceneBlending). **/
    public org.ogre4j.SceneBlendFactor getSourceBlendFactor();

    /** 
    Retrieves the destination blending factor for the material (as set using Materiall::setSceneBlending). **/
    public org.ogre4j.SceneBlendFactor getDestBlendFactor();

    /** 
    Retrieves the alpha source blending factor for the material (as set using Materiall::setSeparateSceneBlending). **/
    public org.ogre4j.SceneBlendFactor getSourceBlendFactorAlpha();

    /** 
    Retrieves the alpha destination blending factor for the material (as set using Materiall::setSeparateSceneBlending). **/
    public org.ogre4j.SceneBlendFactor getDestBlendFactorAlpha();

    /** 
    Returns true if this pass has some element of transparency. **/
    public boolean isTransparent();

    /** 
    Sets whether or not this pass renders with depth-buffer checking on or not. **/
    public void setDepthCheckEnabled(boolean enabled);

    /** 
    Returns whether or not this pass renders with depth-buffer checking on or not. **/
    public boolean getDepthCheckEnabled();

    /** 
    Sets whether or not this pass renders with depth-buffer writing on or not. **/
    public void setDepthWriteEnabled(boolean enabled);

    /** 
    Returns whether or not this pass renders with depth-buffer writing on or not. **/
    public boolean getDepthWriteEnabled();

    /** 
    Sets the function used to compare depth values when depth checking is on. **/
    public void setDepthFunction(org.ogre4j.CompareFunction func);

    /** 
    Returns the function used to compare depth values when depth checking is on. **/
    public org.ogre4j.CompareFunction getDepthFunction();

    /** 
    Sets whether or not colour buffer writing is enabled for this . **/
    public void setColourWriteEnabled(boolean enabled);

    /** 
    Determines if colour buffer writing is enabled for this pass. **/
    public boolean getColourWriteEnabled();

    /** 
    Sets the culling mode for this pass based on the 'vertex winding'. **/
    public void setCullingMode(org.ogre4j.CullingMode mode);

    /** 
    Returns the culling mode for geometry rendered with this pass. See setCullingMode for more information. **/
    public org.ogre4j.CullingMode getCullingMode();

    /** 
    Sets the manual culling mode, performed by CPU rather than hardware. **/
    public void setManualCullingMode(org.ogre4j.ManualCullingMode mode);

    /** 
    Retrieves the manual culling mode for this pass **/
    public org.ogre4j.ManualCullingMode getManualCullingMode();

    /** 
    Sets whether or not dynamic lighting is enabled. **/
    public void setLightingEnabled(boolean enabled);

    /** 
    Returns whether or not dynamic lighting is enabled. **/
    public boolean getLightingEnabled();

    /** 
    Sets the maximum number of lights to be used by this pass. **/
    public void setMaxSimultaneousLights(int maxLights);

    /** 
    Gets the maximum number of lights to be used by this pass. **/
    public int getMaxSimultaneousLights();

    /** 
    Sets the light index that this pass will start at in the light list. **/
    public void setStartLight(int startLight);

    /** 
    Gets the light index that this pass will start at in the light list. **/
    public int getStartLight();

    /** 
    Sets the type of light shading required **/
    public void setShadingMode(org.ogre4j.ShadeOptions mode);

    /** 
    Returns the type of light shading to be used. **/
    public org.ogre4j.ShadeOptions getShadingMode();

    /** 
    Sets the type of polygon rendering required **/
    public void setPolygonMode(org.ogre4j.PolygonMode mode);

    /** 
    Returns the type of light shading to be used. **/
    public org.ogre4j.PolygonMode getPolygonMode();

    /** 
    Sets whether this pass's chosen detail level can be overridden (downgraded) by the camera setting. **/
    public void setPolygonModeOverrideable(boolean override);

    /** 
    Gets whether this renderable's chosen detail level can be overridden (downgraded) by the camera setting. **/
    public boolean getPolygonModeOverrideable();

    /** 
    Sets the fogging mode applied to this pass. **/
    public void setFog(boolean overrideScene, org.ogre4j.FogMode mode, org.ogre4j.IColourValue colour, float expDensity, float linearStart, float linearEnd);

    /** 
    Returns true if this pass is to override the scene fog settings. **/
    public boolean getFogOverride();

    /** 
    Returns the fog mode for this pass. **/
    public org.ogre4j.FogMode getFogMode();

    /** 
    Returns the fog colour for the scene. **/
    public org.ogre4j.IColourValue getFogColour();

    /** 
    Returns the fog start distance for this pass. **/
    public float getFogStart();

    /** 
    Returns the fog end distance for this pass. **/
    public float getFogEnd();

    /** 
    Returns the fog density for this pass. **/
    public float getFogDensity();

    /** 
    Sets the depth bias to be used for this material. **/
    public void setDepthBias(float constantBias, float slopeScaleBias);

    /** 
    Retrieves the const depth bias value as set by setDepthBias. **/
    public float getDepthBiasConstant();

    /** 
    Retrieves the slope-scale depth bias value as set by setDepthBias. **/
    public float getDepthBiasSlopeScale();

    /** 
    Sets a factor which derives an additional depth bias from the number of times a pass is iterated. **/
    public void setIterationDepthBias(float biasPerIteration);

    /** 
    Gets a factor which derives an additional depth bias from the number of times a pass is iterated. **/
    public float getIterationDepthBias();

    /** 
    Sets the way the pass will have use alpha to totally reject pixels from the pipeline. **/
    public void setAlphaRejectSettings(org.ogre4j.CompareFunction func, short value, boolean alphaToCoverageEnabled);

    /** 
    Sets the alpha reject function. See setAlphaRejectSettings for more information. **/
    public void setAlphaRejectFunction(org.ogre4j.CompareFunction func);

    /** 
    Gets the alpha reject value. See setAlphaRejectSettings for more information. **/
    public void setAlphaRejectValue(short val);

    /** 
    Gets the alpha reject function. See setAlphaRejectSettings for more information. **/
    public org.ogre4j.CompareFunction getAlphaRejectFunction();

    /** 
    Gets the alpha reject value. See setAlphaRejectSettings for more information. **/
    public short getAlphaRejectValue();

    /** 
    Sets whether to use alpha to coverage (A2C) when blending alpha rejected values. **/
    public void setAlphaToCoverageEnabled(boolean enabled);

    /** 
    Gets whether to use alpha to coverage (A2C) when blending alpha rejected values. **/
    public boolean isAlphaToCoverageEnabled();

    /** 
    Sets whether or not transparent sorting is enabled. **/
    public void setTransparentSortingEnabled(boolean enabled);

    /** 
    Returns whether or not transparent sorting is enabled. **/
    public boolean getTransparentSortingEnabled();

    /** 
    Sets whether or not this pass should iterate per light or number of lights which can affect the object being rendered. **/
    public void setIteratePerLight(boolean enabled, boolean onlyForOneLightType, org.ogre4j.Light.LightTypes lightType);

    /** 
    Does this pass run once for every light in range? **/
    public boolean getIteratePerLight();

    /** 
    Does this pass run only for a single light type (if getIteratePerLight is true). **/
    public boolean getRunOnlyForOneLightType();

    /** 
    Gets the single light type this pass runs for if getIteratePerLight and getRunOnlyForOneLightType are both true. **/
    public org.ogre4j.Light.LightTypes getOnlyLightType();

    /** 
    If light iteration is enabled, determine the number of lights per iteration. **/
    public void setLightCountPerIteration(int c);

    /** 
    If light iteration is enabled, determine the number of lights per iteration. **/
    public int getLightCountPerIteration();

    /** **/
    public org.ogre4j.ITechnique getParent();

    /** **/
    public String getResourceGroup();

    /** 
    Sets the details of the vertex program to use. **/
    public void setVertexProgram(String name, boolean resetParams);

    /** 
    Sets the vertex program parameters. **/
    public void setVertexProgramParameters(org.ogre4j.IGpuProgramParametersSharedPtr params);

    /** 
    Gets the name of the vertex program used by this pass. **/
    public String getVertexProgramName();

    /** 
    Gets the vertex program parameters used by this pass. **/
    public void getVertexProgramParameters(org.ogre4j.IGpuProgramParametersSharedPtr returnValue);

    /** 
    Gets the vertex program used by this pass, only available after . **/
    public org.ogre4j.IGpuProgramPtr getVertexProgram();

    /** 
    Sets the details of the vertex program to use when rendering as a shadow caster. **/
    public void setShadowCasterVertexProgram(String name);

    /** 
    Sets the vertex program parameters for rendering as a shadow caster. **/
    public void setShadowCasterVertexProgramParameters(org.ogre4j.IGpuProgramParametersSharedPtr params);

    /** 
    Gets the name of the vertex program used by this pass when rendering shadow casters. **/
    public String getShadowCasterVertexProgramName();

    /** 
    Gets the vertex program parameters used by this pass when rendering shadow casters. **/
    public void getShadowCasterVertexProgramParameters(org.ogre4j.IGpuProgramParametersSharedPtr returnValue);

    /** 
    Gets the vertex program used by this pass when rendering shadow casters, only available after . **/
    public org.ogre4j.IGpuProgramPtr getShadowCasterVertexProgram();

    /** 
    Sets the details of the vertex program to use when rendering as a shadow receiver. **/
    public void setShadowReceiverVertexProgram(String name);

    /** 
    Sets the vertex program parameters for rendering as a shadow receiver. **/
    public void setShadowReceiverVertexProgramParameters(org.ogre4j.IGpuProgramParametersSharedPtr params);

    /** 
    This method allows you to specify a fragment program for use when rendering a texture shadow receiver. **/
    public void setShadowReceiverFragmentProgram(String name);

    /** 
    Sets the fragment program parameters for rendering as a shadow receiver. **/
    public void setShadowReceiverFragmentProgramParameters(org.ogre4j.IGpuProgramParametersSharedPtr params);

    /** 
    Gets the name of the vertex program used by this pass when rendering shadow receivers. **/
    public String getShadowReceiverVertexProgramName();

    /** 
    Gets the vertex program parameters used by this pass when rendering shadow receivers. **/
    public void getShadowReceiverVertexProgramParameters(org.ogre4j.IGpuProgramParametersSharedPtr returnValue);

    /** 
    Gets the vertex program used by this pass when rendering shadow receivers, only available after . **/
    public org.ogre4j.IGpuProgramPtr getShadowReceiverVertexProgram();

    /** 
    Gets the name of the fragment program used by this pass when rendering shadow receivers. **/
    public String getShadowReceiverFragmentProgramName();

    /** 
    Gets the fragment program parameters used by this pass when rendering shadow receivers. **/
    public void getShadowReceiverFragmentProgramParameters(org.ogre4j.IGpuProgramParametersSharedPtr returnValue);

    /** 
    Gets the fragment program used by this pass when rendering shadow receivers, only available after . **/
    public org.ogre4j.IGpuProgramPtr getShadowReceiverFragmentProgram();

    /** 
    Sets the details of the fragment program to use. **/
    public void setFragmentProgram(String name, boolean resetParams);

    /** 
    Sets the fragment program parameters. **/
    public void setFragmentProgramParameters(org.ogre4j.IGpuProgramParametersSharedPtr params);

    /** 
    Gets the name of the fragment program used by this pass. **/
    public String getFragmentProgramName();

    /** 
    Gets the fragment program parameters used by this pass. **/
    public void getFragmentProgramParameters(org.ogre4j.IGpuProgramParametersSharedPtr returnValue);

    /** 
    Gets the fragment program used by this pass, only available after . **/
    public org.ogre4j.IGpuProgramPtr getFragmentProgram();

    /** 
    Sets the details of the geometry program to use. **/
    public void setGeometryProgram(String name, boolean resetParams);

    /** 
    Sets the geometry program parameters. **/
    public void setGeometryProgramParameters(org.ogre4j.IGpuProgramParametersSharedPtr params);

    /** 
    Gets the name of the geometry program used by this pass. **/
    public String getGeometryProgramName();

    /** 
    Gets the geometry program parameters used by this pass. **/
    public void getGeometryProgramParameters(org.ogre4j.IGpuProgramParametersSharedPtr returnValue);

    /** 
    Gets the geometry program used by this pass, only available after . **/
    public org.ogre4j.IGpuProgramPtr getGeometryProgram();

    /** 
    Splits this  to one which can be handled in the number of texture units specified. **/
    public org.ogre4j.IPass _split(int numUnits);

    /** 
    Internal method to adjust pass index. **/
    public void _notifyIndex(int index);

    /** 
    Internal method for preparing to load this pass. **/
    public void _prepare();

    /** 
    Internal method for undoing the load preparartion for this pass. **/
    public void _unprepare();

    /** 
    Internal method for loading this pass. **/
    public void _load();

    /** 
    Internal method for unloading this pass. **/
    public void _unload();

    /** **/
    public boolean isLoaded();

    /** 
    Gets the 'hash' of this pass, ie a precomputed number to use for sorting **/
    public long getHash();

    /** **/
    public void _dirtyHash();

    /** 
    Internal method for recalculating the hash. **/
    public void _recalculateHash();

    /** 
    Tells the pass that it needs recompilation. **/
    public void _notifyNeedsRecompile();

    /** 
    Update any automatic parameters (except lights) on this pass **/
    public void _updateAutoParamsNoLights(org.ogre4j.IAutoParamDataSource source);

    /** 
    Update any automatic light parameters on this pass **/
    public void _updateAutoParamsLightsOnly(org.ogre4j.IAutoParamDataSource source);

    /** 
    Gets the 'nth' texture which references the given content type. **/
    public int _getTextureUnitWithContentTypeIndex(org.ogre4j.TextureUnitState.ContentType contentType, int index);

    /** 
    Set texture filtering for every texture unit **/
    public void setTextureFiltering(org.ogre4j.TextureFilterOptions filterType);

    /** 
    Sets the anisotropy level to be used for all textures. **/
    public void setTextureAnisotropy(long maxAniso);

    /** 
    If set to true, this forces normals to be normalised dynamically by the hardware for this pass. **/
    public void setNormaliseNormals(boolean normalise);

    /** 
    Returns true if this pass has auto-normalisation of normals set. **/
    public boolean getNormaliseNormals();

    /** 
    Queue this pass for deletion when appropriate. **/
    public void queueForDeletion();

    /** 
    Returns whether this pass is ambient only. **/
    public boolean isAmbientOnly();

    /** 
    set the number of iterations that this pass should perform when doing fast multi pass operation. **/
    public void setPassIterationCount(int count);

    /** 
    Gets the pass iteration count value. **/
    public int getPassIterationCount();

    /** 
    Applies texture names to  Unit State with matching texture name aliases. All  Unit States within the pass are checked. If matching texture aliases are found then true is returned.
    **/
    public boolean applyTextureAliases(org.ogre4j.IAliasTextureNamePairList aliasList, boolean apply);

    /** 
    Sets whether or not this pass will be clipped by a scissor rectangle encompassing the lights that are being used in it. **/
    public void setLightScissoringEnabled(boolean enabled);

    /** 
    Gets whether or not this pass will be clipped by a scissor rectangle encompassing the lights that are being used in it. **/
    public boolean getLightScissoringEnabled();

    /** 
    Gets whether or not this pass will be clipped by user clips planes bounding the area covered by the light. **/
    public void setLightClipPlanesEnabled(boolean enabled);

    /** 
    Gets whether or not this pass will be clipped by user clips planes bounding the area covered by the light. **/
    public boolean getLightClipPlanesEnabled();

    /** 
    Manually set which illumination stage this pass is a member of. **/
    public void setIlluminationStage(org.ogre4j.IlluminationStage is);

    /** **/
    public org.ogre4j.IlluminationStage getIlluminationStage();

}
