/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class TextureUnitState extends org.xbig.base.NativeObject implements org.ogre4j.ITextureUnitState {
static { System.loadLibrary("ogre4j");}
public static class TextureEffect extends org.xbig.base.NativeObject implements org.ogre4j.ITextureUnitState.ITextureEffect {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public TextureEffect(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected TextureEffect(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public TextureEffect(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public TextureEffect() {
         super( new org.xbig.base.InstancePointer(__createTextureEffect()), false);
    }

    private native static long __createTextureEffect();

    /** **/
    public org.ogre4j.TextureUnitState.TextureEffectType gettype() {
         return org.ogre4j.TextureUnitState.TextureEffectType.toEnum(_gettype(this.object.pointer));
    }

    private native int _gettype(long _pointer_);

    /** **/
    public void settype(org.ogre4j.TextureUnitState.TextureEffectType _jni_value_) {
        _settype(this.object.pointer, _jni_value_.getValue());
    }

    private native void _settype(long _pointer_, int _jni_value_);

    /** **/
    public int getsubtype() {
         return _getsubtype(this.object.pointer);
    }

    private native int _getsubtype(long _pointer_);

    /** **/
    public void setsubtype(int _jni_value_) {
        _setsubtype(this.object.pointer, _jni_value_);
    }

    private native void _setsubtype(long _pointer_, int _jni_value_);

    /** **/
    public float getarg1() {
         return _getarg1(this.object.pointer);
    }

    private native float _getarg1(long _pointer_);

    /** **/
    public void setarg1(float _jni_value_) {
        _setarg1(this.object.pointer, _jni_value_);
    }

    private native void _setarg1(long _pointer_, float _jni_value_);

    /** **/
    public float getarg2() {
         return _getarg2(this.object.pointer);
    }

    private native float _getarg2(long _pointer_);

    /** **/
    public void setarg2(float _jni_value_) {
        _setarg2(this.object.pointer, _jni_value_);
    }

    private native void _setarg2(long _pointer_, float _jni_value_);

    /** **/
    public org.ogre4j.WaveformType getwaveType() {
         return org.ogre4j.WaveformType.toEnum(_getwaveType(this.object.pointer));
    }

    private native int _getwaveType(long _pointer_);

    /** **/
    public void setwaveType(org.ogre4j.WaveformType _jni_value_) {
        _setwaveType(this.object.pointer, _jni_value_.getValue());
    }

    private native void _setwaveType(long _pointer_, int _jni_value_);

    /** **/
    public float getbase() {
         return _getbase(this.object.pointer);
    }

    private native float _getbase(long _pointer_);

    /** **/
    public void setbase(float _jni_value_) {
        _setbase(this.object.pointer, _jni_value_);
    }

    private native void _setbase(long _pointer_, float _jni_value_);

    /** **/
    public float getfrequency() {
         return _getfrequency(this.object.pointer);
    }

    private native float _getfrequency(long _pointer_);

    /** **/
    public void setfrequency(float _jni_value_) {
        _setfrequency(this.object.pointer, _jni_value_);
    }

    private native void _setfrequency(long _pointer_, float _jni_value_);

    /** **/
    public float getphase() {
         return _getphase(this.object.pointer);
    }

    private native float _getphase(long _pointer_);

    /** **/
    public void setphase(float _jni_value_) {
        _setphase(this.object.pointer, _jni_value_);
    }

    private native void _setphase(long _pointer_, float _jni_value_);

    /** **/
    public float getamplitude() {
         return _getamplitude(this.object.pointer);
    }

    private native float _getamplitude(long _pointer_);

    /** **/
    public void setamplitude(float _jni_value_) {
        _setamplitude(this.object.pointer, _jni_value_);
    }

    private native void _setamplitude(long _pointer_, float _jni_value_);

    /** **/
    public void getcontroller(org.ogre4j.IController< Float > returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getcontroller(this.object.pointer)), true);
    }

    private native long _getcontroller(long _pointer_);

    /** **/
    public void setcontroller(org.ogre4j.IController< Float > _jni_value_) {
        _setcontroller(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setcontroller(long _pointer_, long _jni_value_);

    /** **/
    public org.ogre4j.IFrustum getfrustum() {
         return new org.ogre4j.Frustum(new InstancePointer(_getfrustum(this.object.pointer)));
    }

    private native long _getfrustum(long _pointer_);

}
public static class UVWAddressingMode extends org.xbig.base.NativeObject implements org.ogre4j.ITextureUnitState.IUVWAddressingMode {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public UVWAddressingMode(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected UVWAddressingMode(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public UVWAddressingMode(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public UVWAddressingMode() {
         super( new org.xbig.base.InstancePointer(__createUVWAddressingMode()), false);
    }

    private native static long __createUVWAddressingMode();

    /** **/
    public org.ogre4j.TextureUnitState.TextureAddressingMode getu() {
         return org.ogre4j.TextureUnitState.TextureAddressingMode.toEnum(_getu(this.object.pointer));
    }

    private native int _getu(long _pointer_);

    /** **/
    public void setu(org.ogre4j.TextureUnitState.TextureAddressingMode _jni_value_) {
        _setu(this.object.pointer, _jni_value_.getValue());
    }

    private native void _setu(long _pointer_, int _jni_value_);

    /** **/
    public org.ogre4j.TextureUnitState.TextureAddressingMode getv() {
         return org.ogre4j.TextureUnitState.TextureAddressingMode.toEnum(_getv(this.object.pointer));
    }

    private native int _getv(long _pointer_);

    /** **/
    public void setv(org.ogre4j.TextureUnitState.TextureAddressingMode _jni_value_) {
        _setv(this.object.pointer, _jni_value_.getValue());
    }

    private native void _setv(long _pointer_, int _jni_value_);

    /** **/
    public org.ogre4j.TextureUnitState.TextureAddressingMode getw() {
         return org.ogre4j.TextureUnitState.TextureAddressingMode.toEnum(_getw(this.object.pointer));
    }

    private native int _getw(long _pointer_);

    /** **/
    public void setw(org.ogre4j.TextureUnitState.TextureAddressingMode _jni_value_) {
        _setw(this.object.pointer, _jni_value_.getValue());
    }

    private native void _setw(long _pointer_, int _jni_value_);

}
public enum TextureEffectType implements INativeEnum < TextureEffectType > {
    ET_ENVIRONMENT_MAP(TextureEffectTypeHelper.ENUM_VALUES[0]),
    ET_PROJECTIVE_TEXTURE(TextureEffectTypeHelper.ENUM_VALUES[1]),
    ET_UVSCROLL(TextureEffectTypeHelper.ENUM_VALUES[2]),
    ET_USCROLL(TextureEffectTypeHelper.ENUM_VALUES[3]),
    ET_VSCROLL(TextureEffectTypeHelper.ENUM_VALUES[4]),
    ET_ROTATE(TextureEffectTypeHelper.ENUM_VALUES[5]),
    ET_TRANSFORM(TextureEffectTypeHelper.ENUM_VALUES[6]);

    private int value;

    TextureEffectType(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public TextureEffectType getEnum(int val) {
        return toEnum(val);
    }

    public static final TextureEffectType toEnum(int retval) {
    if (retval ==ET_ENVIRONMENT_MAP.value)
        return TextureEffectType.ET_ENVIRONMENT_MAP;
    else if (retval ==ET_PROJECTIVE_TEXTURE.value)
        return TextureEffectType.ET_PROJECTIVE_TEXTURE;
    else if (retval ==ET_UVSCROLL.value)
        return TextureEffectType.ET_UVSCROLL;
    else if (retval ==ET_USCROLL.value)
        return TextureEffectType.ET_USCROLL;
    else if (retval ==ET_VSCROLL.value)
        return TextureEffectType.ET_VSCROLL;
    else if (retval ==ET_ROTATE.value)
        return TextureEffectType.ET_ROTATE;
    else if (retval ==ET_TRANSFORM.value)
        return TextureEffectType.ET_TRANSFORM;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class TextureEffectTypeHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

public enum EnvMapType implements INativeEnum < EnvMapType > {
    ENV_PLANAR(EnvMapTypeHelper.ENUM_VALUES[0]),
    ENV_CURVED(EnvMapTypeHelper.ENUM_VALUES[1]),
    ENV_REFLECTION(EnvMapTypeHelper.ENUM_VALUES[2]),
    ENV_NORMAL(EnvMapTypeHelper.ENUM_VALUES[3]);

    private int value;

    EnvMapType(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public EnvMapType getEnum(int val) {
        return toEnum(val);
    }

    public static final EnvMapType toEnum(int retval) {
    if (retval ==ENV_PLANAR.value)
        return EnvMapType.ENV_PLANAR;
    else if (retval ==ENV_CURVED.value)
        return EnvMapType.ENV_CURVED;
    else if (retval ==ENV_REFLECTION.value)
        return EnvMapType.ENV_REFLECTION;
    else if (retval ==ENV_NORMAL.value)
        return EnvMapType.ENV_NORMAL;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class EnvMapTypeHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

public enum TextureTransformType implements INativeEnum < TextureTransformType > {
    TT_TRANSLATE_U(TextureTransformTypeHelper.ENUM_VALUES[0]),
    TT_TRANSLATE_V(TextureTransformTypeHelper.ENUM_VALUES[1]),
    TT_SCALE_U(TextureTransformTypeHelper.ENUM_VALUES[2]),
    TT_SCALE_V(TextureTransformTypeHelper.ENUM_VALUES[3]),
    TT_ROTATE(TextureTransformTypeHelper.ENUM_VALUES[4]);

    private int value;

    TextureTransformType(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public TextureTransformType getEnum(int val) {
        return toEnum(val);
    }

    public static final TextureTransformType toEnum(int retval) {
    if (retval ==TT_TRANSLATE_U.value)
        return TextureTransformType.TT_TRANSLATE_U;
    else if (retval ==TT_TRANSLATE_V.value)
        return TextureTransformType.TT_TRANSLATE_V;
    else if (retval ==TT_SCALE_U.value)
        return TextureTransformType.TT_SCALE_U;
    else if (retval ==TT_SCALE_V.value)
        return TextureTransformType.TT_SCALE_V;
    else if (retval ==TT_ROTATE.value)
        return TextureTransformType.TT_ROTATE;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class TextureTransformTypeHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

public enum TextureAddressingMode implements INativeEnum < TextureAddressingMode > {
    TAM_WRAP(TextureAddressingModeHelper.ENUM_VALUES[0]),
    TAM_MIRROR(TextureAddressingModeHelper.ENUM_VALUES[1]),
    TAM_CLAMP(TextureAddressingModeHelper.ENUM_VALUES[2]),
    TAM_BORDER(TextureAddressingModeHelper.ENUM_VALUES[3]);

    private int value;

    TextureAddressingMode(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public TextureAddressingMode getEnum(int val) {
        return toEnum(val);
    }

    public static final TextureAddressingMode toEnum(int retval) {
    if (retval ==TAM_WRAP.value)
        return TextureAddressingMode.TAM_WRAP;
    else if (retval ==TAM_MIRROR.value)
        return TextureAddressingMode.TAM_MIRROR;
    else if (retval ==TAM_CLAMP.value)
        return TextureAddressingMode.TAM_CLAMP;
    else if (retval ==TAM_BORDER.value)
        return TextureAddressingMode.TAM_BORDER;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class TextureAddressingModeHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

public enum TextureCubeFace implements INativeEnum < TextureCubeFace > {
    CUBE_FRONT(TextureCubeFaceHelper.ENUM_VALUES[0]),
    CUBE_BACK(TextureCubeFaceHelper.ENUM_VALUES[1]),
    CUBE_LEFT(TextureCubeFaceHelper.ENUM_VALUES[2]),
    CUBE_RIGHT(TextureCubeFaceHelper.ENUM_VALUES[3]),
    CUBE_UP(TextureCubeFaceHelper.ENUM_VALUES[4]),
    CUBE_DOWN(TextureCubeFaceHelper.ENUM_VALUES[5]);

    private int value;

    TextureCubeFace(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public TextureCubeFace getEnum(int val) {
        return toEnum(val);
    }

    public static final TextureCubeFace toEnum(int retval) {
    if (retval ==CUBE_FRONT.value)
        return TextureCubeFace.CUBE_FRONT;
    else if (retval ==CUBE_BACK.value)
        return TextureCubeFace.CUBE_BACK;
    else if (retval ==CUBE_LEFT.value)
        return TextureCubeFace.CUBE_LEFT;
    else if (retval ==CUBE_RIGHT.value)
        return TextureCubeFace.CUBE_RIGHT;
    else if (retval ==CUBE_UP.value)
        return TextureCubeFace.CUBE_UP;
    else if (retval ==CUBE_DOWN.value)
        return TextureCubeFace.CUBE_DOWN;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class TextureCubeFaceHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

public enum BindingType implements INativeEnum < BindingType > {
    BT_FRAGMENT(BindingTypeHelper.ENUM_VALUES[0]),
    BT_VERTEX(BindingTypeHelper.ENUM_VALUES[1]);

    private int value;

    BindingType(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public BindingType getEnum(int val) {
        return toEnum(val);
    }

    public static final BindingType toEnum(int retval) {
    if (retval ==BT_FRAGMENT.value)
        return BindingType.BT_FRAGMENT;
    else if (retval ==BT_VERTEX.value)
        return BindingType.BT_VERTEX;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class BindingTypeHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

public enum ContentType implements INativeEnum < ContentType > {
    CONTENT_NAMED(ContentTypeHelper.ENUM_VALUES[0]),
    CONTENT_SHADOW(ContentTypeHelper.ENUM_VALUES[1]);

    private int value;

    ContentType(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public ContentType getEnum(int val) {
        return toEnum(val);
    }

    public static final ContentType toEnum(int retval) {
    if (retval ==CONTENT_NAMED.value)
        return ContentType.CONTENT_NAMED;
    else if (retval ==CONTENT_SHADOW.value)
        return ContentType.CONTENT_SHADOW;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class ContentTypeHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

public static class EffectMap extends org.xbig.base.NativeObject implements org.ogre4j.ITextureUnitState.IEffectMap {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public EffectMap(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected EffectMap(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public EffectMap(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public EffectMap() {
         super( new org.xbig.base.InstancePointer(__createEffectMap()), false);
    }

    private native static long __createEffectMap();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(org.ogre4j.TextureUnitState.TextureEffectType key) {
         return _count__Ogre_TextureUnitState_TextureEffectTypeR(this.object.pointer, key.getValue());
    }

    private native int _count__Ogre_TextureUnitState_TextureEffectTypeR(long _pointer_, int key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(org.ogre4j.TextureUnitState.TextureEffectType key) {
         return _erase__Ogre_TextureUnitState_TextureEffectTypeR(this.object.pointer, key.getValue());
    }

    private native int _erase__Ogre_TextureUnitState_TextureEffectTypeR(long _pointer_, int key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public TextureUnitState(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected TextureUnitState(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public TextureUnitState(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** 
    Default constructor. **/
    public TextureUnitState(org.ogre4j.IPass parent) {
         super( new org.xbig.base.InstancePointer(__createTextureUnitState__Passp( parent.getInstancePointer().pointer)), false);
    }

    private native static long __createTextureUnitState__Passp(long parent);

    /** **/
    public TextureUnitState(org.ogre4j.IPass parent, org.ogre4j.ITextureUnitState oth) {
         super( new org.xbig.base.InstancePointer(__createTextureUnitState__PasspTextureUnitStateR( parent.getInstancePointer().pointer,  oth.getInstancePointer().pointer)), false);
    }

    private native static long __createTextureUnitState__PasspTextureUnitStateR(long parent, long oth);

    /** **/
    public org.ogre4j.ITextureUnitState operatorAssignment(org.ogre4j.ITextureUnitState oth) {
         return new org.ogre4j.TextureUnitState(new InstancePointer(_operatorAssignment__TextureUnitStateR(this.object.pointer, oth.getInstancePointer().pointer)));
    }

    private native long _operatorAssignment__TextureUnitStateR(long _pointer_, long oth);

    /** 
    Name-based constructor. **/
    public TextureUnitState(org.ogre4j.IPass parent, String texName, long texCoordSet) {
         super( new org.xbig.base.InstancePointer(__createTextureUnitState__PasspStringRIv( parent.getInstancePointer().pointer,  texName,  texCoordSet)), false);
    }

    private native static long __createTextureUnitState__PasspStringRIv(long parent, String texName, long texCoordSet);

    /** 
    Get the name of current texture image for this layer. **/
    public String getTextureName() {
         return _getTextureName_const(this.object.pointer);
    }

    private native String _getTextureName_const(long _pointer_);

    /** 
    Sets this texture layer to use a single texture, given the name of the texture to use on this layer. **/
    public void setTextureName(String name, org.ogre4j.TextureType ttype) {
        _setTextureName__StringRTextureTypev(this.object.pointer, name,  ttype.getValue());
    }

    private native void _setTextureName__StringRTextureTypev(long _pointer_, String name, int ttype);

    /** 
    Sets this texture layer to use a combination of 6 texture maps, each one relating to a face of a cube. **/
    public void setCubicTextureName(String name, boolean forUVW) {
        _setCubicTextureName__StringRbv(this.object.pointer, name,  forUVW);
    }

    private native void _setCubicTextureName__StringRbv(long _pointer_, String name, boolean forUVW);

    /** 
    Sets the names of the texture images for an animated texture. **/
    public void setAnimatedTextureName(String name, long numFrames, float duration) {
        _setAnimatedTextureName__StringRIvRealv(this.object.pointer, name,  numFrames,  duration);
    }

    private native void _setAnimatedTextureName__StringRIvRealv(long _pointer_, String name, long numFrames, float duration);

    /** 
    Returns the width and height of the texture in the given frame. **/
    public void getTextureDimensions(org.std.Ipair< Integer, Integer > returnValue, long frame) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getTextureDimensions__Iv_const(this.object.pointer, frame)), false);
    }

    private native long _getTextureDimensions__Iv_const(long _pointer_, long frame);

    /** 
    Changes the active frame in an animated or multi-image texture. **/
    public void setCurrentFrame(long frameNumber) {
        _setCurrentFrame__Iv(this.object.pointer, frameNumber);
    }

    private native void _setCurrentFrame__Iv(long _pointer_, long frameNumber);

    /** 
    Gets the active frame in an animated or multi-image texture layer. **/
    public long getCurrentFrame() {
         return _getCurrentFrame_const(this.object.pointer);
    }

    private native long _getCurrentFrame_const(long _pointer_);

    /** 
    Gets the name of the texture associated with a frame number. Throws an exception if frameNumber exceeds the number of stored frames. **/
    public String getFrameTextureName(long frameNumber) {
         return _getFrameTextureName__Iv_const(this.object.pointer, frameNumber);
    }

    private native String _getFrameTextureName__Iv_const(long _pointer_, long frameNumber);

    /** 
    Sets the name of the texture associated with a frame. **/
    public void setFrameTextureName(String name, long frameNumber) {
        _setFrameTextureName__StringRIv(this.object.pointer, name,  frameNumber);
    }

    private native void _setFrameTextureName__StringRIv(long _pointer_, String name, long frameNumber);

    /** 
    Add a  name to the end of the frame container. **/
    public void addFrameTextureName(String name) {
        _addFrameTextureName__StringR(this.object.pointer, name);
    }

    private native void _addFrameTextureName__StringR(long _pointer_, String name);

    /** 
    deletes a specific texture frame. The texture used is not deleted but the texture will no longer be used by the  Unit. An exception is raised if the frame number exceeds the number of actual frames. **/
    public void deleteFrameTextureName(int frameNumber) {
        _deleteFrameTextureName__iV(this.object.pointer, frameNumber);
    }

    private native void _deleteFrameTextureName__iV(long _pointer_, int frameNumber);

    /** 
    Gets the number of frames for a texture. **/
    public long getNumFrames() {
         return _getNumFrames_const(this.object.pointer);
    }

    private native long _getNumFrames_const(long _pointer_);

    /** 
    Sets the type of unit these texture settings should be bound to. **/
    public void setBindingType(org.ogre4j.TextureUnitState.BindingType bt) {
        _setBindingType__BindingTypev(this.object.pointer, bt.getValue());
    }

    private native void _setBindingType__BindingTypev(long _pointer_, int bt);

    /** 
    Gets the type of unit these texture settings should be bound to. **/
    public org.ogre4j.TextureUnitState.BindingType getBindingType() {
         return org.ogre4j.TextureUnitState.BindingType.toEnum(_getBindingType_const(this.object.pointer));
    }

    private native int _getBindingType_const(long _pointer_);

    /** 
    Set the type of content this  references. **/
    public void setContentType(org.ogre4j.TextureUnitState.ContentType ct) {
        _setContentType__ContentTypev(this.object.pointer, ct.getValue());
    }

    private native void _setContentType__ContentTypev(long _pointer_, int ct);

    /** 
    Get the type of content this  references. **/
    public org.ogre4j.TextureUnitState.ContentType getContentType() {
         return org.ogre4j.TextureUnitState.ContentType.toEnum(_getContentType_const(this.object.pointer));
    }

    private native int _getContentType_const(long _pointer_);

    /** 
    Returns true if this texture unit is either a series of 6 2D textures, each in it's own frame, or is a full 3D cube map. You can tell which by checking getTextureType. **/
    public boolean isCubic() {
         return _isCubic_const(this.object.pointer);
    }

    private native boolean _isCubic_const(long _pointer_);

    /** 
    Returns true if this texture layer uses a composite 3D cubic texture. **/
    public boolean is3D() {
         return _is3D_const(this.object.pointer);
    }

    private native boolean _is3D_const(long _pointer_);

    /** 
    Returns the type of this texture. **/
    public org.ogre4j.TextureType getTextureType() {
         return org.ogre4j.TextureType.toEnum(_getTextureType_const(this.object.pointer));
    }

    private native int _getTextureType_const(long _pointer_);

    /** 
    Sets the desired pixel format when load the texture. **/
    public void setDesiredFormat(org.ogre4j.PixelFormat desiredFormat) {
        _setDesiredFormat__PixelFormatv(this.object.pointer, desiredFormat.getValue());
    }

    private native void _setDesiredFormat__PixelFormatv(long _pointer_, int desiredFormat);

    /** 
    Gets the desired pixel format when load the texture. **/
    public org.ogre4j.PixelFormat getDesiredFormat() {
         return org.ogre4j.PixelFormat.toEnum(_getDesiredFormat_const(this.object.pointer));
    }

    private native int _getDesiredFormat_const(long _pointer_);

    /** 
    Sets how many mipmaps have been requested for the texture. **/
    public void setNumMipmaps(int numMipmaps) {
        _setNumMipmaps__iv(this.object.pointer, numMipmaps);
    }

    private native void _setNumMipmaps__iv(long _pointer_, int numMipmaps);

    /** 
    Gets how many mipmaps have been requested for the texture. **/
    public int getNumMipmaps() {
         return _getNumMipmaps_const(this.object.pointer);
    }

    private native int _getNumMipmaps_const(long _pointer_);

    /** 
    Sets whether this texture is requested to be loaded as alpha if single channel **/
    public void setIsAlpha(boolean isAlpha) {
        _setIsAlpha__bv(this.object.pointer, isAlpha);
    }

    private native void _setIsAlpha__bv(long _pointer_, boolean isAlpha);

    /** 
    Gets whether this texture is requested to be loaded as alpha if single channel **/
    public boolean getIsAlpha() {
         return _getIsAlpha_const(this.object.pointer);
    }

    private native boolean _getIsAlpha_const(long _pointer_);

    /** **/
    public void setHardwareGammaEnabled(boolean enabled) {
        _setHardwareGammaEnabled__bv(this.object.pointer, enabled);
    }

    private native void _setHardwareGammaEnabled__bv(long _pointer_, boolean enabled);

    /** **/
    public boolean isHardwareGammaEnabled() {
         return _isHardwareGammaEnabled_const(this.object.pointer);
    }

    private native boolean _isHardwareGammaEnabled_const(long _pointer_);

    /** 
    Gets the index of the set of texture co-ords this layer uses. **/
    public long getTextureCoordSet() {
         return _getTextureCoordSet_const(this.object.pointer);
    }

    private native long _getTextureCoordSet_const(long _pointer_);

    /** 
    Sets the index of the set of texture co-ords this layer uses. **/
    public void setTextureCoordSet(long set) {
        _setTextureCoordSet__Iv(this.object.pointer, set);
    }

    private native void _setTextureCoordSet__Iv(long _pointer_, long set);

    /** 
    Sets a matrix used to transform any texture coordinates on this layer. **/
    public void setTextureTransform(org.ogre4j.IMatrix4 xform) {
        _setTextureTransform__Matrix4R(this.object.pointer, xform.getInstancePointer().pointer);
    }

    private native void _setTextureTransform__Matrix4R(long _pointer_, long xform);

    /** 
    Gets the current texture transformation matrix. **/
    public org.ogre4j.IMatrix4 getTextureTransform() {
         return new org.ogre4j.Matrix4(new InstancePointer(_getTextureTransform_const(this.object.pointer)));
    }

    private native long _getTextureTransform_const(long _pointer_);

    /** 
    Sets the translation offset of the texture, ie scrolls the texture. **/
    public void setTextureScroll(float u, float v) {
        _setTextureScroll__RealvRealv(this.object.pointer, u,  v);
    }

    private native void _setTextureScroll__RealvRealv(long _pointer_, float u, float v);

    /** 
    As setTextureScroll, but sets only U value. **/
    public void setTextureUScroll(float value) {
        _setTextureUScroll__Realv(this.object.pointer, value);
    }

    private native void _setTextureUScroll__Realv(long _pointer_, float value);

    /** **/
    public float getTextureUScroll() {
         return _getTextureUScroll_const(this.object.pointer);
    }

    private native float _getTextureUScroll_const(long _pointer_);

    /** 
    As setTextureScroll, but sets only V value. **/
    public void setTextureVScroll(float value) {
        _setTextureVScroll__Realv(this.object.pointer, value);
    }

    private native void _setTextureVScroll__Realv(long _pointer_, float value);

    /** **/
    public float getTextureVScroll() {
         return _getTextureVScroll_const(this.object.pointer);
    }

    private native float _getTextureVScroll_const(long _pointer_);

    /** 
    As setTextureScale, but sets only U value. **/
    public void setTextureUScale(float value) {
        _setTextureUScale__Realv(this.object.pointer, value);
    }

    private native void _setTextureUScale__Realv(long _pointer_, float value);

    /** **/
    public float getTextureUScale() {
         return _getTextureUScale_const(this.object.pointer);
    }

    private native float _getTextureUScale_const(long _pointer_);

    /** 
    As setTextureScale, but sets only V value. **/
    public void setTextureVScale(float value) {
        _setTextureVScale__Realv(this.object.pointer, value);
    }

    private native void _setTextureVScale__Realv(long _pointer_, float value);

    /** **/
    public float getTextureVScale() {
         return _getTextureVScale_const(this.object.pointer);
    }

    private native float _getTextureVScale_const(long _pointer_);

    /** 
    Sets the scaling factor applied to texture coordinates. **/
    public void setTextureScale(float uScale, float vScale) {
        _setTextureScale__RealvRealv(this.object.pointer, uScale,  vScale);
    }

    private native void _setTextureScale__RealvRealv(long _pointer_, float uScale, float vScale);

    /** 
    Sets the anticlockwise rotation factor applied to texture coordinates. **/
    public void setTextureRotate(org.ogre4j.IRadian angle) {
        _setTextureRotate__RadianR(this.object.pointer, angle.getInstancePointer().pointer);
    }

    private native void _setTextureRotate__RadianR(long _pointer_, long angle);

    /** **/
    public org.ogre4j.IRadian getTextureRotate() {
         return new org.ogre4j.Radian(new InstancePointer(_getTextureRotate_const(this.object.pointer)));
    }

    private native long _getTextureRotate_const(long _pointer_);

    /** 
    Gets the texture addressing mode for a given coordinate, i.e. what happens at uv values above 1.0. **/
    public org.ogre4j.ITextureUnitState.IUVWAddressingMode getTextureAddressingMode() {
         return new org.ogre4j.TextureUnitState.UVWAddressingMode(new InstancePointer(_getTextureAddressingMode_const(this.object.pointer)));
    }

    private native long _getTextureAddressingMode_const(long _pointer_);

    /** 
    Sets the texture addressing mode, i.e. what happens at uv values above 1.0. **/
    public void setTextureAddressingMode(org.ogre4j.TextureUnitState.TextureAddressingMode tam) {
        _setTextureAddressingMode__TextureAddressingModev(this.object.pointer, tam.getValue());
    }

    private native void _setTextureAddressingMode__TextureAddressingModev(long _pointer_, int tam);

    /** 
    Sets the texture addressing mode, i.e. what happens at uv values above 1.0. **/
    public void setTextureAddressingMode(org.ogre4j.TextureUnitState.TextureAddressingMode u, org.ogre4j.TextureUnitState.TextureAddressingMode v, org.ogre4j.TextureUnitState.TextureAddressingMode w) {
        _setTextureAddressingMode__TextureAddressingModevTextureAddressingModevTextureAddressingModev(this.object.pointer, u.getValue(),  v.getValue(),  w.getValue());
    }

    private native void _setTextureAddressingMode__TextureAddressingModevTextureAddressingModevTextureAddressingModev(long _pointer_, int u, int v, int w);

    /** 
    Sets the texture addressing mode, i.e. what happens at uv values above 1.0. **/
    public void setTextureAddressingMode(org.ogre4j.ITextureUnitState.IUVWAddressingMode uvw) {
        _setTextureAddressingMode__UVWAddressingModeR(this.object.pointer, uvw.getInstancePointer().pointer);
    }

    private native void _setTextureAddressingMode__UVWAddressingModeR(long _pointer_, long uvw);

    /** 
    Sets the texture border colour. **/
    public void setTextureBorderColour(org.ogre4j.IColourValue colour) {
        _setTextureBorderColour__ColourValueR(this.object.pointer, colour.getInstancePointer().pointer);
    }

    private native void _setTextureBorderColour__ColourValueR(long _pointer_, long colour);

    /** 
    Sets the texture border colour. **/
    public org.ogre4j.IColourValue getTextureBorderColour() {
         return new org.ogre4j.ColourValue(new InstancePointer(_getTextureBorderColour_const(this.object.pointer)));
    }

    private native long _getTextureBorderColour_const(long _pointer_);

    /** 
    Setting advanced blending options. **/
    public void setColourOperationEx(org.ogre4j.LayerBlendOperationEx op, org.ogre4j.LayerBlendSource source1, org.ogre4j.LayerBlendSource source2, org.ogre4j.IColourValue arg1, org.ogre4j.IColourValue arg2, float manualBlend) {
        _setColourOperationEx__LayerBlendOperationExvLayerBlendSourcevLayerBlendSourcevColourValueRColourValueRRealv(this.object.pointer, op.getValue(),  source1.getValue(),  source2.getValue(),  arg1.getInstancePointer().pointer,  arg2.getInstancePointer().pointer,  manualBlend);
    }

    private native void _setColourOperationEx__LayerBlendOperationExvLayerBlendSourcevLayerBlendSourcevColourValueRColourValueRRealv(long _pointer_, int op, int source1, int source2, long arg1, long arg2, float manualBlend);

    /** 
    Determines how this texture layer is combined with the one below it (or the diffuse colour of the geometry if this is layer 0). **/
    public void setColourOperation(org.ogre4j.LayerBlendOperation op) {
        _setColourOperation__LayerBlendOperationV(this.object.pointer, op.getValue());
    }

    private native void _setColourOperation__LayerBlendOperationV(long _pointer_, int op);

    /** 
    Sets the multipass fallback operation for this layer, if you used  and not enough multitexturing hardware is available. **/
    public void setColourOpMultipassFallback(org.ogre4j.SceneBlendFactor sourceFactor, org.ogre4j.SceneBlendFactor destFactor) {
        _setColourOpMultipassFallback__SceneBlendFactorVSceneBlendFactorV(this.object.pointer, sourceFactor.getValue(),  destFactor.getValue());
    }

    private native void _setColourOpMultipassFallback__SceneBlendFactorVSceneBlendFactorV(long _pointer_, int sourceFactor, int destFactor);

    /** 
    Get multitexturing colour blending mode. **/
    public org.ogre4j.ILayerBlendModeEx getColourBlendMode() {
         return new org.ogre4j.LayerBlendModeEx(new InstancePointer(_getColourBlendMode_const(this.object.pointer)));
    }

    private native long _getColourBlendMode_const(long _pointer_);

    /** 
    Get multitexturing alpha blending mode. **/
    public org.ogre4j.ILayerBlendModeEx getAlphaBlendMode() {
         return new org.ogre4j.LayerBlendModeEx(new InstancePointer(_getAlphaBlendMode_const(this.object.pointer)));
    }

    private native long _getAlphaBlendMode_const(long _pointer_);

    /** 
    Get the multipass fallback for colour blending operation source factor. **/
    public org.ogre4j.SceneBlendFactor getColourBlendFallbackSrc() {
         return org.ogre4j.SceneBlendFactor.toEnum(_getColourBlendFallbackSrc_const(this.object.pointer));
    }

    private native int _getColourBlendFallbackSrc_const(long _pointer_);

    /** 
    Get the multipass fallback for colour blending operation destination factor. **/
    public org.ogre4j.SceneBlendFactor getColourBlendFallbackDest() {
         return org.ogre4j.SceneBlendFactor.toEnum(_getColourBlendFallbackDest_const(this.object.pointer));
    }

    private native int _getColourBlendFallbackDest_const(long _pointer_);

    /** 
    Sets the alpha operation to be applied to this texture. **/
    public void setAlphaOperation(org.ogre4j.LayerBlendOperationEx op, org.ogre4j.LayerBlendSource source1, org.ogre4j.LayerBlendSource source2, float arg1, float arg2, float manualBlend) {
        _setAlphaOperation__LayerBlendOperationExvLayerBlendSourcevLayerBlendSourcevRealvRealvRealv(this.object.pointer, op.getValue(),  source1.getValue(),  source2.getValue(),  arg1,  arg2,  manualBlend);
    }

    private native void _setAlphaOperation__LayerBlendOperationExvLayerBlendSourcevLayerBlendSourcevRealvRealvRealv(long _pointer_, int op, int source1, int source2, float arg1, float arg2, float manualBlend);

    /** 
    Generic method for setting up texture effects. **/
    public void addEffect(org.ogre4j.ITextureUnitState.ITextureEffect effect) {
        _addEffect__TextureEffectr(this.object.pointer, effect.getInstancePointer().pointer);
    }

    private native void _addEffect__TextureEffectr(long _pointer_, long effect);

    /** 
    Turns on/off texture coordinate effect that makes this layer an environment map. **/
    public void setEnvironmentMap(boolean enable, org.ogre4j.TextureUnitState.EnvMapType envMapType) {
        _setEnvironmentMap__bvEnvMapTypev(this.object.pointer, enable,  envMapType.getValue());
    }

    private native void _setEnvironmentMap__bvEnvMapTypev(long _pointer_, boolean enable, int envMapType);

    /** 
    Sets up an animated scroll for the texture layer. **/
    public void setScrollAnimation(float uSpeed, float vSpeed) {
        _setScrollAnimation__RealvRealv(this.object.pointer, uSpeed,  vSpeed);
    }

    private native void _setScrollAnimation__RealvRealv(long _pointer_, float uSpeed, float vSpeed);

    /** 
    Sets up an animated texture rotation for this layer. **/
    public void setRotateAnimation(float speed) {
        _setRotateAnimation__Realv(this.object.pointer, speed);
    }

    private native void _setRotateAnimation__Realv(long _pointer_, float speed);

    /** 
    Sets up a general time-relative texture modification effect. **/
    public void setTransformAnimation(org.ogre4j.TextureUnitState.TextureTransformType ttype, org.ogre4j.WaveformType waveType, float base, float frequency, float phase, float amplitude) {
        _setTransformAnimation__TextureTransformTypeVWaveformTypeVRealvRealvRealvRealv(this.object.pointer, ttype.getValue(),  waveType.getValue(),  base,  frequency,  phase,  amplitude);
    }

    private native void _setTransformAnimation__TextureTransformTypeVWaveformTypeVRealvRealvRealvRealv(long _pointer_, int ttype, int waveType, float base, float frequency, float phase, float amplitude);

    /** 
    Enables or disables projective texturing on this texture unit. **/
    public void setProjectiveTexturing(boolean enabled, org.ogre4j.IFrustum projectionSettings) {
        _setProjectiveTexturing__bvFrustumP(this.object.pointer, enabled,  projectionSettings.getInstancePointer().pointer);
    }

    private native void _setProjectiveTexturing__bvFrustumP(long _pointer_, boolean enabled, long projectionSettings);

    /** 
    Removes all effects applied to this texture layer. **/
    public void removeAllEffects() {
        _removeAllEffects(this.object.pointer);
    }

    private native void _removeAllEffects(long _pointer_);

    /** 
    Removes a single effect applied to this texture layer. **/
    public void removeEffect(org.ogre4j.TextureUnitState.TextureEffectType type) {
        _removeEffect__TextureEffectTypeV(this.object.pointer, type.getValue());
    }

    private native void _removeEffect__TextureEffectTypeV(long _pointer_, int type);

    /** 
    Determines if this texture layer is currently blank. **/
    public boolean isBlank() {
         return _isBlank_const(this.object.pointer);
    }

    private native boolean _isBlank_const(long _pointer_);

    /** 
    Sets this texture layer to be blank. **/
    public void setBlank() {
        _setBlank(this.object.pointer);
    }

    private native void _setBlank(long _pointer_);

    /** 
    Tests if the texture associated with this unit has failed to load. **/
    public boolean isTextureLoadFailing() {
         return _isTextureLoadFailing_const(this.object.pointer);
    }

    private native boolean _isTextureLoadFailing_const(long _pointer_);

    /** 
    Tells the unit to retry loading the texture if it had failed to load. **/
    public void retryTextureLoad() {
        _retryTextureLoad(this.object.pointer);
    }

    private native void _retryTextureLoad(long _pointer_);

    /** **/
    public org.ogre4j.ITextureUnitState.IEffectMap getEffects() {
         return new org.ogre4j.TextureUnitState.EffectMap(new InstancePointer(_getEffects_const(this.object.pointer)));
    }

    private native long _getEffects_const(long _pointer_);

    /** **/
    public float getAnimationDuration() {
         return _getAnimationDuration_const(this.object.pointer);
    }

    private native float _getAnimationDuration_const(long _pointer_);

    /** 
    Set the texture filtering for this unit, using the simplified interface. **/
    public void setTextureFiltering(org.ogre4j.TextureFilterOptions filterType) {
        _setTextureFiltering__TextureFilterOptionsv(this.object.pointer, filterType.getValue());
    }

    private native void _setTextureFiltering__TextureFilterOptionsv(long _pointer_, int filterType);

    /** 
    Set a single filtering option on this texture unit.  ftype The filtering type to set  opts The filtering option to set **/
    public void setTextureFiltering(org.ogre4j.FilterType ftype, org.ogre4j.FilterOptions opts) {
        _setTextureFiltering__FilterTypevFilterOptionsv(this.object.pointer, ftype.getValue(),  opts.getValue());
    }

    private native void _setTextureFiltering__FilterTypevFilterOptionsv(long _pointer_, int ftype, int opts);

    /** 
    Set a the detailed filtering options on this texture unit.  minFilter The filtering to use when reducing the size of the texture. Can be FO_POINT, FO_LINEAR or FO_ANISOTROPIC  magFilter The filtering to use when increasing the size of the texture Can be FO_POINT, FO_LINEAR or FO_ANISOTROPIC  mipFilter The filtering to use between mip levels Can be FO_NONE (turns off mipmapping), FO_POINT or FO_LINEAR (trilinear filtering) **/
    public void setTextureFiltering(org.ogre4j.FilterOptions minFilter, org.ogre4j.FilterOptions magFilter, org.ogre4j.FilterOptions mipFilter) {
        _setTextureFiltering__FilterOptionsvFilterOptionsvFilterOptionsv(this.object.pointer, minFilter.getValue(),  magFilter.getValue(),  mipFilter.getValue());
    }

    private native void _setTextureFiltering__FilterOptionsvFilterOptionsvFilterOptionsv(long _pointer_, int minFilter, int magFilter, int mipFilter);

    /** **/
    public org.ogre4j.FilterOptions getTextureFiltering(org.ogre4j.FilterType ftpye) {
         return org.ogre4j.FilterOptions.toEnum(_getTextureFiltering__FilterTypev_const(this.object.pointer, ftpye.getValue()));
    }

    private native int _getTextureFiltering__FilterTypev_const(long _pointer_, int ftpye);

    /** 
    Sets the anisotropy level to be used for this texture level. **/
    public void setTextureAnisotropy(long maxAniso) {
        _setTextureAnisotropy__Iv(this.object.pointer, maxAniso);
    }

    private native void _setTextureAnisotropy__Iv(long _pointer_, long maxAniso);

    /** **/
    public long getTextureAnisotropy() {
         return _getTextureAnisotropy_const(this.object.pointer);
    }

    private native long _getTextureAnisotropy_const(long _pointer_);

    /** 
    Sets the bias value applied to the mipmap calculation. **/
    public void setTextureMipmapBias(float bias) {
        _setTextureMipmapBias__Fv(this.object.pointer, bias);
    }

    private native void _setTextureMipmapBias__Fv(long _pointer_, float bias);

    /** 
    Gets the bias value applied to the mipmap calculation. **/
    public float getTextureMipmapBias() {
         return _getTextureMipmapBias_const(this.object.pointer);
    }

    private native float _getTextureMipmapBias_const(long _pointer_);

    /** **/
    public org.ogre4j.IPass getParent() {
         return new org.ogre4j.Pass(new InstancePointer(_getParent_const(this.object.pointer)));
    }

    private native long _getParent_const(long _pointer_);

    /** 
    Internal method for preparing this object for load, as part of **/
    public void _prepare() {
        __prepare(this.object.pointer);
    }

    private native void __prepare(long _pointer_);

    /** 
    Internal method for undoing the preparation this object as part of Material::unprepare **/
    public void _unprepare() {
        __unprepare(this.object.pointer);
    }

    private native void __unprepare(long _pointer_);

    /** 
    Internal method for loading this object as part of **/
    public void _load() {
        __load(this.object.pointer);
    }

    private native void __load(long _pointer_);

    /** 
    Internal method for unloading this object as part of **/
    public void _unload() {
        __unload(this.object.pointer);
    }

    private native void __unload(long _pointer_);

    /** **/
    public boolean hasViewRelativeTextureCoordinateGeneration() {
         return _hasViewRelativeTextureCoordinateGeneration_const(this.object.pointer);
    }

    private native boolean _hasViewRelativeTextureCoordinateGeneration_const(long _pointer_);

    /** **/
    public boolean isLoaded() {
         return _isLoaded_const(this.object.pointer);
    }

    private native boolean _isLoaded_const(long _pointer_);

    /** 
    Tells the class that it needs recompilation. **/
    public void _notifyNeedsRecompile() {
        __notifyNeedsRecompile(this.object.pointer);
    }

    private native void __notifyNeedsRecompile(long _pointer_);

    /** 
    Set the name of the  Unit State **/
    public void setName(String name) {
        _setName__StringR(this.object.pointer, name);
    }

    private native void _setName__StringR(long _pointer_, String name);

    /** **/
    public String getName() {
         return _getName_const(this.object.pointer);
    }

    private native String _getName_const(long _pointer_);

    /** 
    Set the alias name used for texture frame names **/
    public void setTextureNameAlias(String name) {
        _setTextureNameAlias__StringR(this.object.pointer, name);
    }

    private native void _setTextureNameAlias__StringR(long _pointer_, String name);

    /** 
    gets the  Name Alias of the  Unit. **/
    public String getTextureNameAlias() {
         return _getTextureNameAlias_const(this.object.pointer);
    }

    private native String _getTextureNameAlias_const(long _pointer_);

    /** 
    Applies texture names to  Unit State with matching texture name aliases. If no matching aliases are found then the TUS state does not change. **/
    public boolean applyTextureAliases(org.ogre4j.IAliasTextureNamePairList aliasList, boolean apply) {
         return _applyTextureAliases__AliasTextureNamePairListRbV(this.object.pointer, aliasList.getInstancePointer().pointer,  apply);
    }

    private native boolean _applyTextureAliases__AliasTextureNamePairListRbV(long _pointer_, long aliasList, boolean apply);

    /** 
    Notify this object that its parent has changed **/
    public void _notifyParent(org.ogre4j.IPass parent) {
        __notifyParent__Passp(this.object.pointer, parent.getInstancePointer().pointer);
    }

    private native void __notifyParent__Passp(long _pointer_, long parent);

    /** 
    Get the texture pointer for the current frame. **/
    public org.ogre4j.ITexturePtr _getTexturePtr() {
         return new org.ogre4j.TexturePtr(new InstancePointer(__getTexturePtr_const(this.object.pointer)));
    }

    private native long __getTexturePtr_const(long _pointer_);

    /** 
    Get the texture pointer for a given frame. **/
    public org.ogre4j.ITexturePtr _getTexturePtr(int frame) {
         return new org.ogre4j.TexturePtr(new InstancePointer(__getTexturePtr__iv_const(this.object.pointer, frame)));
    }

    private native long __getTexturePtr__iv_const(long _pointer_, int frame);

    /** 
    Set the texture pointer for the current frame (internal use only!). **/
    public void _setTexturePtr(org.ogre4j.ITexturePtr texptr) {
        __setTexturePtr__TexturePtrR(this.object.pointer, texptr.getInstancePointer().pointer);
    }

    private native void __setTexturePtr__TexturePtrR(long _pointer_, long texptr);

    /** 
    Set the texture pointer for a given frame (internal use only!). **/
    public void _setTexturePtr(org.ogre4j.ITexturePtr texptr, int frame) {
        __setTexturePtr__TexturePtrRiv(this.object.pointer, texptr.getInstancePointer().pointer,  frame);
    }

    private native void __setTexturePtr__TexturePtrRiv(long _pointer_, long texptr, int frame);

    /** 
    Gets the animation controller (as created because of setAnimatedTexture) if it exists. **/
    public void _getAnimController(org.ogre4j.IController< Float > returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(__getAnimController_const(this.object.pointer)), true);
    }

    private native long __getAnimController_const(long _pointer_);

}
