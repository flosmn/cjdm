/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public interface IPlane extends INativeObject {

    /** **/
    public org.ogre4j.Plane.Side getSide(org.ogre4j.IVector3 rkPoint);

    /** 
    returns the side where the aligneBox is. the flag BOTH_SIDE indicates an intersecting box. one corner ON the plane is sufficient to consider the box and the plane intersecting. **/
    public org.ogre4j.Plane.Side getSide(org.ogre4j.IAxisAlignedBox rkBox);

    /** 
    Returns which side of the plane that the given box lies on. The box is defined as centre/half-size pairs for effectively. **/
    public org.ogre4j.Plane.Side getSide(org.ogre4j.IVector3 centre, org.ogre4j.IVector3 halfSize);

    /** 
    This is a pseudodistance. The sign of the return value is positive if the point is on the positive side of the plane, negative if the point is on the negative side, and zero if the point is on the plane. **/
    public float getDistance(org.ogre4j.IVector3 rkPoint);

    /** 
    Redefine this plane based on 3 points. **/
    public void redefine(org.ogre4j.IVector3 rkPoint0, org.ogre4j.IVector3 rkPoint1, org.ogre4j.IVector3 rkPoint2);

    /** 
    Redefine this plane based on a normal and a point. **/
    public void redefine(org.ogre4j.IVector3 rkNormal, org.ogre4j.IVector3 rkPoint);

    /** 
    Project a vector onto the plane. **/
    public void projectVector(org.ogre4j.IVector3 returnValue, org.ogre4j.IVector3 v);

    /** 
    Normalises the plane. **/
    public float normalise();

    /** **/
    public boolean operatorEqual(org.ogre4j.IPlane rhs);

    /** **/
    public boolean operatorNotEqual(org.ogre4j.IPlane rhs);

    /** **/
    public void getnormal(org.ogre4j.IVector3 returnValue);

    /** **/
    public void setnormal(org.ogre4j.IVector3 _jni_value_);

    /** **/
    public float getd();

    /** **/
    public void setd(float _jni_value_);

}
