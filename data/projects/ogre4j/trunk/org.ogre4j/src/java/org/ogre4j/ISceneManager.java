/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public interface ISceneManager extends INativeObject, org.ogre4j.ISceneCtlAllocatedObject {

public static interface IListener extends INativeObject {

    /** 
    Called prior to searching for visible objects in this . **/
    public void preFindVisibleObjects(org.ogre4j.ISceneManager source, org.ogre4j.SceneManager.IlluminationRenderStage irs, org.ogre4j.IViewport v);

    /** 
    Called after searching for visible objects in this . **/
    public void postFindVisibleObjects(org.ogre4j.ISceneManager source, org.ogre4j.SceneManager.IlluminationRenderStage irs, org.ogre4j.IViewport v);

    /** 
    Event raised after all shadow textures have been rendered into for all queues / targets but before any other geometry has been rendered (including main scene geometry and any additional shadow receiver passes). **/
    public void shadowTexturesUpdated(int numberOfShadowTextures);

    /** 
    This event occurs just before the view & projection matrices are set for rendering into a shadow texture. **/
    public void shadowTextureCasterPreViewProj(org.ogre4j.ILight light, org.ogre4j.ICamera camera, int iteration);

    /** 
    This event occurs just before the view & projection matrices are set for re-rendering a shadow receiver. **/
    public void shadowTextureReceiverPreViewProj(org.ogre4j.ILight light, org.ogre4j.IFrustum frustum);

    /** 
    Hook to allow the listener to override the ordering of lights for the entire frustum. **/
    public boolean sortLightsAffectingFrustum(org.ogre4j.ILightList lightList);

}
public static interface ISceneMgrQueuedRenderableVisitor extends INativeObject, org.ogre4j.IQueuedRenderableVisitor {

    /** **/
    public void visit(org.ogre4j.IRenderable r);

    /** **/
    public boolean visit(org.ogre4j.IPass p);

    /** **/
    public void visit(org.ogre4j.IRenderablePass rp);

    /** **/
    public org.ogre4j.ISceneManager gettargetSceneMgr();

    /** **/
    public void settargetSceneMgr(org.ogre4j.ISceneManager _jni_value_);

    /** **/
    public boolean gettransparentShadowCastersMode();

    /** **/
    public void settransparentShadowCastersMode(boolean _jni_value_);

    /** **/
    public boolean getautoLights();

    /** **/
    public void setautoLights(boolean _jni_value_);

    /** **/
    public org.ogre4j.ILightList getmanualLightList();

    /** **/
    public boolean getscissoring();

    /** **/
    public void setscissoring(boolean _jni_value_);

}
public static interface IShadowCasterSceneQueryListener extends INativeObject, org.ogre4j.ISceneQueryListener, org.ogre4j.ISceneCtlAllocatedObject {

    /** **/
    public void prepare(boolean lightInFrustum, org.ogre4j.IPlaneBoundedVolumeList lightClipVolumes, org.ogre4j.ILight light, org.ogre4j.ICamera cam, org.ogre4j.ISceneManager.IShadowCasterList casterList, float farDistSquared);

    /** **/
    public boolean queryResult(org.ogre4j.IMovableObject object);

    /** **/
    public boolean queryResult(org.ogre4j.ISceneQuery.IWorldFragment fragment);

}
public static interface ILightClippingInfo extends INativeObject {

    /** **/
    public void getscissorRect(org.ogre4j.IRealRect returnValue);

    /** **/
    public void setscissorRect(org.ogre4j.IRealRect _jni_value_);

    /** **/
    public void getclipPlanes(org.ogre4j.IPlaneList returnValue);

    /** **/
    public void setclipPlanes(org.ogre4j.IPlaneList _jni_value_);

    /** **/
    public boolean getscissorValid();

    /** **/
    public void setscissorValid(boolean _jni_value_);

    /** **/
    public long getclipPlanesValid();

    /** **/
    public void setclipPlanesValid(long _jni_value_);

}
public static interface ILightInfo extends INativeObject {

    /** **/
    public boolean operatorEqual(org.ogre4j.ISceneManager.ILightInfo rhs);

    /** **/
    public boolean operatorNotEqual(org.ogre4j.ISceneManager.ILightInfo rhs);

    /** **/
    public org.ogre4j.ILight getlight();

    /** **/
    public void setlight(org.ogre4j.ILight _jni_value_);

    /** **/
    public int gettype();

    /** **/
    public void settype(int _jni_value_);

    /** **/
    public float getrange();

    /** **/
    public void setrange(float _jni_value_);

    /** **/
    public void getposition(org.ogre4j.IVector3 returnValue);

    /** **/
    public void setposition(org.ogre4j.IVector3 _jni_value_);

}
public static interface IlightLess extends INativeObject {

    /** **/
    public boolean operatorFunctionCall(org.ogre4j.ILight a, org.ogre4j.ILight b);

}
public static interface IlightsForShadowTextureLess extends INativeObject {

    /** **/
    public boolean operatorFunctionCall(org.ogre4j.ILight l1, org.ogre4j.ILight l2);

}
public static interface ImaterialLess extends INativeObject {

    /** **/
    public boolean operatorFunctionCall(org.ogre4j.IMaterial x, org.ogre4j.IMaterial y);

}
public static interface IMovableObjectCollection extends INativeObject {

    /** **/
    public void getmap(org.ogre4j.ISceneManager.IMovableObjectMap returnValue);

    /** **/
    public void setmap(org.ogre4j.ISceneManager.IMovableObjectMap _jni_value_);

}
public static interface ISkyBoxGenParameters extends INativeObject {

    /** **/
    public float getskyBoxDistance();

    /** **/
    public void setskyBoxDistance(float _jni_value_);

}
public static interface ISkyDomeGenParameters extends INativeObject {

    /** **/
    public float getskyDomeCurvature();

    /** **/
    public void setskyDomeCurvature(float _jni_value_);

    /** **/
    public float getskyDomeTiling();

    /** **/
    public void setskyDomeTiling(float _jni_value_);

    /** **/
    public float getskyDomeDistance();

    /** **/
    public void setskyDomeDistance(float _jni_value_);

    /** **/
    public int getskyDomeXSegments();

    /** **/
    public void setskyDomeXSegments(int _jni_value_);

    /** **/
    public int getskyDomeYSegments();

    /** **/
    public void setskyDomeYSegments(int _jni_value_);

    /** **/
    public int getskyDomeYSegments_keep();

    /** **/
    public void setskyDomeYSegments_keep(int _jni_value_);

}
public static interface ISkyPlaneGenParameters extends INativeObject {

    /** **/
    public float getskyPlaneScale();

    /** **/
    public void setskyPlaneScale(float _jni_value_);

    /** **/
    public float getskyPlaneTiling();

    /** **/
    public void setskyPlaneTiling(float _jni_value_);

    /** **/
    public float getskyPlaneBow();

    /** **/
    public void setskyPlaneBow(float _jni_value_);

    /** **/
    public int getskyPlaneXSegments();

    /** **/
    public void setskyPlaneXSegments(int _jni_value_);

    /** **/
    public int getskyPlaneYSegments();

    /** **/
    public void setskyPlaneYSegments(int _jni_value_);

}
public interface ICameraIterator extends INativeObject, org.ogre4j.IMapIterator< org.ogre4j.ISceneManager.ICameraList > {

    /** **/
    public boolean hasMoreElements();

    /** **/
    public org.ogre4j.ICamera getNext();

    /** **/
    public org.ogre4j.ICamera peekNextValue();

    /** **/
    public String peekNextKey();

    /** **/
    public org.ogre4j.ISceneManager.ICameraIterator operatorAssignment(org.ogre4j.ISceneManager.ICameraIterator rhs);

    /** **/
    public NativeObjectPointer<org.ogre4j.ICamera> peekNextValuePtr();

    /** **/
    public void moveNext();

}
public interface IAnimationIterator extends INativeObject, org.ogre4j.IMapIterator< org.ogre4j.ISceneManager.IAnimationList > {

    /** **/
    public boolean hasMoreElements();

    /** **/
    public org.ogre4j.IAnimation getNext();

    /** **/
    public org.ogre4j.IAnimation peekNextValue();

    /** **/
    public String peekNextKey();

    /** **/
    public org.ogre4j.ISceneManager.IAnimationIterator operatorAssignment(org.ogre4j.ISceneManager.IAnimationIterator rhs);

    /** **/
    public NativeObjectPointer<org.ogre4j.IAnimation> peekNextValuePtr();

    /** **/
    public void moveNext();

}
public interface IMovableObjectIterator extends INativeObject, org.ogre4j.IMapIterator< org.ogre4j.ISceneManager.IMovableObjectMap > {

    /** **/
    public boolean hasMoreElements();

    /** **/
    public org.ogre4j.IMovableObject getNext();

    /** **/
    public org.ogre4j.IMovableObject peekNextValue();

    /** **/
    public String peekNextKey();

    /** **/
    public org.ogre4j.ISceneManager.IMovableObjectIterator operatorAssignment(org.ogre4j.ISceneManager.IMovableObjectIterator rhs);

    /** **/
    public NativeObjectPointer<org.ogre4j.IMovableObject> peekNextValuePtr();

    /** **/
    public void moveNext();

}
public interface ICameraList extends INativeObject, org.std.Imap< String, org.ogre4j.ICamera > {

    /** **/
    public void clear();

    /** **/
    public int count(String key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(String key);

    /** **/
    public int max_size();

    /** **/
    public int size();

    /** **/
    public org.ogre4j.ICamera get(String key);

    /** **/
    public void insert(String key, org.ogre4j.ICamera value);

}
public interface IStaticGeometryList extends INativeObject, org.std.Imap< String, org.ogre4j.IStaticGeometry > {

    /** **/
    public void clear();

    /** **/
    public int count(String key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(String key);

    /** **/
    public int max_size();

    /** **/
    public int size();

    /** **/
    public org.ogre4j.IStaticGeometry get(String key);

    /** **/
    public void insert(String key, org.ogre4j.IStaticGeometry value);

}
public interface IInstancedGeometryList extends INativeObject, org.std.Imap< String, org.ogre4j.IInstancedGeometry > {

    /** **/
    public void clear();

    /** **/
    public int count(String key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(String key);

    /** **/
    public int max_size();

    /** **/
    public int size();

    /** **/
    public org.ogre4j.IInstancedGeometry get(String key);

    /** **/
    public void insert(String key, org.ogre4j.IInstancedGeometry value);

}
public interface ISceneNodeList extends INativeObject, org.std.Imap< String, org.ogre4j.ISceneNode > {

    /** **/
    public void clear();

    /** **/
    public int count(String key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(String key);

    /** **/
    public int max_size();

    /** **/
    public int size();

    /** **/
    public org.ogre4j.ISceneNode get(String key);

    /** **/
    public void insert(String key, org.ogre4j.ISceneNode value);

}
public interface IAutoTrackingSceneNodes extends INativeObject, org.std.Iset< org.ogre4j.ISceneNode > {

    /** **/
    public void clear();

    /** **/
    public int count(org.ogre4j.ISceneNode key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(org.ogre4j.ISceneNode key);

    /** **/
    public int max_size();

    /** **/
    public int size();

}
public interface ISpecialCaseRenderQueueList extends INativeObject, org.std.Iset< Short > {

    /** **/
    public void clear();

    /** **/
    public int count(short key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(short key);

    /** **/
    public int max_size();

    /** **/
    public int size();

}
public interface ICamVisibleObjectsMap extends INativeObject, org.std.Imap< org.ogre4j.ICamera, org.ogre4j.IVisibleObjectsBoundsInfo > {

    /** **/
    public void clear();

    /** **/
    public int count(org.ogre4j.ICamera key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(org.ogre4j.ICamera key);

    /** **/
    public int max_size();

    /** **/
    public int size();

    /** **/
    public org.ogre4j.IVisibleObjectsBoundsInfo get(org.ogre4j.ICamera key);

    /** **/
    public void insert(org.ogre4j.ICamera key, org.ogre4j.IVisibleObjectsBoundsInfo value);

}
public interface IShadowCamLightMapping extends INativeObject, org.std.Imap< org.ogre4j.ICamera, org.ogre4j.ILight > {

    /** **/
    public void clear();

    /** **/
    public int count(org.ogre4j.ICamera key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(org.ogre4j.ICamera key);

    /** **/
    public int max_size();

    /** **/
    public int size();

    /** **/
    public org.ogre4j.ILight get(org.ogre4j.ICamera key);

    /** **/
    public void insert(org.ogre4j.ICamera key, org.ogre4j.ILight value);

}
public interface ILightInfoList extends INativeObject, org.std.Ivector< org.ogre4j.ISceneManager.ILightInfo > {

    /** **/
    public void assign(int num, org.ogre4j.ISceneManager.ILightInfo val);

    /** **/
    public org.ogre4j.ISceneManager.ILightInfo at(int loc);

    /** **/
    public org.ogre4j.ISceneManager.ILightInfo back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public org.ogre4j.ISceneManager.ILightInfo front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(org.ogre4j.ISceneManager.ILightInfo val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
public interface IMovableObjectMap extends INativeObject, org.std.Imap< String, org.ogre4j.IMovableObject > {

    /** **/
    public void clear();

    /** **/
    public int count(String key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(String key);

    /** **/
    public int max_size();

    /** **/
    public int size();

    /** **/
    public org.ogre4j.IMovableObject get(String key);

    /** **/
    public void insert(String key, org.ogre4j.IMovableObject value);

}
public interface IMovableObjectCollectionMap extends INativeObject, org.std.Imap< String, org.ogre4j.ISceneManager.IMovableObjectCollection > {

    /** **/
    public void clear();

    /** **/
    public int count(String key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(String key);

    /** **/
    public int max_size();

    /** **/
    public int size();

    /** **/
    public org.ogre4j.ISceneManager.IMovableObjectCollection get(String key);

    /** **/
    public void insert(String key, org.ogre4j.ISceneManager.IMovableObjectCollection value);

}
public interface IAnimationList extends INativeObject, org.std.Imap< String, org.ogre4j.IAnimation > {

    /** **/
    public void clear();

    /** **/
    public int count(String key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(String key);

    /** **/
    public int max_size();

    /** **/
    public int size();

    /** **/
    public org.ogre4j.IAnimation get(String key);

    /** **/
    public void insert(String key, org.ogre4j.IAnimation value);

}
public interface IRenderQueueListenerList extends INativeObject, org.std.Ivector< org.ogre4j.IRenderQueueListener > {

    /** **/
    public void assign(int num, org.ogre4j.IRenderQueueListener val);

    /** **/
    public org.ogre4j.IRenderQueueListener at(int loc);

    /** **/
    public org.ogre4j.IRenderQueueListener back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public org.ogre4j.IRenderQueueListener front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(org.ogre4j.IRenderQueueListener val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
public interface IListenerList extends INativeObject, org.std.Ivector< org.ogre4j.ISceneManager.IListener > {

    /** **/
    public void assign(int num, org.ogre4j.ISceneManager.IListener val);

    /** **/
    public org.ogre4j.ISceneManager.IListener at(int loc);

    /** **/
    public org.ogre4j.ISceneManager.IListener back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public org.ogre4j.ISceneManager.IListener front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(org.ogre4j.ISceneManager.IListener val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
public interface IShadowTextureCameraList extends INativeObject, org.std.Ivector< org.ogre4j.ICamera > {

    /** **/
    public void assign(int num, org.ogre4j.ICamera val);

    /** **/
    public org.ogre4j.ICamera at(int loc);

    /** **/
    public org.ogre4j.ICamera back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public org.ogre4j.ICamera front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(org.ogre4j.ICamera val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
public interface ILightClippingInfoMap extends INativeObject, org.std.Imap< org.ogre4j.ILight, org.ogre4j.ISceneManager.ILightClippingInfo > {

    /** **/
    public void clear();

    /** **/
    public int count(org.ogre4j.ILight key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(org.ogre4j.ILight key);

    /** **/
    public int max_size();

    /** **/
    public int size();

    /** **/
    public org.ogre4j.ISceneManager.ILightClippingInfo get(org.ogre4j.ILight key);

    /** **/
    public void insert(org.ogre4j.ILight key, org.ogre4j.ISceneManager.ILightClippingInfo value);

}
public interface IShadowCasterList extends INativeObject, org.std.Ivector< org.ogre4j.IShadowCaster > {

    /** **/
    public void assign(int num, org.ogre4j.IShadowCaster val);

    /** **/
    public org.ogre4j.IShadowCaster at(int loc);

    /** **/
    public org.ogre4j.IShadowCaster back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public org.ogre4j.IShadowCaster front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(org.ogre4j.IShadowCaster val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
    /** 
    Return the instance name of this . **/
    public String getName();

    /** 
    Retrieve the type name of this scene manager. **/
    public String getTypeName();

    /** 
    Creates a camera to be managed by this scene manager. **/
    public org.ogre4j.ICamera createCamera(String name);

    /** 
    Retrieves a pointer to the named camera. **/
    public org.ogre4j.ICamera getCamera(String name);

    /** 
    Returns whether a camera with the given name exists. **/
    public boolean hasCamera(String name);

    /** 
    Removes a camera from the scene. **/
    public void destroyCamera(org.ogre4j.ICamera cam);

    /** 
    Removes a camera from the scene. **/
    public void destroyCamera(String name);

    /** 
    Removes (and destroys) all cameras from the scene. **/
    public void destroyAllCameras();

    /** 
    Creates a light for use in the scene. **/
    public org.ogre4j.ILight createLight(String name);

    /** 
    Returns a pointer to the named  which has previously been added to the scene. **/
    public org.ogre4j.ILight getLight(String name);

    /** 
    Returns whether a light with the given name exists. **/
    public boolean hasLight(String name);

    /** 
    Retrieve a set of clipping planes for a given light. **/
    public org.ogre4j.IPlaneList getLightClippingPlanes(org.ogre4j.ILight l);

    /** 
    Retrieve a scissor rectangle for a given light and camera. **/
    public org.ogre4j.IRealRect getLightScissorRect(org.ogre4j.ILight l, org.ogre4j.ICamera cam);

    /** 
    Removes the named light from the scene and destroys it. **/
    public void destroyLight(String name);

    /** 
    Removes the light from the scene and destroys it based on a pointer. **/
    public void destroyLight(org.ogre4j.ILight light);

    /** 
    Removes and destroys all lights in the scene. **/
    public void destroyAllLights();

    /** 
    Advance method to increase the lights dirty counter due lights changed. **/
    public void _notifyLightsDirty();

    /** 
    Advance method to gets the lights dirty counter. **/
    public long _getLightsDirtyCounter();

    /** 
    Get the list of lights which could be affecting the frustum. **/
    public org.ogre4j.ILightList _getLightsAffectingFrustum();

    /** 
    Populate a light list with an ordered set of the lights which are closest to the position specified. **/
    public void _populateLightList(org.ogre4j.IVector3 position, float radius, org.ogre4j.ILightList destList);

    /** 
    Creates an instance of a . **/
    public org.ogre4j.ISceneNode createSceneNode();

    /** 
    Creates an instance of a  with a given name. **/
    public org.ogre4j.ISceneNode createSceneNode(String name);

    /** 
    Destroys a  with a given name. **/
    public void destroySceneNode(String name);

    /** 
    Destroys a . **/
    public void destroySceneNode(org.ogre4j.ISceneNode sn);

    /** 
    Gets the  at the root of the scene hierarchy. **/
    public org.ogre4j.ISceneNode getRootSceneNode();

    /** 
    Retrieves a named  from the scene graph. **/
    public org.ogre4j.ISceneNode getSceneNode(String name);

    /** 
    Returns whether a scene node with the given name exists. **/
    public boolean hasSceneNode(String name);

    /** 
    Create an  (instance of a discrete mesh). **/
    public org.ogre4j.IEntity createEntity(String entityName, String meshName);

    /** 
    Create an  (instance of a discrete mesh) from a range of prefab shapes. **/
    public org.ogre4j.IEntity createEntity(String entityName, org.ogre4j.SceneManager.PrefabType ptype);

    /** 
    Retrieves a pointer to the named . **/
    public org.ogre4j.IEntity getEntity(String name);

    /** 
    Returns whether an entity with the given name exists. **/
    public boolean hasEntity(String name);

    /** 
    Removes & destroys an  from the . **/
    public void destroyEntity(org.ogre4j.IEntity ent);

    /** 
    Removes & destroys an  from the  by name. **/
    public void destroyEntity(String name);

    /** 
    Removes & destroys all Entities. **/
    public void destroyAllEntities();

    /** 
    Create a , an object which you populate with geometry manually through a GL immediate-mode style interface. **/
    public org.ogre4j.IManualObject createManualObject(String name);

    /** 
    Retrieves a pointer to the named . **/
    public org.ogre4j.IManualObject getManualObject(String name);

    /** 
    Returns whether a manual object with the given name exists. **/
    public boolean hasManualObject(String name);

    /** 
    Removes & destroys a  from the . **/
    public void destroyManualObject(org.ogre4j.IManualObject obj);

    /** 
    Removes & destroys a  from the . **/
    public void destroyManualObject(String name);

    /** 
    Removes & destroys all ManualObjects from the . **/
    public void destroyAllManualObjects();

    /** 
    Create a , an object which you can use to render a linked chain of billboards. **/
    public org.ogre4j.IBillboardChain createBillboardChain(String name);

    /** 
    Retrieves a pointer to the named . **/
    public org.ogre4j.IBillboardChain getBillboardChain(String name);

    /** 
    Returns whether a billboard chain with the given name exists. **/
    public boolean hasBillboardChain(String name);

    /** 
    Removes & destroys a  from the . **/
    public void destroyBillboardChain(org.ogre4j.IBillboardChain obj);

    /** 
    Removes & destroys a  from the . **/
    public void destroyBillboardChain(String name);

    /** 
    Removes & destroys all BillboardChains from the . **/
    public void destroyAllBillboardChains();

    /** 
    Create a , an object which you can use to render a linked chain of billboards which follows one or more nodes. **/
    public org.ogre4j.IRibbonTrail createRibbonTrail(String name);

    /** 
    Retrieves a pointer to the named . **/
    public org.ogre4j.IRibbonTrail getRibbonTrail(String name);

    /** 
    Returns whether a ribbon trail with the given name exists. **/
    public boolean hasRibbonTrail(String name);

    /** 
    Removes & destroys a  from the . **/
    public void destroyRibbonTrail(org.ogre4j.IRibbonTrail obj);

    /** 
    Removes & destroys a  from the . **/
    public void destroyRibbonTrail(String name);

    /** 
    Removes & destroys all RibbonTrails from the . **/
    public void destroyAllRibbonTrails();

    /** 
    Creates a particle system based on a template. **/
    public org.ogre4j.IParticleSystem createParticleSystem(String name, String templateName);

    /** 
    Create a blank particle system. **/
    public org.ogre4j.IParticleSystem createParticleSystem(String name, int quota, String resourceGroup);

    /** 
    Retrieves a pointer to the named . **/
    public org.ogre4j.IParticleSystem getParticleSystem(String name);

    /** 
    Returns whether a particle system with the given name exists. **/
    public boolean hasParticleSystem(String name);

    /** 
    Removes & destroys a  from the . **/
    public void destroyParticleSystem(org.ogre4j.IParticleSystem obj);

    /** 
    Removes & destroys a  from the . **/
    public void destroyParticleSystem(String name);

    /** 
    Removes & destroys all ParticleSystems from the . **/
    public void destroyAllParticleSystems();

    /** 
    Empties the entire scene, inluding all SceneNodes, Entities, Lights, BillboardSets etc. Cameras are not deleted at this stage since they are still referenced by viewports, which are not destroyed during this process. **/
    public void clearScene();

    /** 
    Sets the ambient light level to be used for the scene. **/
    public void setAmbientLight(org.ogre4j.IColourValue colour);

    /** 
    Returns the ambient light level to be used for the scene. **/
    public org.ogre4j.IColourValue getAmbientLight();

    /** 
    Sets the source of the 'world' geometry, i.e. the large, mainly static geometry making up the world e.g. rooms, landscape etc. This function can be called before setWorldGeometry in a background thread, do to some slow tasks (e.g. IO) that do not involve the backend render system. **/
    public void prepareWorldGeometry(String filename);

    /** 
    Sets the source of the 'world' geometry, i.e. the large, mainly static geometry making up the world e.g. rooms, landscape etc. This function can be called before setWorldGeometry in a background thread, do to some slow tasks (e.g. IO) that do not involve the backend render system. **/
    public void prepareWorldGeometry(org.ogre4j.IDataStreamPtr stream, String typeName);

    /** 
    Sets the source of the 'world' geometry, i.e. the large, mainly static geometry making up the world e.g. rooms, landscape etc. **/
    public void setWorldGeometry(String filename);

    /** 
    Sets the source of the 'world' geometry, i.e. the large, mainly static geometry making up the world e.g. rooms, landscape etc. **/
    public void setWorldGeometry(org.ogre4j.IDataStreamPtr stream, String typeName);

    /** 
    Estimate the number of loading stages required to load the named world geometry. **/
    public int estimateWorldGeometry(String filename);

    /** 
    Estimate the number of loading stages required to load the named world geometry. **/
    public int estimateWorldGeometry(org.ogre4j.IDataStreamPtr stream, String typeName);

    /** 
    Asks the  to provide a suggested viewpoint from which the scene should be viewed. **/
    public void getSuggestedViewpoint(org.ogre4j.IViewPoint returnValue, boolean random);

    /** 
    Method for setting a specific option of the Scene Manager. These options are usually specific for a certain implemntation of the Scene Manager class, and may (and probably will) not exist across different implementations. **/
    public boolean setOption(String strKey, VoidPointer pValue);

    /** 
    Method for getting the value of an implementation-specific Scene Manager option. **/
    public boolean getOption(String strKey, VoidPointer pDestValue);

    /** 
    Method for verifying wether the scene manager has an implementation-specific option. **/
    public boolean hasOption(String strKey);

    /** 
    Method for getting all possible values for a specific option. When this list is too large (i.e. the option expects, for example, a float), the return value will be true, but the list will contain just one element whose size will be set to 0. Otherwise, the list will be filled with all the possible values the option can accept. **/
    public boolean getOptionValues(String strKey, org.ogre4j.IStringVector refValueList);

    /** 
    Method for getting all the implementation-specific options of the scene manager. **/
    public boolean getOptionKeys(org.ogre4j.IStringVector refKeys);

    /** 
    Internal method for updating the scene graph ie the tree of  instances managed by this class. **/
    public void _updateSceneGraph(org.ogre4j.ICamera cam);

    /** 
    Internal method which parses the scene to find visible objects to render. **/
    public void _findVisibleObjects(org.ogre4j.ICamera cam, org.ogre4j.IVisibleObjectsBoundsInfo visibleBounds, boolean onlyShadowCasters);

    /** 
    Internal method for applying animations to scene nodes. **/
    public void _applySceneAnimations();

    /** 
    Sends visible objects found in _findVisibleObjects to the rendering engine. **/
    public void _renderVisibleObjects();

    /** 
    Prompts the class to send its contents to the renderer. **/
    public void _renderScene(org.ogre4j.ICamera camera, org.ogre4j.IViewport vp, boolean includeOverlays);

    /** 
    Internal method for queueing the sky objects with the params as previously set through setSkyBox, setSkyPlane and setSkyDome. **/
    public void _queueSkiesForRendering(org.ogre4j.ICamera cam);

    /** 
    Notifies the scene manager of its destination render system **/
    public void _setDestinationRenderSystem(org.ogre4j.IRenderSystem sys);

    /** 
    Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. **/
    public void setSkyPlane(boolean enable, org.ogre4j.IPlane plane, String materialName, float scale, float tiling, boolean drawFirst, float bow, int xsegments, int ysegments, String groupName);

    /** 
    Enables / disables a 'sky plane' i.e. a plane at constant distance from the camera representing the sky. **/
    public void _setSkyPlane(boolean enable, org.ogre4j.IPlane plane, String materialName, float scale, float tiling, short renderQueue, float bow, int xsegments, int ysegments, String groupName);

    /** 
    Return whether a key plane is enabled **/
    public boolean isSkyPlaneEnabled();

    /** 
    Get the sky plane node, if enabled. **/
    public org.ogre4j.ISceneNode getSkyPlaneNode();

    /** 
    Get the parameters used to construct the SkyPlane, if any **/
    public org.ogre4j.ISceneManager.ISkyPlaneGenParameters getSkyPlaneGenParameters();

    /** 
    Enables / disables a 'sky box' i.e. a 6-sided box at constant distance from the camera representing the sky. **/
    public void setSkyBox(boolean enable, String materialName, float distance, boolean drawFirst, org.ogre4j.IQuaternion orientation, String groupName);

    /** 
    Enables / disables a 'sky box' i.e. a 6-sided box at constant distance from the camera representing the sky. **/
    public void _setSkyBox(boolean enable, String materialName, float distance, short renderQueue, org.ogre4j.IQuaternion orientation, String groupName);

    /** 
    Return whether a skybox is enabled **/
    public boolean isSkyBoxEnabled();

    /** 
    Get the skybox node, if enabled. **/
    public org.ogre4j.ISceneNode getSkyBoxNode();

    /** 
    Get the parameters used to generate the current SkyBox, if any **/
    public org.ogre4j.ISceneManager.ISkyBoxGenParameters getSkyBoxGenParameters();

    /** 
    Enables / disables a 'sky dome' i.e. an illusion of a curved sky. **/
    public void setSkyDome(boolean enable, String materialName, float curvature, float tiling, float distance, boolean drawFirst, org.ogre4j.IQuaternion orientation, int xsegments, int ysegments, int ysegments_keep, String groupName);

    /** 
    Enables / disables a 'sky dome' i.e. an illusion of a curved sky. **/
    public void _setSkyDome(boolean enable, String materialName, float curvature, float tiling, float distance, short renderQueue, org.ogre4j.IQuaternion orientation, int xsegments, int ysegments, int ysegments_keep, String groupName);

    /** 
    Return whether a skydome is enabled **/
    public boolean isSkyDomeEnabled();

    /** 
    Get the sky dome node, if enabled. **/
    public org.ogre4j.ISceneNode getSkyDomeNode();

    /** 
    Get the parameters used to generate the current SkyDome, if any **/
    public org.ogre4j.ISceneManager.ISkyDomeGenParameters getSkyDomeGenParameters();

    /** 
    Sets the fogging mode applied to the scene. **/
    public void setFog(org.ogre4j.FogMode mode, org.ogre4j.IColourValue colour, float expDensity, float linearStart, float linearEnd);

    /** 
    Returns the fog mode for the scene. **/
    public org.ogre4j.FogMode getFogMode();

    /** 
    Returns the fog colour for the scene. **/
    public org.ogre4j.IColourValue getFogColour();

    /** 
    Returns the fog start distance for the scene. **/
    public float getFogStart();

    /** 
    Returns the fog end distance for the scene. **/
    public float getFogEnd();

    /** 
    Returns the fog density for the scene. **/
    public float getFogDensity();

    /** 
    Creates a new  for use with this scene manager. **/
    public org.ogre4j.IBillboardSet createBillboardSet(String name, long poolSize);

    /** 
    Retrieves a pointer to the named . **/
    public org.ogre4j.IBillboardSet getBillboardSet(String name);

    /** 
    Returns whether a billboardset with the given name exists. **/
    public boolean hasBillboardSet(String name);

    /** 
    Removes & destroys an  from the . **/
    public void destroyBillboardSet(org.ogre4j.IBillboardSet set);

    /** 
    Removes & destroys an  from the  by name. **/
    public void destroyBillboardSet(String name);

    /** 
    Removes & destroys all BillboardSets. **/
    public void destroyAllBillboardSets();

    /** 
    Tells the  whether it should render the SceneNodes which make up the scene as well as the objects in the scene. **/
    public void setDisplaySceneNodes(boolean display);

    /** 
    Returns true if all scene nodes axis are to be displayed **/
    public boolean getDisplaySceneNodes();

    /** 
    Creates an animation which can be used to animate scene nodes. **/
    public org.ogre4j.IAnimation createAnimation(String name, float length);

    /** 
    Looks up an  object previously created with createAnimation. **/
    public org.ogre4j.IAnimation getAnimation(String name);

    /** 
    Returns whether an animation with the given name exists. **/
    public boolean hasAnimation(String name);

    /** 
    Destroys an . **/
    public void destroyAnimation(String name);

    /** 
    Removes all animations created using this . **/
    public void destroyAllAnimations();

    /** 
    Create an  object for managing application of animations. **/
    public org.ogre4j.IAnimationState createAnimationState(String animName);

    /** 
    Retrieves animation state as previously created using createAnimationState. **/
    public org.ogre4j.IAnimationState getAnimationState(String animName);

    /** 
    Returns whether an animation state with the given name exists. **/
    public boolean hasAnimationState(String name);

    /** 
    Destroys an . **/
    public void destroyAnimationState(String name);

    /** 
    Removes all animation states created using this . **/
    public void destroyAllAnimationStates();

    /** 
    Manual rendering method, for advanced users only. **/
    public void manualRender(org.ogre4j.IRenderOperation rend, org.ogre4j.IPass pass, org.ogre4j.IViewport vp, org.ogre4j.IMatrix4 worldMatrix, org.ogre4j.IMatrix4 viewMatrix, org.ogre4j.IMatrix4 projMatrix, boolean doBeginEndFrame);

    /** 
    Retrieves the internal render queue, for advanced users only. **/
    public org.ogre4j.IRenderQueue getRenderQueue();

    /** 
    Registers a new  which will be notified when render queues are processed. **/
    public void addRenderQueueListener(org.ogre4j.IRenderQueueListener newListener);

    /** 
    Removes a listener previously added with addRenderQueueListener. **/
    public void removeRenderQueueListener(org.ogre4j.IRenderQueueListener delListener);

    /** 
    Adds an item to the 'special case' render queue list. **/
    public void addSpecialCaseRenderQueue(short qid);

    /** 
    Removes an item to the 'special case' render queue list. **/
    public void removeSpecialCaseRenderQueue(short qid);

    /** 
    Clears the 'special case' render queue list. **/
    public void clearSpecialCaseRenderQueues();

    /** 
    Sets the way the special case render queue list is processed. **/
    public void setSpecialCaseRenderQueueMode(org.ogre4j.SceneManager.SpecialCaseRenderQueueMode mode);

    /** 
    Gets the way the special case render queue list is processed. **/
    public org.ogre4j.SceneManager.SpecialCaseRenderQueueMode getSpecialCaseRenderQueueMode();

    /** 
    Returns whether or not the named queue will be rendered based on the current 'special case' render queue list and mode. **/
    public boolean isRenderQueueToBeProcessed(short qid);

    /** 
    Sets the render queue that the world geometry (if any) this  renders will be associated with. **/
    public void setWorldGeometryRenderQueue(short qid);

    /** 
    Gets the render queue that the world geometry (if any) this  renders will be associated with. **/
    public short getWorldGeometryRenderQueue();

    /** 
    Allows all bounding boxes of scene nodes to be displayed. **/
    public void showBoundingBoxes(boolean bShow);

    /** 
    Returns if all bounding boxes of scene nodes are to be displayed **/
    public boolean getShowBoundingBoxes();

    /** 
    Internal method for notifying the manager that a  is autotracking. **/
    public void _notifyAutotrackingSceneNode(org.ogre4j.ISceneNode node, boolean autoTrack);

    /** 
    Creates an  for this scene manager. **/
    public org.ogre4j.IAxisAlignedBoxSceneQuery createAABBQuery(org.ogre4j.IAxisAlignedBox box, long mask);

    /** 
    Creates a  for this scene manager. **/
    public org.ogre4j.ISphereSceneQuery createSphereQuery(org.ogre4j.ISphere sphere, long mask);

    /** 
    Creates a  for this scene manager. **/
    public org.ogre4j.IPlaneBoundedVolumeListSceneQuery createPlaneBoundedVolumeQuery(org.ogre4j.IPlaneBoundedVolumeList volumes, long mask);

    /** 
    Creates a  for this scene manager. **/
    public org.ogre4j.IRaySceneQuery createRayQuery(org.ogre4j.IRay ray, long mask);

    /** 
    Creates an  for this scene manager. **/
    public org.ogre4j.IIntersectionSceneQuery createIntersectionQuery(long mask);

    /** 
    Destroys a scene query of any type. **/
    public void destroyQuery(org.ogre4j.ISceneQuery query);

    /** 
    Returns a specialised  over all cameras in the scene. **/
    public void getCameraIterator(org.ogre4j.ISceneManager.ICameraIterator returnValue);

    /** 
    Returns a specialised  over all animations in the scene. **/
    public void getAnimationIterator(org.ogre4j.ISceneManager.IAnimationIterator returnValue);

    /** 
    Returns a specialised  over all animation states in the scene. **/
    public void getAnimationStateIterator(org.ogre4j.IAnimationStateIterator returnValue);

    /** 
    Sets the general shadow technique to be used in this scene. **/
    public void setShadowTechnique(org.ogre4j.ShadowTechnique technique);

    /** 
    Gets the current shadow technique. **/
    public org.ogre4j.ShadowTechnique getShadowTechnique();

    /** 
    Enables / disables the rendering of debug information for shadows. **/
    public void setShowDebugShadows(boolean debug);

    /** 
    Are debug shadows shown? **/
    public boolean getShowDebugShadows();

    /** 
    Set the colour used to modulate areas in shadow. **/
    public void setShadowColour(org.ogre4j.IColourValue colour);

    /** 
    Get the colour used to modulate areas in shadow. **/
    public org.ogre4j.IColourValue getShadowColour();

    /** 
    Sets the distance a shadow volume is extruded for a directional light. **/
    public void setShadowDirectionalLightExtrusionDistance(float dist);

    /** 
    Gets the distance a shadow volume is extruded for a directional light. **/
    public float getShadowDirectionalLightExtrusionDistance();

    /** 
    Sets the default maximum distance away from the camera that shadows will be visible. You have to call this function before you create lights or the default distance of zero will be used. **/
    public void setShadowFarDistance(float distance);

    /** 
    Gets the default maximum distance away from the camera that shadows will be visible. **/
    public float getShadowFarDistance();

    /** **/
    public float getShadowFarDistanceSquared();

    /** 
    Sets the maximum size of the index buffer used to render shadow primitives. **/
    public void setShadowIndexBufferSize(int size);

    /** **/
    public int getShadowIndexBufferSize();

    /** 
    Set the size of the texture used for all texture-based shadows. **/
    public void setShadowTextureSize(int size);

    /** 
    Set the detailed configuration for a shadow texture. **/
    public void setShadowTextureConfig(int shadowIndex, int width, int height, org.ogre4j.PixelFormat format);

    /** 
    Set the detailed configuration for a shadow texture. **/
    public void setShadowTextureConfig(int shadowIndex, org.ogre4j.IShadowTextureConfig config);

    /** 
    Get an iterator over the current shadow texture settings. **/
    public void getShadowTextureConfigIterator(org.ogre4j.IConstShadowTextureConfigIterator returnValue);

    /** 
    Set the pixel format of the textures used for texture-based shadows. **/
    public void setShadowTexturePixelFormat(org.ogre4j.PixelFormat fmt);

    /** 
    Set the number of textures allocated for texture-based shadows. **/
    public void setShadowTextureCount(int count);

    /** **/
    public int getShadowTextureCount();

    /** 
    Set the number of shadow textures a light type uses. **/
    public void setShadowTextureCountPerLightType(org.ogre4j.Light.LightTypes type, int count);

    /** **/
    public int getShadowTextureCountPerLightType(org.ogre4j.Light.LightTypes type);

    /** 
    Sets the size and count of textures used in texture-based shadows. **/
    public void setShadowTextureSettings(int size, int count, org.ogre4j.PixelFormat fmt);

    /** 
    Get a reference to the shadow texture currently in use at the given index. **/
    public org.ogre4j.ITexturePtr getShadowTexture(int shadowIndex);

    /** 
    Sets the proportional distance which a texture shadow which is generated from a directional light will be offset into the camera view to make best use of texture space. **/
    public void setShadowDirLightTextureOffset(float offset);

    /** 
    Gets the proportional distance which a texture shadow which is generated from a directional light will be offset into the camera view to make best use of texture space. **/
    public float getShadowDirLightTextureOffset();

    /** 
    Sets the proportional distance at which texture shadows begin to fade out. **/
    public void setShadowTextureFadeStart(float fadeStart);

    /** 
    Sets the proportional distance at which texture shadows finish to fading out. **/
    public void setShadowTextureFadeEnd(float fadeEnd);

    /** 
    Sets whether or not texture shadows should attempt to self-shadow. **/
    public void setShadowTextureSelfShadow(boolean selfShadow);

    /** **/
    public boolean getShadowTextureSelfShadow();

    /** 
    Sets the default material to use for rendering shadow casters. **/
    public void setShadowTextureCasterMaterial(String name);

    /** 
    Sets the default material to use for rendering shadow receivers. **/
    public void setShadowTextureReceiverMaterial(String name);

    /** 
    Sets whether or not shadow casters should be rendered into shadow textures using their back faces rather than their front faces. **/
    public void setShadowCasterRenderBackFaces(boolean bf);

    /** 
    Gets whether or not shadow casters should be rendered into shadow textures using their back faces rather than their front faces. **/
    public boolean getShadowCasterRenderBackFaces();

    /** 
    Set the shadow camera setup to use for all lights which don't have their own shadow camera setup. **/
    public void setShadowCameraSetup(org.ogre4j.IShadowCameraSetupPtr shadowSetup);

    /** 
    Get the shadow camera setup in use for all lights which don't have their own shadow camera setup. **/
    public org.ogre4j.IShadowCameraSetupPtr getShadowCameraSetup();

    /** 
    Sets whether we should use an inifinite camera far plane when rendering stencil shadows. **/
    public void setShadowUseInfiniteFarPlane(boolean enable);

    /** 
    Is there a stencil shadow based shadowing technique in use? **/
    public boolean isShadowTechniqueStencilBased();

    /** 
    Is there a texture shadow based shadowing technique in use? **/
    public boolean isShadowTechniqueTextureBased();

    /** 
    Is there a modulative shadowing technique in use? **/
    public boolean isShadowTechniqueModulative();

    /** 
    Is there an additive shadowing technique in use? **/
    public boolean isShadowTechniqueAdditive();

    /** 
    Is the shadow technique integrated into primary materials? **/
    public boolean isShadowTechniqueIntegrated();

    /** 
    Is there any shadowing technique in use? **/
    public boolean isShadowTechniqueInUse();

    /** 
    Sets whether when using a built-in additive shadow mode, user clip planes should be used to restrict light rendering. **/
    public void setShadowUseLightClipPlanes(boolean enabled);

    /** 
    Gets whether when using a built-in additive shadow mode, user clip planes should be used to restrict light rendering. **/
    public boolean getShadowUseLightClipPlanes();

    /** 
    Add a listener which will get called back on scene manager events. **/
    public void addListener(org.ogre4j.ISceneManager.IListener s);

    /** 
    Remove a listener **/
    public void removeListener(org.ogre4j.ISceneManager.IListener s);

    /** 
    Creates a  instance suitable for use with this . **/
    public org.ogre4j.IStaticGeometry createStaticGeometry(String name);

    /** 
    Retrieve a previously created  instance. **/
    public org.ogre4j.IStaticGeometry getStaticGeometry(String name);

    /** 
    Returns whether a static geometry instance with the given name exists. **/
    public boolean hasStaticGeometry(String name);

    /** 
    Remove & destroy a  instance. **/
    public void destroyStaticGeometry(org.ogre4j.IStaticGeometry geom);

    /** 
    Remove & destroy a  instance. **/
    public void destroyStaticGeometry(String name);

    /** 
    Remove & destroy all  instances. **/
    public void destroyAllStaticGeometry();

    /** 
    Creates a  instance suitable for use with this . **/
    public org.ogre4j.IInstancedGeometry createInstancedGeometry(String name);

    /** 
    Retrieve a previously created  instance. **/
    public org.ogre4j.IInstancedGeometry getInstancedGeometry(String name);

    /** 
    Remove & destroy a  instance. **/
    public void destroyInstancedGeometry(org.ogre4j.IInstancedGeometry geom);

    /** 
    Remove & destroy a  instance. **/
    public void destroyInstancedGeometry(String name);

    /** 
    Remove & destroy all  instances. **/
    public void destroyAllInstancedGeometry();

    /** 
    Create a movable object of the type specified. **/
    public org.ogre4j.IMovableObject createMovableObject(String name, String typeName, org.ogre4j.INameValuePairList params);

    /** 
    Destroys a  with the name specified, of the type specified. **/
    public void destroyMovableObject(String name, String typeName);

    /** 
    Destroys a . **/
    public void destroyMovableObject(org.ogre4j.IMovableObject m);

    /** 
    Destroy all MovableObjects of a given type. **/
    public void destroyAllMovableObjectsByType(String typeName);

    /** 
    Destroy all MovableObjects. **/
    public void destroyAllMovableObjects();

    /** 
    Get a reference to a previously created . **/
    public org.ogre4j.IMovableObject getMovableObject(String name, String typeName);

    /** 
    Returns whether a movable object instance with the given name exists. **/
    public boolean hasMovableObject(String name, String typeName);

    /** 
    Get an iterator over all MovableObect instances of a given type. **/
    public void getMovableObjectIterator(org.ogre4j.ISceneManager.IMovableObjectIterator returnValue, String typeName);

    /** 
    Inject a  instance created externally. **/
    public void injectMovableObject(org.ogre4j.IMovableObject m);

    /** 
    Extract a previously injected . **/
    public void extractMovableObject(String name, String typeName);

    /** 
    Extract a previously injected . **/
    public void extractMovableObject(org.ogre4j.IMovableObject m);

    /** 
    Extract all injected MovableObjects of a given type. **/
    public void extractAllMovableObjectsByType(String typeName);

    /** 
    Sets a mask which is bitwise 'and'ed with objects own visibility masks to determine if the object is visible. **/
    public void setVisibilityMask(long vmask);

    /** 
    Gets a mask which is bitwise 'and'ed with objects own visibility masks to determine if the object is visible. **/
    public long getVisibilityMask();

    /** 
    Internal method for getting the combination between the global visibility mask and the per-viewport visibility mask. **/
    public long _getCombinedVisibilityMask();

    /** 
    Sets whether the  should search for visible objects, or whether they are being manually handled. **/
    public void setFindVisibleObjects(boolean find);

    /** 
    Gets whether the  should search for visible objects, or whether they are being manually handled. **/
    public boolean getFindVisibleObjects();

    /** 
    Set whether to automatically normalise normals on objects whenever they are scaled. **/
    public void setNormaliseNormalsOnScale(boolean n);

    /** 
    Get whether to automatically normalise normals on objects whenever they are scaled. **/
    public boolean getNormaliseNormalsOnScale();

    /** 
    Set whether to automatically flip the culling mode on objects whenever they are negatively scaled. **/
    public void setFlipCullingOnNegativeScale(boolean n);

    /** 
    Get whether to automatically flip the culling mode on objects whenever they are negatively scaled. **/
    public boolean getFlipCullingOnNegativeScale();

    /** 
    Render something as if it came from the current queue. **/
    public void _injectRenderWithPass(org.ogre4j.IPass pass, org.ogre4j.IRenderable rend, boolean shadowDerivation);

    /** 
    Indicates to the  whether it should suppress changing the  states when rendering objects. **/
    public void _suppressRenderStateChanges(boolean suppress);

    /** 
    Are render state changes suppressed? **/
    public boolean _areRenderStateChangesSuppressed();

    /** 
    Internal method for setting up the renderstate for a rendering pass. **/
    public org.ogre4j.IPass _setPass(org.ogre4j.IPass pass, boolean evenIfSuppressed, boolean shadowDerivation);

    /** 
    Indicates to the  whether it should suppress the active shadow rendering technique until told otherwise. **/
    public void _suppressShadows(boolean suppress);

    /** 
    Are shadows suppressed? **/
    public boolean _areShadowsSuppressed();

    /** 
    Render the objects in a given queue group **/
    public void _renderQueueGroupObjects(org.ogre4j.IRenderQueueGroup group, org.ogre4j.QueuedRenderableCollection.OrganisationMode om);

    /** 
    Advanced method for supplying an alternative visitor, used for parsing the render queues and sending the results to the renderer. **/
    public void setQueuedRenderableVisitor(org.ogre4j.ISceneManager.ISceneMgrQueuedRenderableVisitor visitor);

    /** 
    Gets the current visitor object which processes queued renderables. **/
    public org.ogre4j.ISceneManager.ISceneMgrQueuedRenderableVisitor getQueuedRenderableVisitor();

    /** 
    Get the rendersystem subclass to which the output of this Scene Manager gets sent **/
    public org.ogre4j.IRenderSystem getDestinationRenderSystem();

    /** 
    Gets the current viewport being rendered (advanced use only, only valid during viewport update. **/
    public org.ogre4j.IViewport getCurrentViewport();

    /** 
    Returns a visibility boundary box for a specific camera. **/
    public org.ogre4j.IVisibleObjectsBoundsInfo getVisibleObjectsBoundsInfo(org.ogre4j.ICamera cam);

    /** 
    Returns the shadow caster AAB for a specific light-camera combination **/
    public org.ogre4j.IVisibleObjectsBoundsInfo getShadowCasterBoundsInfo(org.ogre4j.ILight light, int iteration);

    /** 
    Set whether to use camera-relative co-ordinates when rendering, ie to always place the camera at the origin and move the world around it. **/
    public void setCameraRelativeRendering(boolean rel);

    /** 
    Get whether to use camera-relative co-ordinates when rendering, ie to always place the camera at the origin and move the world around it. **/
    public boolean getCameraRelativeRendering();

}
