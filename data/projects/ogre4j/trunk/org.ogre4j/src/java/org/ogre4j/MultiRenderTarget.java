/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class MultiRenderTarget extends org.xbig.base.NativeObject implements org.ogre4j.IMultiRenderTarget {
static { System.loadLibrary("ogre4j");}
public static class BoundSufaceList extends org.xbig.base.NativeObject implements org.ogre4j.IMultiRenderTarget.IBoundSufaceList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public BoundSufaceList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected BoundSufaceList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public BoundSufaceList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public BoundSufaceList() {
         super( new org.xbig.base.InstancePointer(__createBoundSufaceList()), false);
    }

    private native static long __createBoundSufaceList();

    /** **/
    public void assign(int num, org.ogre4j.IRenderTexture val) {
        _assign__ivOgre_RenderTextureP(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_RenderTextureP(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.IRenderTexture at(int loc) {
         return new org.ogre4j.RenderTexture(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.IRenderTexture back() {
         return new org.ogre4j.RenderTexture(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.IRenderTexture front() {
         return new org.ogre4j.RenderTexture(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.IRenderTexture val) {
        _push_back__Ogre_RenderTextureP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_RenderTextureP(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public MultiRenderTarget(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected MultiRenderTarget(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public MultiRenderTarget(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** 
    Bind a surface to a certain attachment point. 
It does not bind the surface and fails with an exception (ERR_INVALIDPARAMS) if:**/
    public void bindSurface(int attachment, org.ogre4j.IRenderTexture target) {
        _bindSurface__ivRenderTexturep(this.object.pointer, attachment,  target.getInstancePointer().pointer);
    }

    private native void _bindSurface__ivRenderTexturep(long _pointer_, int attachment, long target);

    /** 
    Unbind attachment. **/
    public void unbindSurface(int attachment) {
        _unbindSurface__iv(this.object.pointer, attachment);
    }

    private native void _unbindSurface__iv(long _pointer_, int attachment);

    /** 
    Error throwing implementation, it's not possible to write a  to disk. **/
    public void copyContentsToMemory(org.ogre4j.IPixelBox dst, org.ogre4j.RenderTarget.FrameBuffer buffer) {
        _copyContentsToMemory__PixelBoxRFrameBufferv(this.object.pointer, dst.getInstancePointer().pointer,  buffer.getValue());
    }

    private native void _copyContentsToMemory__PixelBoxRFrameBufferv(long _pointer_, long dst, int buffer);

    /** **/
    public org.ogre4j.PixelFormat suggestPixelFormat() {
         return org.ogre4j.PixelFormat.toEnum(_suggestPixelFormat_const(this.object.pointer));
    }

    private native int _suggestPixelFormat_const(long _pointer_);

    /** **/
    public org.ogre4j.IMultiRenderTarget.IBoundSufaceList getBoundSurfaceList() {
         return new org.ogre4j.MultiRenderTarget.BoundSufaceList(new InstancePointer(_getBoundSurfaceList_const(this.object.pointer)));
    }

    private native long _getBoundSurfaceList_const(long _pointer_);

    /** 
    Get a pointer to a bound surface **/
    public org.ogre4j.IRenderTexture getBoundSurface(int index) {
         return new org.ogre4j.RenderTexture(new InstancePointer(_getBoundSurface__iv(this.object.pointer, index)));
    }

    private native long _getBoundSurface__iv(long _pointer_, int index);

    /** **/
    public String getName() {
         return _getName_const(this.object.pointer);
    }

    private native String _getName_const(long _pointer_);

    /** **/
    public void getMetrics(LongPointer width, LongPointer height, LongPointer colourDepth) {
        _getMetrics__IrIrIr(this.object.pointer, width.object.pointer,  height.object.pointer,  colourDepth.object.pointer);
    }

    private native void _getMetrics__IrIrIr(long _pointer_, long width, long height, long colourDepth);

    /** **/
    public long getWidth() {
         return _getWidth_const(this.object.pointer);
    }

    private native long _getWidth_const(long _pointer_);

    /** **/
    public long getHeight() {
         return _getHeight_const(this.object.pointer);
    }

    private native long _getHeight_const(long _pointer_);

    /** **/
    public long getColourDepth() {
         return _getColourDepth_const(this.object.pointer);
    }

    private native long _getColourDepth_const(long _pointer_);

    /** 
    Tells the target to update it's contents. **/
    public void update(boolean swapBuffers) {
        _update__bv(this.object.pointer, swapBuffers);
    }

    private native void _update__bv(long _pointer_, boolean swapBuffers);

    /** 
    Swaps the frame buffers to display the next frame. **/
    public void swapBuffers(boolean waitForVSync) {
        _swapBuffers__bv(this.object.pointer, waitForVSync);
    }

    private native void _swapBuffers__bv(long _pointer_, boolean waitForVSync);

    /** 
    Adds a viewport to the rendering target. **/
    public org.ogre4j.IViewport addViewport(org.ogre4j.ICamera cam, int ZOrder, float left, float top, float width, float height) {
         return new org.ogre4j.Viewport(new InstancePointer(_addViewport__CamerapivFvFvFvFv(this.object.pointer, cam.getInstancePointer().pointer,  ZOrder,  left,  top,  width,  height)));
    }

    private native long _addViewport__CamerapivFvFvFvFv(long _pointer_, long cam, int ZOrder, float left, float top, float width, float height);

    /** 
    Returns the number of viewports attached to this target. **/
    public int getNumViewports() {
         return _getNumViewports_const(this.object.pointer);
    }

    private native int _getNumViewports_const(long _pointer_);

    /** 
    Retrieves a pointer to the viewport with the given index. **/
    public org.ogre4j.IViewport getViewport(int index) {
         return new org.ogre4j.Viewport(new InstancePointer(_getViewport__Hv(this.object.pointer, index)));
    }

    private native long _getViewport__Hv(long _pointer_, int index);

    /** 
    Removes a viewport at a given ZOrder. **/
    public void removeViewport(int ZOrder) {
        _removeViewport__iv(this.object.pointer, ZOrder);
    }

    private native void _removeViewport__iv(long _pointer_, int ZOrder);

    /** 
    Removes all viewports on this target. **/
    public void removeAllViewports() {
        _removeAllViewports(this.object.pointer);
    }

    private native void _removeAllViewports(long _pointer_);

    /** 
    Retieves details of current rendering performance. **/
    public void getStatistics(FloatPointer lastFPS, FloatPointer avgFPS, FloatPointer bestFPS, FloatPointer worstFPS) {
        _getStatistics__FrFrFrFr_const(this.object.pointer, lastFPS.object.pointer,  avgFPS.object.pointer,  bestFPS.object.pointer,  worstFPS.object.pointer);
    }

    private native void _getStatistics__FrFrFrFr_const(long _pointer_, long lastFPS, long avgFPS, long bestFPS, long worstFPS);

    /** **/
    public org.ogre4j.IRenderTarget.IFrameStats getStatistics() {
         return new org.ogre4j.RenderTarget.FrameStats(new InstancePointer(_getStatistics_const(this.object.pointer)));
    }

    private native long _getStatistics_const(long _pointer_);

    /** 
    Individual stats access - gets the number of frames per second (FPS) based on the last frame rendered. **/
    public float getLastFPS() {
         return _getLastFPS_const(this.object.pointer);
    }

    private native float _getLastFPS_const(long _pointer_);

    /** 
    Individual stats access - gets the average frames per second (FPS) since call to . **/
    public float getAverageFPS() {
         return _getAverageFPS_const(this.object.pointer);
    }

    private native float _getAverageFPS_const(long _pointer_);

    /** 
    Individual stats access - gets the best frames per second (FPS) since call to . **/
    public float getBestFPS() {
         return _getBestFPS_const(this.object.pointer);
    }

    private native float _getBestFPS_const(long _pointer_);

    /** 
    Individual stats access - gets the worst frames per second (FPS) since call to . **/
    public float getWorstFPS() {
         return _getWorstFPS_const(this.object.pointer);
    }

    private native float _getWorstFPS_const(long _pointer_);

    /** 
    Individual stats access - gets the best frame time **/
    public float getBestFrameTime() {
         return _getBestFrameTime_const(this.object.pointer);
    }

    private native float _getBestFrameTime_const(long _pointer_);

    /** 
    Individual stats access - gets the worst frame time **/
    public float getWorstFrameTime() {
         return _getWorstFrameTime_const(this.object.pointer);
    }

    private native float _getWorstFrameTime_const(long _pointer_);

    /** 
    Resets saved frame-rate statistices. **/
    public void resetStatistics() {
        _resetStatistics(this.object.pointer);
    }

    private native void _resetStatistics(long _pointer_);

    /** 
    Gets a custom (maybe platform-specific) attribute. **/
    public void getCustomAttribute(String name, VoidPointer pData) {
        _getCustomAttribute__StringRvp(this.object.pointer, name,  pData.object.pointer);
    }

    private native void _getCustomAttribute__StringRvp(long _pointer_, String name, long pData);

    /** 
    Add a listener to this  which will be called back before & after rendering. **/
    public void addListener(org.ogre4j.IRenderTargetListener listener) {
        _addListener__RenderTargetListenerp(this.object.pointer, listener.getInstancePointer().pointer);
    }

    private native void _addListener__RenderTargetListenerp(long _pointer_, long listener);

    /** 
    Removes a  previously registered using addListener. **/
    public void removeListener(org.ogre4j.IRenderTargetListener listener) {
        _removeListener__RenderTargetListenerp(this.object.pointer, listener.getInstancePointer().pointer);
    }

    private native void _removeListener__RenderTargetListenerp(long _pointer_, long listener);

    /** 
    Removes all listeners from this instance. **/
    public void removeAllListeners() {
        _removeAllListeners(this.object.pointer);
    }

    private native void _removeAllListeners(long _pointer_);

    /** 
    Sets the priority of this render target in relation to the others. **/
    public void setPriority(short priority) {
        _setPriority__ucharv(this.object.pointer, priority);
    }

    private native void _setPriority__ucharv(long _pointer_, short priority);

    /** 
    Gets the priority of a render target. **/
    public short getPriority() {
         return _getPriority_const(this.object.pointer);
    }

    private native short _getPriority_const(long _pointer_);

    /** 
    Used to retrieve or set the active state of the render target. **/
    public boolean isActive() {
         return _isActive_const(this.object.pointer);
    }

    private native boolean _isActive_const(long _pointer_);

    /** 
    Used to set the active state of the render target. **/
    public void setActive(boolean state) {
        _setActive__bv(this.object.pointer, state);
    }

    private native void _setActive__bv(long _pointer_, boolean state);

    /** 
    Sets whether this target should be automatically updated if Ogre's rendering loop or  is being used. **/
    public void setAutoUpdated(boolean autoupdate) {
        _setAutoUpdated__bv(this.object.pointer, autoupdate);
    }

    private native void _setAutoUpdated__bv(long _pointer_, boolean autoupdate);

    /** 
    Gets whether this target is automatically updated if Ogre's rendering loop or  is being used. **/
    public boolean isAutoUpdated() {
         return _isAutoUpdated_const(this.object.pointer);
    }

    private native boolean _isAutoUpdated_const(long _pointer_);

    /** 
    Writes the current contents of the render target to the named file. **/
    public void writeContentsToFile(String filename) {
        _writeContentsToFile__StringR(this.object.pointer, filename);
    }

    private native void _writeContentsToFile__StringR(long _pointer_, String filename);

    /** 
    Writes the current contents of the render target to the (PREFIX)(time-stamp)(SUFFIX) file. **/
    public String writeContentsToTimestampedFile(String filenamePrefix, String filenameSuffix) {
         return _writeContentsToTimestampedFile__StringRStringR(this.object.pointer, filenamePrefix,  filenameSuffix);
    }

    private native String _writeContentsToTimestampedFile__StringRStringR(long _pointer_, String filenamePrefix, String filenameSuffix);

    /** **/
    public boolean requiresTextureFlipping() {
         return _requiresTextureFlipping_const(this.object.pointer);
    }

    private native boolean _requiresTextureFlipping_const(long _pointer_);

    /** 
    Gets the number of triangles rendered in the last  call. **/
    public int getTriangleCount() {
         return _getTriangleCount_const(this.object.pointer);
    }

    private native int _getTriangleCount_const(long _pointer_);

    /** 
    Gets the number of batches rendered in the last  call. **/
    public int getBatchCount() {
         return _getBatchCount_const(this.object.pointer);
    }

    private native int _getBatchCount_const(long _pointer_);

    /** 
    Utility method to notify a render target that a camera has been removed, incase it was referring to it as a viewer. **/
    public void _notifyCameraRemoved(org.ogre4j.ICamera cam) {
        __notifyCameraRemoved__CameraP(this.object.pointer, cam.getInstancePointer().pointer);
    }

    private native void __notifyCameraRemoved__CameraP(long _pointer_, long cam);

    /** 
    Indicates whether this target is the primary window. The primary window is special in that it is destroyed when ogre is shut down, and cannot be destroyed directly. This is the case because it holds the context for vertex, index buffers and textures. **/
    public boolean isPrimary() {
         return _isPrimary_const(this.object.pointer);
    }

    private native boolean _isPrimary_const(long _pointer_);

    /** 
    Indicates whether on rendering, linear colour space is converted to sRGB gamma colour space. This is the exact opposite conversion of what is indicated by , and can only be enabled on creation of the render target. For render windows, it's enabled through the 'gamma' creation misc parameter. For textures, it is enabled through the hwGamma parameter to the create call. **/
    public boolean isHardwareGammaEnabled() {
         return _isHardwareGammaEnabled_const(this.object.pointer);
    }

    private native boolean _isHardwareGammaEnabled_const(long _pointer_);

    /** 
    Indicates whether multisampling is performed on rendering and at what level. **/
    public long getFSAA() {
         return _getFSAA_const(this.object.pointer);
    }

    private native long _getFSAA_const(long _pointer_);

    /** 
    Get rendersystem specific interface for this . This is used by the  to (un)bind this target, and to get specific information like surfaces and framebuffer objects. **/
    public org.ogre4j.IRenderTarget.IImpl _getImpl() {
         return new org.ogre4j.RenderTarget.Impl(new InstancePointer(__getImpl(this.object.pointer)));
    }

    private native long __getImpl(long _pointer_);

}
