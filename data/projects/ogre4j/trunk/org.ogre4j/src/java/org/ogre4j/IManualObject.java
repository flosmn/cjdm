/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public interface IManualObject extends INativeObject, org.ogre4j.IMovableObject {

public static interface IManualObjectSection extends INativeObject, org.ogre4j.IRenderable, org.ogre4j.ISceneObjAllocatedObject {

    /** **/
    public org.ogre4j.IRenderOperation getRenderOperation();

    /** **/
    public String getMaterialName();

    /** **/
    public void setMaterialName(String name);

    /** **/
    public void set32BitIndices(boolean n32);

    /** **/
    public boolean get32BitIndices();

    /** 
    
. **/
    public org.ogre4j.IMaterialPtr getMaterial();

    /** 
    
. **/
    public void getRenderOperation(org.ogre4j.IRenderOperation op);

    /** 
    
. **/
    public void getWorldTransforms(org.ogre4j.IMatrix4 xform);

    /** 
    
. **/
    public float getSquaredViewDepth(org.ogre4j.ICamera a1);

    /** 
    
. **/
    public org.ogre4j.ILightList getLights();

}
public static interface IManualObjectSectionShadowRenderable extends INativeObject, org.ogre4j.IShadowRenderable {

    /** **/
    public void getWorldTransforms(org.ogre4j.IMatrix4 xform);

    /** **/
    public void getPositionBuffer(org.ogre4j.IHardwareVertexBufferSharedPtr returnValue);

    /** **/
    public void getWBuffer(org.ogre4j.IHardwareVertexBufferSharedPtr returnValue);

}
public static interface ITempVertex extends INativeObject {

    /** **/
    public void getposition(org.ogre4j.IVector3 returnValue);

    /** **/
    public void setposition(org.ogre4j.IVector3 _jni_value_);

    /** **/
    public void getnormal(org.ogre4j.IVector3 returnValue);

    /** **/
    public void setnormal(org.ogre4j.IVector3 _jni_value_);

    /** **/
    public void gettexCoord(org.ogre4j.IVector4 returnValue);

    /** **/
    public void settexCoord(org.ogre4j.IVector4 _jni_value_);

    /** **/
    public int gettexCoordDims();

    /** **/
    public void settexCoordDims(int _jni_value_);

    /** **/
    public void getcolour(org.ogre4j.IColourValue returnValue);

    /** **/
    public void setcolour(org.ogre4j.IColourValue _jni_value_);

}
public interface ISectionList extends INativeObject, org.std.Ivector< org.ogre4j.IManualObject.IManualObjectSection > {

    /** **/
    public void assign(int num, org.ogre4j.IManualObject.IManualObjectSection val);

    /** **/
    public org.ogre4j.IManualObject.IManualObjectSection at(int loc);

    /** **/
    public org.ogre4j.IManualObject.IManualObjectSection back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public org.ogre4j.IManualObject.IManualObjectSection front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(org.ogre4j.IManualObject.IManualObjectSection val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
    /** 
    Completely clear the contents of the object. **/
    public void clear();

    /** 
    Estimate the number of vertices ahead of time. **/
    public void estimateVertexCount(int vcount);

    /** 
    Estimate the number of indices ahead of time. **/
    public void estimateIndexCount(int icount);

    /** 
    Start defining a part of the object. **/
    public void begin(String materialName, org.ogre4j.RenderOperation.OperationType opType);

    /** 
    Use before defining geometry to indicate that you intend to update the geometry regularly and want the internal structure to reflect that. **/
    public void setDynamic(boolean dyn);

    /** 
    Gets whether this object is marked as dynamic **/
    public boolean getDynamic();

    /** 
    Start the definition of an update to a part of the object. **/
    public void beginUpdate(int sectionIndex);

    /** 
    Add a vertex position, starting a new vertex at the same time. **/
    public void position(org.ogre4j.IVector3 pos);

    /** **/
    public void position(float x, float y, float z);

    /** 
    Add a vertex normal to the current vertex. **/
    public void normal(org.ogre4j.IVector3 norm);

    /** **/
    public void normal(float x, float y, float z);

    /** 
    Add a texture coordinate to the current vertex. **/
    public void textureCoord(float u);

    /** **/
    public void textureCoord(float u, float v);

    /** **/
    public void textureCoord(float u, float v, float w);

    /** **/
    public void textureCoord(float x, float y, float z, float w);

    /** **/
    public void textureCoord(org.ogre4j.IVector2 uv);

    /** **/
    public void textureCoord(org.ogre4j.IVector3 uvw);

    /** **/
    public void textureCoord(org.ogre4j.IVector4 xyzw);

    /** 
    Add a vertex colour to a vertex. **/
    public void colour(org.ogre4j.IColourValue col);

    /** 
    Add a vertex colour to a vertex. **/
    public void colour(float r, float g, float b, float a);

    /** 
    Add a vertex index to construct faces / lines / points via indexing rather than just by a simple list of vertices. **/
    public void index(long idx);

    /** 
    Add a set of 3 vertex indices to construct a triangle; this is a shortcut to calling  3 times. It is only valid for triangle lists. **/
    public void triangle(long i1, long i2, long i3);

    /** 
    Add a set of 4 vertex indices to construct a quad (out of 2 triangles); this is a shortcut to calling  6 times, or  twice. It's only valid for triangle list operations. **/
    public void quad(long i1, long i2, long i3, long i4);

    /** 
    Finish defining the object and compile the final renderable version. **/
    public org.ogre4j.IManualObject.IManualObjectSection end();

    /** 
    Alter the material for a subsection of this object after it has been specified. **/
    public void setMaterialName(int subindex, String name);

    /** 
    Convert this object to a . **/
    public void convertToMesh(org.ogre4j.IMeshPtr returnValue, String meshName, String groupName);

    /** 
    Sets whether or not to use an 'identity' projection. **/
    public void setUseIdentityProjection(boolean useIdentityProjection);

    /** 
    Returns whether or not to use an 'identity' projection. **/
    public boolean getUseIdentityProjection();

    /** 
    Sets whether or not to use an 'identity' view. **/
    public void setUseIdentityView(boolean useIdentityView);

    /** 
    Returns whether or not to use an 'identity' view. **/
    public boolean getUseIdentityView();

    /** 
    Sets the bounding box. **/
    public void setBoundingBox(org.ogre4j.IAxisAlignedBox box);

    /** 
    Gets a pointer to a , i.e. a part of a . **/
    public org.ogre4j.IManualObject.IManualObjectSection getSection(long index);

    /** 
    Retrieves the number of  objects making up this . **/
    public long getNumSections();

    /** 
    Sets whether or not to keep the original declaration order when queuing the renderables. **/
    public void setKeepDeclarationOrder(boolean keepOrder);

    /** 
    Gets whether or not the declaration order is to be kept or not. **/
    public boolean getKeepDeclarationOrder();

    /** 
    
. **/
    public String getMovableType();

    /** 
    
. **/
    public org.ogre4j.IAxisAlignedBox getBoundingBox();

    /** 
    
. **/
    public float getBoundingRadius();

    /** 
    
. **/
    public void _updateRenderQueue(org.ogre4j.IRenderQueue queue);

    /** 
    Implement this method to enable stencil shadows. **/
    public org.ogre4j.IEdgeData getEdgeList();

    /** 
    Overridden member from . **/
    public boolean hasEdgeList();

    /** 
    Implement this method to enable stencil shadows. **/
    public void getShadowVolumeRenderableIterator(org.ogre4j.IShadowCaster.IShadowRenderableListIterator returnValue, org.ogre4j.ShadowTechnique shadowTechnique, org.ogre4j.ILight light, org.ogre4j.IHardwareIndexBufferSharedPtr indexBuffer, boolean extrudeVertices, float extrusionDist, long flags);

    /** **/
    public void visitRenderables(org.ogre4j.IRenderable.IVisitor visitor, boolean debugRenderables);

}
