/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class Font extends org.xbig.base.NativeObject implements org.ogre4j.IFont {
static { System.loadLibrary("ogre4j");}
protected static class CmdCodePoints extends org.xbig.base.NativeObject implements org.ogre4j.IFont.ICmdCodePoints {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public CmdCodePoints(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected CmdCodePoints(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public CmdCodePoints(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public String doGet(VoidPointer target) {
         return _doGet__vP_const(this.object.pointer, target.object.pointer);
    }

    private native String _doGet__vP_const(long _pointer_, long target);

    /** **/
    public void doSet(VoidPointer target, String val) {
        _doSet__vpStringR(this.object.pointer, target.object.pointer,  val);
    }

    private native void _doSet__vpStringR(long _pointer_, long target, String val);

    /** **/
    public CmdCodePoints() {
         super( new org.xbig.base.InstancePointer(__createCmdCodePoints()), false);
    }

    private native static long __createCmdCodePoints();

}
protected static class CmdResolution extends org.xbig.base.NativeObject implements org.ogre4j.IFont.ICmdResolution {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public CmdResolution(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected CmdResolution(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public CmdResolution(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public String doGet(VoidPointer target) {
         return _doGet__vP_const(this.object.pointer, target.object.pointer);
    }

    private native String _doGet__vP_const(long _pointer_, long target);

    /** **/
    public void doSet(VoidPointer target, String val) {
        _doSet__vpStringR(this.object.pointer, target.object.pointer,  val);
    }

    private native void _doSet__vpStringR(long _pointer_, long target, String val);

    /** **/
    public CmdResolution() {
         super( new org.xbig.base.InstancePointer(__createCmdResolution()), false);
    }

    private native static long __createCmdResolution();

}
protected static class CmdSize extends org.xbig.base.NativeObject implements org.ogre4j.IFont.ICmdSize {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public CmdSize(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected CmdSize(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public CmdSize(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public String doGet(VoidPointer target) {
         return _doGet__vP_const(this.object.pointer, target.object.pointer);
    }

    private native String _doGet__vP_const(long _pointer_, long target);

    /** **/
    public void doSet(VoidPointer target, String val) {
        _doSet__vpStringR(this.object.pointer, target.object.pointer,  val);
    }

    private native void _doSet__vpStringR(long _pointer_, long target, String val);

    /** **/
    public CmdSize() {
         super( new org.xbig.base.InstancePointer(__createCmdSize()), false);
    }

    private native static long __createCmdSize();

}
protected static class CmdSource extends org.xbig.base.NativeObject implements org.ogre4j.IFont.ICmdSource {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public CmdSource(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected CmdSource(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public CmdSource(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public String doGet(VoidPointer target) {
         return _doGet__vP_const(this.object.pointer, target.object.pointer);
    }

    private native String _doGet__vP_const(long _pointer_, long target);

    /** **/
    public void doSet(VoidPointer target, String val) {
        _doSet__vpStringR(this.object.pointer, target.object.pointer,  val);
    }

    private native void _doSet__vpStringR(long _pointer_, long target, String val);

    /** **/
    public CmdSource() {
         super( new org.xbig.base.InstancePointer(__createCmdSource()), false);
    }

    private native static long __createCmdSource();

}
protected static class CmdType extends org.xbig.base.NativeObject implements org.ogre4j.IFont.ICmdType {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public CmdType(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected CmdType(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public CmdType(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public String doGet(VoidPointer target) {
         return _doGet__vP_const(this.object.pointer, target.object.pointer);
    }

    private native String _doGet__vP_const(long _pointer_, long target);

    /** **/
    public void doSet(VoidPointer target, String val) {
        _doSet__vpStringR(this.object.pointer, target.object.pointer,  val);
    }

    private native void _doSet__vpStringR(long _pointer_, long target, String val);

    /** **/
    public CmdType() {
         super( new org.xbig.base.InstancePointer(__createCmdType()), false);
    }

    private native static long __createCmdType();

}
public static class GlyphInfo extends org.xbig.base.NativeObject implements org.ogre4j.IFont.IGlyphInfo {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public GlyphInfo(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected GlyphInfo(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public GlyphInfo(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public GlyphInfo(long id, org.ogre4j.IFloatRect rect, float aspect) {
         super( new org.xbig.base.InstancePointer(__createGlyphInfo__CodePointvUVRectRRealv( id,  rect.getInstancePointer().pointer,  aspect)), false);
    }

    private native static long __createGlyphInfo__CodePointvUVRectRRealv(long id, long rect, float aspect);

    /** **/
    public long getcodePoint() {
         return _getcodePoint(this.object.pointer);
    }

    private native long _getcodePoint(long _pointer_);

    /** **/
    public void setcodePoint(long _jni_value_) {
        _setcodePoint(this.object.pointer, _jni_value_);
    }

    private native void _setcodePoint(long _pointer_, long _jni_value_);

    /** **/
    public void getuvRect(org.ogre4j.IFloatRect returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getuvRect(this.object.pointer)), false);
    }

    private native long _getuvRect(long _pointer_);

    /** **/
    public void setuvRect(org.ogre4j.IFloatRect _jni_value_) {
        _setuvRect(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setuvRect(long _pointer_, long _jni_value_);

    /** **/
    public float getaspectRatio() {
         return _getaspectRatio(this.object.pointer);
    }

    private native float _getaspectRatio(long _pointer_);

    /** **/
    public void setaspectRatio(float _jni_value_) {
        _setaspectRatio(this.object.pointer, _jni_value_);
    }

    private native void _setaspectRatio(long _pointer_, float _jni_value_);

}
public static class CodePointRange extends org.xbig.base.NativeObject implements org.ogre4j.IFont.ICodePointRange {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public CodePointRange(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected CodePointRange(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public CodePointRange(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public long getfirst() {
         return _getfirst(this.object.pointer);
    }

    private native long _getfirst(long _pointer_);

    /** **/
    public void setfirst(long _jni_value_) {
        _setfirst(this.object.pointer, _jni_value_);
    }

    private native void _setfirst(long _pointer_, long _jni_value_);

    /** **/
    public long getsecond() {
         return _getsecond(this.object.pointer);
    }

    private native long _getsecond(long _pointer_);

    /** **/
    public void setsecond(long _jni_value_) {
        _setsecond(this.object.pointer, _jni_value_);
    }

    private native void _setsecond(long _pointer_, long _jni_value_);

}
public static class CodePointRangeList extends org.xbig.base.NativeObject implements org.ogre4j.IFont.ICodePointRangeList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public CodePointRangeList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected CodePointRangeList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public CodePointRangeList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public CodePointRangeList() {
         super( new org.xbig.base.InstancePointer(__createCodePointRangeList()), false);
    }

    private native static long __createCodePointRangeList();

    /** **/
    public void assign(int num, org.ogre4j.IFont.ICodePointRange val) {
        _assign__ivOgre_Font_CodePointRangeR(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_Font_CodePointRangeR(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.IFont.ICodePointRange at(int loc) {
         return new org.ogre4j.Font.CodePointRange(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.IFont.ICodePointRange back() {
         return new org.ogre4j.Font.CodePointRange(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.IFont.ICodePointRange front() {
         return new org.ogre4j.Font.CodePointRange(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.IFont.ICodePointRange val) {
        _push_back__Ogre_Font_CodePointRangeR(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_Font_CodePointRangeR(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
protected static class CodePointMap extends org.xbig.base.NativeObject implements org.ogre4j.IFont.ICodePointMap {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public CodePointMap(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected CodePointMap(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public CodePointMap(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public CodePointMap() {
         super( new org.xbig.base.InstancePointer(__createCodePointMap()), false);
    }

    private native static long __createCodePointMap();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(long key) {
         return _count__IR(this.object.pointer, key);
    }

    private native int _count__IR(long _pointer_, long key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(long key) {
         return _erase__IR(this.object.pointer, key);
    }

    private native int _erase__IR(long _pointer_, long key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.IFont.IGlyphInfo get(long key) {
         return new org.ogre4j.Font.GlyphInfo(new InstancePointer(_get__IR(this.object.pointer, key)));
    }

    private native long _get__IR(long _pointer_, long key);

    /** **/
    public void insert(long key, org.ogre4j.IFont.IGlyphInfo value) {
        _insert__IROgre_Font_GlyphInfor(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__IROgre_Font_GlyphInfor(long _pointer_, long key, long value);

}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public Font(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected Font(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public Font(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** 
    Constructor. **/
    public Font(org.ogre4j.IResourceManager creator, String name, long handle, String group, boolean isManual, org.ogre4j.IManualResourceLoader loader) {
         super( new org.xbig.base.InstancePointer(__createFont__ResourceManagerpStringRResourceHandlevStringRbvManualResourceLoaderp( creator.getInstancePointer().pointer,  name,  handle,  group,  isManual,  loader.getInstancePointer().pointer)), false);
    }

    private native static long __createFont__ResourceManagerpStringRResourceHandlevStringRbvManualResourceLoaderp(long creator, String name, long handle, String group, boolean isManual, long loader);

    /** 
    Sets the type of font. Must be set before loading. **/
    public void setType(org.ogre4j.FontType ftype) {
        _setType__FontTypev(this.object.pointer, ftype.getValue());
    }

    private native void _setType__FontTypev(long _pointer_, int ftype);

    /** 
    Gets the type of font. **/
    public org.ogre4j.FontType getType() {
         return org.ogre4j.FontType.toEnum(_getType_const(this.object.pointer));
    }

    private native int _getType_const(long _pointer_);

    /** 
    Sets the source of the font. **/
    public void setSource(String source) {
        _setSource__StringR(this.object.pointer, source);
    }

    private native void _setSource__StringR(long _pointer_, String source);

    /** 
    Gets the source this font (either an image or a truetype font). **/
    public String getSource() {
         return _getSource_const(this.object.pointer);
    }

    private native String _getSource_const(long _pointer_);

    /** 
    Sets the size of a truetype font (only required for FT_TRUETYPE). **/
    public void setTrueTypeSize(float ttfSize) {
        _setTrueTypeSize__Realv(this.object.pointer, ttfSize);
    }

    private native void _setTrueTypeSize__Realv(long _pointer_, float ttfSize);

    /** 
    Gets the resolution (dpi) of the font used to generate the texture (only required for FT_TRUETYPE). **/
    public void setTrueTypeResolution(long ttfResolution) {
        _setTrueTypeResolution__uintv(this.object.pointer, ttfResolution);
    }

    private native void _setTrueTypeResolution__uintv(long _pointer_, long ttfResolution);

    /** 
    Gets the point size of the font used to generate the texture. **/
    public float getTrueTypeSize() {
         return _getTrueTypeSize_const(this.object.pointer);
    }

    private native float _getTrueTypeSize_const(long _pointer_);

    /** 
    Gets the resolution (dpi) of the font used to generate the texture. **/
    public long getTrueTypeResolution() {
         return _getTrueTypeResolution_const(this.object.pointer);
    }

    private native long _getTrueTypeResolution_const(long _pointer_);

    /** 
    Gets the maximum baseline distance of all glyphs used in the texture. **/
    public int getTrueTypeMaxBearingY() {
         return _getTrueTypeMaxBearingY_const(this.object.pointer);
    }

    private native int _getTrueTypeMaxBearingY_const(long _pointer_);

    /** 
    Returns the texture coordinates of the associated glyph. **/
    public org.ogre4j.IFloatRect getGlyphTexCoords(long id) {
         return new org.ogre4j.FloatRect(new InstancePointer(_getGlyphTexCoords__CodePointv_const(this.object.pointer, id)));
    }

    private native long _getGlyphTexCoords__CodePointv_const(long _pointer_, long id);

    /** 
    Sets the texture coordinates of a glyph. **/
    public void setGlyphTexCoords(long id, float u1, float v1, float u2, float v2, float textureAspect) {
        _setGlyphTexCoords__CodePointvRealvRealvRealvRealvRealv(this.object.pointer, id,  u1,  v1,  u2,  v2,  textureAspect);
    }

    private native void _setGlyphTexCoords__CodePointvRealvRealvRealvRealvRealv(long _pointer_, long id, float u1, float v1, float u2, float v2, float textureAspect);

    /** 
    Gets the aspect ratio (width / height) of this character. **/
    public float getGlyphAspectRatio(long id) {
         return _getGlyphAspectRatio__CodePointv_const(this.object.pointer, id);
    }

    private native float _getGlyphAspectRatio__CodePointv_const(long _pointer_, long id);

    /** 
    Sets the aspect ratio (width / height) of this character. **/
    public void setGlyphAspectRatio(long id, float ratio) {
        _setGlyphAspectRatio__CodePointvRealv(this.object.pointer, id,  ratio);
    }

    private native void _setGlyphAspectRatio__CodePointvRealv(long _pointer_, long id, float ratio);

    /** 
    Gets the information available for a glyph corresponding to a given code point, or throws an exception if it doesn't exist; **/
    public org.ogre4j.IFont.IGlyphInfo getGlyphInfo(long id) {
         return new org.ogre4j.Font.GlyphInfo(new InstancePointer(_getGlyphInfo__CodePointv_const(this.object.pointer, id)));
    }

    private native long _getGlyphInfo__CodePointv_const(long _pointer_, long id);

    /** 
    Adds a range of code points to the list of code point ranges to generate glyphs for, if this is a truetype based font. **/
    public void addCodePointRange(org.ogre4j.IFont.ICodePointRange range) {
        _addCodePointRange__CodePointRangeR(this.object.pointer, range.getInstancePointer().pointer);
    }

    private native void _addCodePointRange__CodePointRangeR(long _pointer_, long range);

    /** 
    Clear the list of code point ranges. **/
    public void clearCodePointRanges() {
        _clearCodePointRanges(this.object.pointer);
    }

    private native void _clearCodePointRanges(long _pointer_);

    /** 
    Get a const reference to the list of code point ranges to be used to generate glyphs from a truetype font. **/
    public org.ogre4j.IFont.ICodePointRangeList getCodePointRangeList() {
         return new org.ogre4j.Font.CodePointRangeList(new InstancePointer(_getCodePointRangeList_const(this.object.pointer)));
    }

    private native long _getCodePointRangeList_const(long _pointer_);

    /** **/
    public org.ogre4j.IMaterialPtr getMaterial_const() {
         return new org.ogre4j.MaterialPtr(new InstancePointer(_getMaterial_const_const(this.object.pointer)));
    }

    private native long _getMaterial_const_const(long _pointer_);

    /** 
    Gets the material generated for this font, as a weak reference. **/
    public org.ogre4j.IMaterialPtr getMaterial() {
         return new org.ogre4j.MaterialPtr(new InstancePointer(_getMaterial(this.object.pointer)));
    }

    private native long _getMaterial(long _pointer_);

    /** 
    Sets whether or not the colour of this font is antialiased as it is generated from a true type font. **/
    public void setAntialiasColour(boolean enabled) {
        _setAntialiasColour__bv(this.object.pointer, enabled);
    }

    private native void _setAntialiasColour__bv(long _pointer_, boolean enabled);

    /** 
    Gets whether or not the colour of this font is antialiased as it is generated from a true type font. **/
    public boolean getAntialiasColour() {
         return _getAntialiasColour_const(this.object.pointer);
    }

    private native boolean _getAntialiasColour_const(long _pointer_);

    /** 
    Implementation of , called when the  that this font creates needs to (re)load. **/
    public void loadResource(org.ogre4j.IResource resource) {
        _loadResource__Resourcep(this.object.pointer, resource.getInstancePointer().pointer);
    }

    private native void _loadResource__Resourcep(long _pointer_, long resource);

    /** 
    Prepares the resource for load, if it is not already. One can call  before , but this is not required as  will call  itself, if needed. When OGRE_THREAD_SUPPORT==1 both  and  are thread-safe. When OGRE_THREAD_SUPPORT==2 however, only  is thread-safe. The reason for this function is to allow a background thread to do some of the loading work, without requiring the whole render system to be thread-safe. The background thread would call  while the main render loop would later call . So long as  remains thread-safe, subclasses can arbitrarily split the work of loading a resource between  and . It is best to try and do as much work in , however, since this will leave less work for the main render thread to do and thus increase FPS. **/
    public void prepare() {
        _prepare(this.object.pointer);
    }

    private native void _prepare(long _pointer_);

    /** 
    Loads the resource, if it is not already. **/
    public void load(boolean backgroundThread) {
        _load__bv(this.object.pointer, backgroundThread);
    }

    private native void _load__bv(long _pointer_, boolean backgroundThread);

    /** 
    Reloads the resource, if it is already loaded. **/
    public void reload() {
        _reload(this.object.pointer);
    }

    private native void _reload(long _pointer_);

    /** 
    Returns true if the  is reloadable, false otherwise. **/
    public boolean isReloadable() {
         return _isReloadable_const(this.object.pointer);
    }

    private native boolean _isReloadable_const(long _pointer_);

    /** 
    Is this resource manually loaded? **/
    public boolean isManuallyLoaded() {
         return _isManuallyLoaded_const(this.object.pointer);
    }

    private native boolean _isManuallyLoaded_const(long _pointer_);

    /** 
    Unloads the resource; this is not permanent, the resource can be reloaded later if required. **/
    public void unload() {
        _unload(this.object.pointer);
    }

    private native void _unload(long _pointer_);

    /** 
    Retrieves info about the size of the resource. **/
    public int getSize() {
         return _getSize_const(this.object.pointer);
    }

    private native int _getSize_const(long _pointer_);

    /** 
    'Touches' the resource to indicate it has been used. **/
    public void touch() {
        _touch(this.object.pointer);
    }

    private native void _touch(long _pointer_);

    /** 
    Gets resource name. **/
    public String getName() {
         return _getName_const(this.object.pointer);
    }

    private native String _getName_const(long _pointer_);

    /** **/
    public long getHandle() {
         return _getHandle_const(this.object.pointer);
    }

    private native long _getHandle_const(long _pointer_);

    /** 
    Returns true if the  has been prepared, false otherwise. **/
    public boolean isPrepared() {
         return _isPrepared_const(this.object.pointer);
    }

    private native boolean _isPrepared_const(long _pointer_);

    /** 
    Returns true if the  has been loaded, false otherwise. **/
    public boolean isLoaded() {
         return _isLoaded_const(this.object.pointer);
    }

    private native boolean _isLoaded_const(long _pointer_);

    /** 
    Returns whether the resource is currently in the process of background loading. **/
    public boolean isLoading() {
         return _isLoading_const(this.object.pointer);
    }

    private native boolean _isLoading_const(long _pointer_);

    /** 
    Returns the current loading state. **/
    public org.ogre4j.Resource.LoadingState getLoadingState() {
         return org.ogre4j.Resource.LoadingState.toEnum(_getLoadingState_const(this.object.pointer));
    }

    private native int _getLoadingState_const(long _pointer_);

    /** 
    Returns whether this  has been earmarked for background loading. **/
    public boolean isBackgroundLoaded() {
         return _isBackgroundLoaded_const(this.object.pointer);
    }

    private native boolean _isBackgroundLoaded_const(long _pointer_);

    /** 
    Tells the resource whether it is background loaded or not. **/
    public void setBackgroundLoaded(boolean bl) {
        _setBackgroundLoaded__bv(this.object.pointer, bl);
    }

    private native void _setBackgroundLoaded__bv(long _pointer_, boolean bl);

    /** 
    Escalates the loading of a background loaded resource. **/
    public void escalateLoading() {
        _escalateLoading(this.object.pointer);
    }

    private native void _escalateLoading(long _pointer_);

    /** 
    Register a listener on this resource. **/
    public void addListener(org.ogre4j.IResource.IListener lis) {
        _addListener__Listenerp(this.object.pointer, lis.getInstancePointer().pointer);
    }

    private native void _addListener__Listenerp(long _pointer_, long lis);

    /** 
    Remove a listener on this resource. **/
    public void removeListener(org.ogre4j.IResource.IListener lis) {
        _removeListener__Listenerp(this.object.pointer, lis.getInstancePointer().pointer);
    }

    private native void _removeListener__Listenerp(long _pointer_, long lis);

    /** **/
    public String getGroup() {
         return _getGroup(this.object.pointer);
    }

    private native String _getGroup(long _pointer_);

    /** 
    Change the resource group ownership of a . **/
    public void changeGroupOwnership(String newGroup) {
        _changeGroupOwnership__StringR(this.object.pointer, newGroup);
    }

    private native void _changeGroupOwnership__StringR(long _pointer_, String newGroup);

    /** **/
    public org.ogre4j.IResourceManager getCreator() {
         return new org.ogre4j.ResourceManager(new InstancePointer(_getCreator(this.object.pointer)));
    }

    private native long _getCreator(long _pointer_);

    /** 
    Get the origin of this resource, e.g. a script file name. **/
    public String getOrigin() {
         return _getOrigin_const(this.object.pointer);
    }

    private native String _getOrigin_const(long _pointer_);

    /** **/
    public void _notifyOrigin(String origin) {
        __notifyOrigin__StringR(this.object.pointer, origin);
    }

    private native void __notifyOrigin__StringR(long _pointer_, String origin);

    /** 
    Returns the number of times this resource has changed state, which generally means the number of times it has been loaded. Objects that build derived data based on the resource can check this value against a copy they kept last time they built this derived data, in order to know whether it needs rebuilding. This is a nice way of monitoring changes without having a tightly-bound callback. **/
    public int getStateCount() {
         return _getStateCount_const(this.object.pointer);
    }

    private native int _getStateCount_const(long _pointer_);

    /** 
    Manually mark the state of this resource as having been changed. **/
    public void _dirtyState() {
        __dirtyState(this.object.pointer);
    }

    private native void __dirtyState(long _pointer_);

    /** 
    Firing of background loading complete event **/
    public void _fireBackgroundLoadingComplete() {
        __fireBackgroundLoadingComplete(this.object.pointer);
    }

    private native void __fireBackgroundLoadingComplete(long _pointer_);

    /** 
    Firing of background preparing complete event **/
    public void _fireBackgroundPreparingComplete() {
        __fireBackgroundPreparingComplete(this.object.pointer);
    }

    private native void __fireBackgroundPreparingComplete(long _pointer_);

    /** 
    Retrieves the parameter dictionary for this class. **/
    public org.ogre4j.IParamDictionary getParamDictionary() {
         return new org.ogre4j.ParamDictionary(new InstancePointer(_getParamDictionary(this.object.pointer)));
    }

    private native long _getParamDictionary(long _pointer_);

    /** **/
    public org.ogre4j.IParamDictionary getParamDictionary_const() {
         return new org.ogre4j.ParamDictionary(new InstancePointer(_getParamDictionary_const_const(this.object.pointer)));
    }

    private native long _getParamDictionary_const_const(long _pointer_);

    /** 
    Retrieves a list of parameters valid for this object. **/
    public org.ogre4j.IParameterList getParameters() {
         return new org.ogre4j.ParameterList(new InstancePointer(_getParameters_const(this.object.pointer)));
    }

    private native long _getParameters_const(long _pointer_);

    /** 
    Generic parameter setting method. **/
    public boolean setParameter(String name, String value) {
         return _setParameter__StringRStringR(this.object.pointer, name,  value);
    }

    private native boolean _setParameter__StringRStringR(long _pointer_, String name, String value);

    /** 
    Generic multiple parameter setting method. **/
    public void setParameterList(org.ogre4j.INameValuePairList paramList) {
        _setParameterList__NameValuePairListR(this.object.pointer, paramList.getInstancePointer().pointer);
    }

    private native void _setParameterList__NameValuePairListR(long _pointer_, long paramList);

    /** 
    Generic parameter retrieval method. **/
    public String getParameter(String name) {
         return _getParameter__StringR_const(this.object.pointer, name);
    }

    private native String _getParameter__StringR_const(long _pointer_, String name);

    /** 
    Method for copying this object's parameters to another object. **/
    public void copyParametersTo(org.ogre4j.IStringInterface dest) {
        _copyParametersTo__StringInterfacep_const(this.object.pointer, dest.getInstancePointer().pointer);
    }

    private native void _copyParametersTo__StringInterfacep_const(long _pointer_, long dest);

    /** 
    Cleans up the static 'msDictionary' required to reset , otherwise the containers are left with invalid pointers, which will lead to a crash as soon as one of the  implementers (e.g. ) initializes. **/
    public static void cleanupDictionary() {
        _cleanupDictionary();
    }

    private native static void _cleanupDictionary();

    /** 
    Called when a resource wishes to load. Note that this could get called in a background thread even in just a semithreaded ogre (OGRE_THREAD_SUPPORT==2). Thus, you must not access the rendersystem from this callback. Do that stuff in loadResource. **/
    public void prepareResource(org.ogre4j.IResource resource) {
        _prepareResource__Resourcep(this.object.pointer, resource.getInstancePointer().pointer);
    }

    private native void _prepareResource__Resourcep(long _pointer_, long resource);

}
