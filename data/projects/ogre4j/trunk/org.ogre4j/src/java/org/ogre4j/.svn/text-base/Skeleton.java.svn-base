/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class Skeleton extends org.xbig.base.NativeObject implements org.ogre4j.ISkeleton {
static { System.loadLibrary("ogre4j");}
public static class BoneList extends org.xbig.base.NativeObject implements org.ogre4j.ISkeleton.IBoneList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public BoneList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected BoneList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public BoneList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public BoneList() {
         super( new org.xbig.base.InstancePointer(__createBoneList()), false);
    }

    private native static long __createBoneList();

    /** **/
    public void assign(int num, org.ogre4j.IBone val) {
        _assign__ivOgre_BoneP(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_BoneP(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.IBone at(int loc) {
         return new org.ogre4j.Bone(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.IBone back() {
         return new org.ogre4j.Bone(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.IBone front() {
         return new org.ogre4j.Bone(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.IBone val) {
        _push_back__Ogre_BoneP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_BoneP(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
public static class BoneIterator extends org.xbig.base.NativeObject implements org.ogre4j.ISkeleton.IBoneIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public BoneIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected BoneIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public BoneIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public BoneIterator(org.ogre4j.ISkeleton.IBoneList c) {
         super( new org.xbig.base.InstancePointer(__createBoneIterator__Ogre_Skeleton_BoneListr( c.getInstancePointer().pointer)), false);
    }

    private native static long __createBoneIterator__Ogre_Skeleton_BoneListr(long c);

    /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public org.ogre4j.IBone getNext() {
         return new org.ogre4j.Bone(new InstancePointer(_getNext(this.object.pointer)));
    }

    private native long _getNext(long _pointer_);

    /** **/
    public org.ogre4j.IBone peekNext() {
         return new org.ogre4j.Bone(new InstancePointer(_peekNext(this.object.pointer)));
    }

    private native long _peekNext(long _pointer_);

    /** **/
    public NativeObjectPointer<org.ogre4j.IBone> peekNextPtr() {
         return new NativeObjectPointer<org.ogre4j.IBone>(new InstancePointer(_peekNextPtr(this.object.pointer)));
    }

    private native long _peekNextPtr(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext(this.object.pointer);
    }

    private native void _moveNext(long _pointer_);

}
public static class LinkedSkeletonAnimSourceList extends org.xbig.base.NativeObject implements org.ogre4j.ISkeleton.ILinkedSkeletonAnimSourceList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public LinkedSkeletonAnimSourceList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected LinkedSkeletonAnimSourceList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public LinkedSkeletonAnimSourceList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public LinkedSkeletonAnimSourceList() {
         super( new org.xbig.base.InstancePointer(__createLinkedSkeletonAnimSourceList()), false);
    }

    private native static long __createLinkedSkeletonAnimSourceList();

    /** **/
    public void assign(int num, org.ogre4j.ILinkedSkeletonAnimationSource val) {
        _assign__ivOgre_LinkedSkeletonAnimationSourceR(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_LinkedSkeletonAnimationSourceR(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.ILinkedSkeletonAnimationSource at(int loc) {
         return new org.ogre4j.LinkedSkeletonAnimationSource(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.ILinkedSkeletonAnimationSource back() {
         return new org.ogre4j.LinkedSkeletonAnimationSource(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.ILinkedSkeletonAnimationSource front() {
         return new org.ogre4j.LinkedSkeletonAnimationSource(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.ILinkedSkeletonAnimationSource val) {
        _push_back__Ogre_LinkedSkeletonAnimationSourceR(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_LinkedSkeletonAnimationSourceR(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
public static class LinkedSkeletonAnimSourceIterator extends org.xbig.base.NativeObject implements org.ogre4j.ISkeleton.ILinkedSkeletonAnimSourceIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public LinkedSkeletonAnimSourceIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected LinkedSkeletonAnimSourceIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public LinkedSkeletonAnimSourceIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public LinkedSkeletonAnimSourceIterator(org.ogre4j.ISkeleton.ILinkedSkeletonAnimSourceList c) {
         super( new org.xbig.base.InstancePointer(__createLinkedSkeletonAnimSourceIterator__Ogre_Skeleton_LinkedSkeletonAnimSourceListR( c.getInstancePointer().pointer)), false);
    }

    private native static long __createLinkedSkeletonAnimSourceIterator__Ogre_Skeleton_LinkedSkeletonAnimSourceListR(long c);

    /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public void getNext(org.ogre4j.ILinkedSkeletonAnimationSource returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getNext(this.object.pointer)), false);
    }

    private native long _getNext(long _pointer_);

    /** **/
    public void peekNext(org.ogre4j.ILinkedSkeletonAnimationSource returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_peekNext_const(this.object.pointer)), false);
    }

    private native long _peekNext_const(long _pointer_);

    /** **/
    public org.ogre4j.ILinkedSkeletonAnimationSource peekNextPtr() {
         return new org.ogre4j.LinkedSkeletonAnimationSource(new InstancePointer(_peekNextPtr_const(this.object.pointer)));
    }

    private native long _peekNextPtr_const(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext_const(this.object.pointer);
    }

    private native void _moveNext_const(long _pointer_);

}
public static class BoneHandleMap extends org.xbig.base.NativeObject implements org.ogre4j.ISkeleton.IBoneHandleMap {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public BoneHandleMap(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected BoneHandleMap(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public BoneHandleMap(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public BoneHandleMap() {
         super( new org.xbig.base.InstancePointer(__createBoneHandleMap()), false);
    }

    private native static long __createBoneHandleMap();

    /** **/
    public void assign(int num, int val) {
        _assign__ivHR(this.object.pointer, num,  val);
    }

    private native void _assign__ivHR(long _pointer_, int num, int val);

    /** **/
    public IntegerPointer at(int loc) {
         return new IntegerPointer(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public IntegerPointer back() {
         return new IntegerPointer(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public IntegerPointer front() {
         return new IntegerPointer(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(int val) {
        _push_back__HR(this.object.pointer, val);
    }

    private native void _push_back__HR(long _pointer_, int val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
protected static class BoneListByName extends org.xbig.base.NativeObject implements org.ogre4j.ISkeleton.IBoneListByName {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public BoneListByName(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected BoneListByName(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public BoneListByName(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public BoneListByName() {
         super( new org.xbig.base.InstancePointer(__createBoneListByName()), false);
    }

    private native static long __createBoneListByName();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.IBone get(String key) {
         return new org.ogre4j.Bone(new InstancePointer(_get__sR(this.object.pointer, key)));
    }

    private native long _get__sR(long _pointer_, String key);

    /** **/
    public void insert(String key, org.ogre4j.IBone value) {
        _insert__sROgre_Bonep(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__sROgre_Bonep(long _pointer_, String key, long value);

}
protected static class BoneSet extends org.xbig.base.NativeObject implements org.ogre4j.ISkeleton.IBoneSet {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public BoneSet(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected BoneSet(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public BoneSet(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public BoneSet() {
         super( new org.xbig.base.InstancePointer(__createBoneSet()), false);
    }

    private native static long __createBoneSet();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(org.ogre4j.IBone key) {
         return _count__Ogre_BoneP(this.object.pointer, key.getInstancePointer().pointer);
    }

    private native int _count__Ogre_BoneP(long _pointer_, long key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(org.ogre4j.IBone key) {
         return _erase__Ogre_BoneP(this.object.pointer, key.getInstancePointer().pointer);
    }

    private native int _erase__Ogre_BoneP(long _pointer_, long key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

}
protected static class AnimationList extends org.xbig.base.NativeObject implements org.ogre4j.ISkeleton.IAnimationList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public AnimationList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected AnimationList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public AnimationList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public AnimationList() {
         super( new org.xbig.base.InstancePointer(__createAnimationList()), false);
    }

    private native static long __createAnimationList();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.IAnimation get(String key) {
         return new org.ogre4j.Animation(new InstancePointer(_get__sR(this.object.pointer, key)));
    }

    private native long _get__sR(long _pointer_, String key);

    /** **/
    public void insert(String key, org.ogre4j.IAnimation value) {
        _insert__sROgre_Animationp(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__sROgre_Animationp(long _pointer_, String key, long value);

}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public Skeleton(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected Skeleton(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public Skeleton(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** 
    Constructor, don't call directly, use . **/
    public Skeleton(org.ogre4j.IResourceManager creator, String name, long handle, String group, boolean isManual, org.ogre4j.IManualResourceLoader loader) {
         super( new org.xbig.base.InstancePointer(__createSkeleton__ResourceManagerpStringRResourceHandlevStringRbvManualResourceLoaderp( creator.getInstancePointer().pointer,  name,  handle,  group,  isManual,  loader.getInstancePointer().pointer)), false);
    }

    private native static long __createSkeleton__ResourceManagerpStringRResourceHandlevStringRbvManualResourceLoaderp(long creator, String name, long handle, String group, boolean isManual, long loader);

    /** 
    Creates a brand new  owned by this . **/
    public org.ogre4j.IBone createBone() {
         return new org.ogre4j.Bone(new InstancePointer(_createBone(this.object.pointer)));
    }

    private native long _createBone(long _pointer_);

    /** 
    Creates a brand new  owned by this . **/
    public org.ogre4j.IBone createBone(int handle) {
         return new org.ogre4j.Bone(new InstancePointer(_createBone__Hv(this.object.pointer, handle)));
    }

    private native long _createBone__Hv(long _pointer_, int handle);

    /** 
    Creates a brand new  owned by this . **/
    public org.ogre4j.IBone createBone(String name) {
         return new org.ogre4j.Bone(new InstancePointer(_createBone__StringR(this.object.pointer, name)));
    }

    private native long _createBone__StringR(long _pointer_, String name);

    /** 
    Creates a brand new  owned by this . **/
    public org.ogre4j.IBone createBone(String name, int handle) {
         return new org.ogre4j.Bone(new InstancePointer(_createBone__StringRHv(this.object.pointer, name,  handle)));
    }

    private native long _createBone__StringRHv(long _pointer_, String name, int handle);

    /** 
    Returns the number of bones in this skeleton. **/
    public int getNumBones() {
         return _getNumBones_const(this.object.pointer);
    }

    private native int _getNumBones_const(long _pointer_);

    /** 
    Gets the root bone of the skeleton: deprecated in favour of getRootBoneIterator. **/
    public org.ogre4j.IBone getRootBone() {
         return new org.ogre4j.Bone(new InstancePointer(_getRootBone_const(this.object.pointer)));
    }

    private native long _getRootBone_const(long _pointer_);

    /** **/
    public void getRootBoneIterator(org.ogre4j.ISkeleton.IBoneIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getRootBoneIterator(this.object.pointer)), false);
    }

    private native long _getRootBoneIterator(long _pointer_);

    /** **/
    public void getBoneIterator(org.ogre4j.ISkeleton.IBoneIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getBoneIterator(this.object.pointer)), false);
    }

    private native long _getBoneIterator(long _pointer_);

    /** 
    Gets a bone by it's handle. **/
    public org.ogre4j.IBone getBone(int handle) {
         return new org.ogre4j.Bone(new InstancePointer(_getBone__Hv_const(this.object.pointer, handle)));
    }

    private native long _getBone__Hv_const(long _pointer_, int handle);

    /** 
    Gets a bone by it's name. **/
    public org.ogre4j.IBone getBone(String name) {
         return new org.ogre4j.Bone(new InstancePointer(_getBone__StringR_const(this.object.pointer, name)));
    }

    private native long _getBone__StringR_const(long _pointer_, String name);

    /** 
    Returns whether this skeleton contains the named bone. **/
    public boolean hasBone(String name) {
         return _hasBone__StringR_const(this.object.pointer, name);
    }

    private native boolean _hasBone__StringR_const(long _pointer_, String name);

    /** 
    Sets the current position / orientation to be the 'binding pose' i.e. the layout in which bones were originally bound to a mesh. **/
    public void setBindingPose() {
        _setBindingPose(this.object.pointer);
    }

    private native void _setBindingPose(long _pointer_);

    /** 
    Resets the position and orientation of all bones in this skeleton to their original binding position. **/
    public void reset(boolean resetManualBones) {
        _reset__bv(this.object.pointer, resetManualBones);
    }

    private native void _reset__bv(long _pointer_, boolean resetManualBones);

    /** 
    Creates a new  object for animating this skeleton. **/
    public org.ogre4j.IAnimation createAnimation(String name, float length) {
         return new org.ogre4j.Animation(new InstancePointer(_createAnimation__StringRRealv(this.object.pointer, name,  length)));
    }

    private native long _createAnimation__StringRRealv(long _pointer_, String name, float length);

    /** 
    Returns the named  object. **/
    public org.ogre4j.IAnimation getAnimation(String name, NativeObjectPointer<org.ogre4j.ILinkedSkeletonAnimationSource> linker) {
         return new org.ogre4j.Animation(new InstancePointer(_getAnimation__StringRLinkedSkeletonAnimationSourceP_const(this.object.pointer, name,  linker.getInstancePointer().pointer)));
    }

    private native long _getAnimation__StringRLinkedSkeletonAnimationSourceP_const(long _pointer_, String name, long linker);

    /** **/
    public org.ogre4j.IAnimation _getAnimationImpl(String name, NativeObjectPointer<org.ogre4j.ILinkedSkeletonAnimationSource> linker) {
         return new org.ogre4j.Animation(new InstancePointer(__getAnimationImpl__StringRLinkedSkeletonAnimationSourceP_const(this.object.pointer, name,  linker.getInstancePointer().pointer)));
    }

    private native long __getAnimationImpl__StringRLinkedSkeletonAnimationSourceP_const(long _pointer_, String name, long linker);

    /** 
    Returns whether this skeleton contains the named animation. **/
    public boolean hasAnimation(String name) {
         return _hasAnimation__StringR(this.object.pointer, name);
    }

    private native boolean _hasAnimation__StringR(long _pointer_, String name);

    /** 
    Removes an  from this skeleton. **/
    public void removeAnimation(String name) {
        _removeAnimation__StringR(this.object.pointer, name);
    }

    private native void _removeAnimation__StringR(long _pointer_, String name);

    /** 
    Changes the state of the skeleton to reflect the application of the passed in collection of animations. **/
    public void setAnimationState(org.ogre4j.IAnimationStateSet animSet) {
        _setAnimationState__AnimationStateSetR(this.object.pointer, animSet.getInstancePointer().pointer);
    }

    private native void _setAnimationState__AnimationStateSetR(long _pointer_, long animSet);

    /** 
    Initialise an animation set suitable for use with this skeleton. **/
    public void _initAnimationState(org.ogre4j.IAnimationStateSet animSet) {
        __initAnimationState__AnimationStateSetp(this.object.pointer, animSet.getInstancePointer().pointer);
    }

    private native void __initAnimationState__AnimationStateSetp(long _pointer_, long animSet);

    /** 
    Refresh an animation set suitable for use with this skeleton. **/
    public void _refreshAnimationState(org.ogre4j.IAnimationStateSet animSet) {
        __refreshAnimationState__AnimationStateSetp(this.object.pointer, animSet.getInstancePointer().pointer);
    }

    private native void __refreshAnimationState__AnimationStateSetp(long _pointer_, long animSet);

    /** 
    Populates the passed in array with the bone matrices based on the current position. **/
    public void _getBoneMatrices(org.ogre4j.IMatrix4 pMatrices) {
        __getBoneMatrices__Matrix4p(this.object.pointer, pMatrices.getInstancePointer().pointer);
    }

    private native void __getBoneMatrices__Matrix4p(long _pointer_, long pMatrices);

    /** 
    Gets the number of animations on this skeleton. **/
    public int getNumAnimations() {
         return _getNumAnimations_const(this.object.pointer);
    }

    private native int _getNumAnimations_const(long _pointer_);

    /** 
    Gets a single animation by index. **/
    public org.ogre4j.IAnimation getAnimation(int index) {
         return new org.ogre4j.Animation(new InstancePointer(_getAnimation__Hv_const(this.object.pointer, index)));
    }

    private native long _getAnimation__Hv_const(long _pointer_, int index);

    /** 
    Gets the animation blending mode which this skeleton will use. **/
    public org.ogre4j.SkeletonAnimationBlendMode getBlendMode() {
         return org.ogre4j.SkeletonAnimationBlendMode.toEnum(_getBlendMode_const(this.object.pointer));
    }

    private native int _getBlendMode_const(long _pointer_);

    /** 
    Sets the animation blending mode this skeleton will use. **/
    public void setBlendMode(org.ogre4j.SkeletonAnimationBlendMode state) {
        _setBlendMode__SkeletonAnimationBlendModev(this.object.pointer, state.getValue());
    }

    private native void _setBlendMode__SkeletonAnimationBlendModev(long _pointer_, int state);

    /** **/
    public void _updateTransforms() {
        __updateTransforms(this.object.pointer);
    }

    private native void __updateTransforms(long _pointer_);

    /** 
    Optimise all of this skeleton's animations. **/
    public void optimiseAllAnimations(boolean preservingIdentityNodeTracks) {
        _optimiseAllAnimations__bv(this.object.pointer, preservingIdentityNodeTracks);
    }

    private native void _optimiseAllAnimations__bv(long _pointer_, boolean preservingIdentityNodeTracks);

    /** 
    Allows you to use the animations from another  object to animate this skeleton. 
You cannot set up cyclic relationships, e.g. SkeletonA uses SkeletonB's animations, and SkeletonB uses SkeletonA's animations. This is because it would set up a circular dependency which would prevent proper unloading - make one of the skeletons the 'master' in this case. **/
    public void addLinkedSkeletonAnimationSource(String skelName, float scale) {
        _addLinkedSkeletonAnimationSource__StringRRealv(this.object.pointer, skelName,  scale);
    }

    private native void _addLinkedSkeletonAnimationSource__StringRRealv(long _pointer_, String skelName, float scale);

    /** **/
    public void removeAllLinkedSkeletonAnimationSources() {
        _removeAllLinkedSkeletonAnimationSources(this.object.pointer);
    }

    private native void _removeAllLinkedSkeletonAnimationSources(long _pointer_);

    /** **/
    public void getLinkedSkeletonAnimationSourceIterator(org.ogre4j.ISkeleton.ILinkedSkeletonAnimSourceIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getLinkedSkeletonAnimationSourceIterator_const(this.object.pointer)), false);
    }

    private native long _getLinkedSkeletonAnimationSourceIterator_const(long _pointer_);

    /** **/
    public void _notifyManualBonesDirty() {
        __notifyManualBonesDirty(this.object.pointer);
    }

    private native void __notifyManualBonesDirty(long _pointer_);

    /** **/
    public void _notifyManualBoneStateChange(org.ogre4j.IBone bone) {
        __notifyManualBoneStateChange__Bonep(this.object.pointer, bone.getInstancePointer().pointer);
    }

    private native void __notifyManualBoneStateChange__Bonep(long _pointer_, long bone);

    /** **/
    public boolean getManualBonesDirty() {
         return _getManualBonesDirty_const(this.object.pointer);
    }

    private native boolean _getManualBonesDirty_const(long _pointer_);

    /** **/
    public boolean hasManualBones() {
         return _hasManualBones_const(this.object.pointer);
    }

    private native boolean _hasManualBones_const(long _pointer_);

    /** 
    Merge animations from another  object into this skeleton. **/
    public void _mergeSkeletonAnimations(org.ogre4j.ISkeleton source, org.ogre4j.ISkeleton.IBoneHandleMap boneHandleMap, org.ogre4j.IStringVector animations) {
        __mergeSkeletonAnimations__SkeletonPBoneHandleMapRStringVectorR(this.object.pointer, source.getInstancePointer().pointer,  boneHandleMap.getInstancePointer().pointer,  animations.getInstancePointer().pointer);
    }

    private native void __mergeSkeletonAnimations__SkeletonPBoneHandleMapRStringVectorR(long _pointer_, long source, long boneHandleMap, long animations);

    /** 
    Build the bone handle map to use with . **/
    public void _buildMapBoneByHandle(org.ogre4j.ISkeleton source, org.ogre4j.ISkeleton.IBoneHandleMap boneHandleMap) {
        __buildMapBoneByHandle__SkeletonPBoneHandleMapr_const(this.object.pointer, source.getInstancePointer().pointer,  boneHandleMap.getInstancePointer().pointer);
    }

    private native void __buildMapBoneByHandle__SkeletonPBoneHandleMapr_const(long _pointer_, long source, long boneHandleMap);

    /** 
    Build the bone handle map to use with . **/
    public void _buildMapBoneByName(org.ogre4j.ISkeleton source, org.ogre4j.ISkeleton.IBoneHandleMap boneHandleMap) {
        __buildMapBoneByName__SkeletonPBoneHandleMapr_const(this.object.pointer, source.getInstancePointer().pointer,  boneHandleMap.getInstancePointer().pointer);
    }

    private native void __buildMapBoneByName__SkeletonPBoneHandleMapr_const(long _pointer_, long source, long boneHandleMap);

    /** 
    Prepares the resource for load, if it is not already. One can call  before , but this is not required as  will call  itself, if needed. When OGRE_THREAD_SUPPORT==1 both  and  are thread-safe. When OGRE_THREAD_SUPPORT==2 however, only  is thread-safe. The reason for this function is to allow a background thread to do some of the loading work, without requiring the whole render system to be thread-safe. The background thread would call  while the main render loop would later call . So long as  remains thread-safe, subclasses can arbitrarily split the work of loading a resource between  and . It is best to try and do as much work in , however, since this will leave less work for the main render thread to do and thus increase FPS. **/
    public void prepare() {
        _prepare(this.object.pointer);
    }

    private native void _prepare(long _pointer_);

    /** 
    Loads the resource, if it is not already. **/
    public void load(boolean backgroundThread) {
        _load__bv(this.object.pointer, backgroundThread);
    }

    private native void _load__bv(long _pointer_, boolean backgroundThread);

    /** 
    Reloads the resource, if it is already loaded. **/
    public void reload() {
        _reload(this.object.pointer);
    }

    private native void _reload(long _pointer_);

    /** 
    Returns true if the  is reloadable, false otherwise. **/
    public boolean isReloadable() {
         return _isReloadable_const(this.object.pointer);
    }

    private native boolean _isReloadable_const(long _pointer_);

    /** 
    Is this resource manually loaded? **/
    public boolean isManuallyLoaded() {
         return _isManuallyLoaded_const(this.object.pointer);
    }

    private native boolean _isManuallyLoaded_const(long _pointer_);

    /** 
    Unloads the resource; this is not permanent, the resource can be reloaded later if required. **/
    public void unload() {
        _unload(this.object.pointer);
    }

    private native void _unload(long _pointer_);

    /** 
    Retrieves info about the size of the resource. **/
    public int getSize() {
         return _getSize_const(this.object.pointer);
    }

    private native int _getSize_const(long _pointer_);

    /** 
    'Touches' the resource to indicate it has been used. **/
    public void touch() {
        _touch(this.object.pointer);
    }

    private native void _touch(long _pointer_);

    /** 
    Gets resource name. **/
    public String getName() {
         return _getName_const(this.object.pointer);
    }

    private native String _getName_const(long _pointer_);

    /** **/
    public long getHandle() {
         return _getHandle_const(this.object.pointer);
    }

    private native long _getHandle_const(long _pointer_);

    /** 
    Returns true if the  has been prepared, false otherwise. **/
    public boolean isPrepared() {
         return _isPrepared_const(this.object.pointer);
    }

    private native boolean _isPrepared_const(long _pointer_);

    /** 
    Returns true if the  has been loaded, false otherwise. **/
    public boolean isLoaded() {
         return _isLoaded_const(this.object.pointer);
    }

    private native boolean _isLoaded_const(long _pointer_);

    /** 
    Returns whether the resource is currently in the process of background loading. **/
    public boolean isLoading() {
         return _isLoading_const(this.object.pointer);
    }

    private native boolean _isLoading_const(long _pointer_);

    /** 
    Returns the current loading state. **/
    public org.ogre4j.Resource.LoadingState getLoadingState() {
         return org.ogre4j.Resource.LoadingState.toEnum(_getLoadingState_const(this.object.pointer));
    }

    private native int _getLoadingState_const(long _pointer_);

    /** 
    Returns whether this  has been earmarked for background loading. **/
    public boolean isBackgroundLoaded() {
         return _isBackgroundLoaded_const(this.object.pointer);
    }

    private native boolean _isBackgroundLoaded_const(long _pointer_);

    /** 
    Tells the resource whether it is background loaded or not. **/
    public void setBackgroundLoaded(boolean bl) {
        _setBackgroundLoaded__bv(this.object.pointer, bl);
    }

    private native void _setBackgroundLoaded__bv(long _pointer_, boolean bl);

    /** 
    Escalates the loading of a background loaded resource. **/
    public void escalateLoading() {
        _escalateLoading(this.object.pointer);
    }

    private native void _escalateLoading(long _pointer_);

    /** 
    Register a listener on this resource. **/
    public void addListener(org.ogre4j.IResource.IListener lis) {
        _addListener__Listenerp(this.object.pointer, lis.getInstancePointer().pointer);
    }

    private native void _addListener__Listenerp(long _pointer_, long lis);

    /** 
    Remove a listener on this resource. **/
    public void removeListener(org.ogre4j.IResource.IListener lis) {
        _removeListener__Listenerp(this.object.pointer, lis.getInstancePointer().pointer);
    }

    private native void _removeListener__Listenerp(long _pointer_, long lis);

    /** **/
    public String getGroup() {
         return _getGroup(this.object.pointer);
    }

    private native String _getGroup(long _pointer_);

    /** 
    Change the resource group ownership of a . **/
    public void changeGroupOwnership(String newGroup) {
        _changeGroupOwnership__StringR(this.object.pointer, newGroup);
    }

    private native void _changeGroupOwnership__StringR(long _pointer_, String newGroup);

    /** **/
    public org.ogre4j.IResourceManager getCreator() {
         return new org.ogre4j.ResourceManager(new InstancePointer(_getCreator(this.object.pointer)));
    }

    private native long _getCreator(long _pointer_);

    /** 
    Get the origin of this resource, e.g. a script file name. **/
    public String getOrigin() {
         return _getOrigin_const(this.object.pointer);
    }

    private native String _getOrigin_const(long _pointer_);

    /** **/
    public void _notifyOrigin(String origin) {
        __notifyOrigin__StringR(this.object.pointer, origin);
    }

    private native void __notifyOrigin__StringR(long _pointer_, String origin);

    /** 
    Returns the number of times this resource has changed state, which generally means the number of times it has been loaded. Objects that build derived data based on the resource can check this value against a copy they kept last time they built this derived data, in order to know whether it needs rebuilding. This is a nice way of monitoring changes without having a tightly-bound callback. **/
    public int getStateCount() {
         return _getStateCount_const(this.object.pointer);
    }

    private native int _getStateCount_const(long _pointer_);

    /** 
    Manually mark the state of this resource as having been changed. **/
    public void _dirtyState() {
        __dirtyState(this.object.pointer);
    }

    private native void __dirtyState(long _pointer_);

    /** 
    Firing of background loading complete event **/
    public void _fireBackgroundLoadingComplete() {
        __fireBackgroundLoadingComplete(this.object.pointer);
    }

    private native void __fireBackgroundLoadingComplete(long _pointer_);

    /** 
    Firing of background preparing complete event **/
    public void _fireBackgroundPreparingComplete() {
        __fireBackgroundPreparingComplete(this.object.pointer);
    }

    private native void __fireBackgroundPreparingComplete(long _pointer_);

    /** 
    Retrieves the parameter dictionary for this class. **/
    public org.ogre4j.IParamDictionary getParamDictionary() {
         return new org.ogre4j.ParamDictionary(new InstancePointer(_getParamDictionary(this.object.pointer)));
    }

    private native long _getParamDictionary(long _pointer_);

    /** **/
    public org.ogre4j.IParamDictionary getParamDictionary_const() {
         return new org.ogre4j.ParamDictionary(new InstancePointer(_getParamDictionary_const_const(this.object.pointer)));
    }

    private native long _getParamDictionary_const_const(long _pointer_);

    /** 
    Retrieves a list of parameters valid for this object. **/
    public org.ogre4j.IParameterList getParameters() {
         return new org.ogre4j.ParameterList(new InstancePointer(_getParameters_const(this.object.pointer)));
    }

    private native long _getParameters_const(long _pointer_);

    /** 
    Generic parameter setting method. **/
    public boolean setParameter(String name, String value) {
         return _setParameter__StringRStringR(this.object.pointer, name,  value);
    }

    private native boolean _setParameter__StringRStringR(long _pointer_, String name, String value);

    /** 
    Generic multiple parameter setting method. **/
    public void setParameterList(org.ogre4j.INameValuePairList paramList) {
        _setParameterList__NameValuePairListR(this.object.pointer, paramList.getInstancePointer().pointer);
    }

    private native void _setParameterList__NameValuePairListR(long _pointer_, long paramList);

    /** 
    Generic parameter retrieval method. **/
    public String getParameter(String name) {
         return _getParameter__StringR_const(this.object.pointer, name);
    }

    private native String _getParameter__StringR_const(long _pointer_, String name);

    /** 
    Method for copying this object's parameters to another object. **/
    public void copyParametersTo(org.ogre4j.IStringInterface dest) {
        _copyParametersTo__StringInterfacep_const(this.object.pointer, dest.getInstancePointer().pointer);
    }

    private native void _copyParametersTo__StringInterfacep_const(long _pointer_, long dest);

    /** 
    Cleans up the static 'msDictionary' required to reset , otherwise the containers are left with invalid pointers, which will lead to a crash as soon as one of the  implementers (e.g. ) initializes. **/
    public static void cleanupDictionary() {
        _cleanupDictionary();
    }

    private native static void _cleanupDictionary();

}
