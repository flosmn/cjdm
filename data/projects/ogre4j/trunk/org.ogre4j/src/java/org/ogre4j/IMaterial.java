/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public interface IMaterial extends INativeObject, org.ogre4j.IResource {

public interface ILodDistanceList extends INativeObject, org.std.Ivector< Float > {

    /** **/
    public void assign(int num, float val);

    /** **/
    public FloatPointer at(int loc);

    /** **/
    public FloatPointer back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public FloatPointer front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(float val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
public interface ILodDistanceIterator extends INativeObject, org.ogre4j.IConstVectorIterator< org.ogre4j.IMaterial.ILodDistanceList > {

    /** **/
    public boolean hasMoreElements();

    /** **/
    public float getNext();

    /** **/
    public float peekNext();

    /** **/
    public FloatPointer peekNextPtr();

    /** **/
    public void moveNext();

}
public interface ITechniqueIterator extends INativeObject, org.ogre4j.IVectorIterator< org.ogre4j.IMaterial.ITechniques > {

    /** **/
    public boolean hasMoreElements();

    /** **/
    public org.ogre4j.ITechnique getNext();

    /** **/
    public org.ogre4j.ITechnique peekNext();

    /** **/
    public NativeObjectPointer<org.ogre4j.ITechnique> peekNextPtr();

    /** **/
    public void moveNext();

}
public interface ITechniques extends INativeObject, org.std.Ivector< org.ogre4j.ITechnique > {

    /** **/
    public void assign(int num, org.ogre4j.ITechnique val);

    /** **/
    public org.ogre4j.ITechnique at(int loc);

    /** **/
    public org.ogre4j.ITechnique back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public org.ogre4j.ITechnique front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(org.ogre4j.ITechnique val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
public interface ILodTechniques extends INativeObject, org.std.Imap< Integer, org.ogre4j.ITechnique > {

    /** **/
    public void clear();

    /** **/
    public int count(int key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(int key);

    /** **/
    public int max_size();

    /** **/
    public int size();

    /** **/
    public org.ogre4j.ITechnique get(int key);

    /** **/
    public void insert(int key, org.ogre4j.ITechnique value);

}
public interface IBestTechniquesBySchemeList extends INativeObject, org.std.Imap< Integer, org.ogre4j.IMaterial.ILodTechniques > {

    /** **/
    public void clear();

    /** **/
    public int count(int key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(int key);

    /** **/
    public int max_size();

    /** **/
    public int size();

    /** **/
    public org.ogre4j.IMaterial.ILodTechniques get(int key);

    /** **/
    public void insert(int key, org.ogre4j.IMaterial.ILodTechniques value);

}
    /** 
    Assignment operator to allow easy copying between materials. **/
    public org.ogre4j.IMaterial operatorAssignment(org.ogre4j.IMaterial rhs);

    /** 
    Determines if the material has any transparency with the rest of the scene (derived from whether any Techniques say they involve transparency). **/
    public boolean isTransparent();

    /** 
    Sets whether objects using this material will receive shadows. **/
    public void setReceiveShadows(boolean enabled);

    /** 
    Returns whether or not objects using this material will receive shadows. **/
    public boolean getReceiveShadows();

    /** 
    Sets whether objects using this material be classified as opaque to the shadow caster system. **/
    public void setTransparencyCastsShadows(boolean enabled);

    /** 
    Returns whether or not objects using this material be classified as opaque to the shadow caster system. **/
    public boolean getTransparencyCastsShadows();

    /** 
    Creates a new  for this . **/
    public org.ogre4j.ITechnique createTechnique();

    /** 
    Gets the indexed technique. **/
    public org.ogre4j.ITechnique getTechnique(int index);

    /** 
    searches for the named technique. Return 0 if technique with name is not found **/
    public org.ogre4j.ITechnique getTechnique(String name);

    /** 
    Retrieves the number of techniques. **/
    public int getNumTechniques();

    /** 
    Removes the technique at the given index. **/
    public void removeTechnique(int index);

    /** 
    Removes all the techniques in this . **/
    public void removeAllTechniques();

    /** 
    Get an iterator over the Techniques in this . **/
    public void getTechniqueIterator(org.ogre4j.IMaterial.ITechniqueIterator returnValue);

    /** 
    Gets an iterator over all the Techniques which are supported by the current card. **/
    public void getSupportedTechniqueIterator(org.ogre4j.IMaterial.ITechniqueIterator returnValue);

    /** 
    Gets the indexed supported technique. **/
    public org.ogre4j.ITechnique getSupportedTechnique(int index);

    /** 
    Retrieves the number of supported techniques. **/
    public int getNumSupportedTechniques();

    /** 
    Gets a string explaining why any techniques are not supported. **/
    public String getUnsupportedTechniquesExplanation();

    /** 
    Gets the number of levels-of-detail this material has in the given scheme, based on . **/
    public int getNumLodLevels(int schemeIndex);

    /** 
    Gets the number of levels-of-detail this material has in the given scheme, based on . **/
    public int getNumLodLevels(String schemeName);

    /** 
    Gets the best supported technique. **/
    public org.ogre4j.ITechnique getBestTechnique(int lodIndex, org.ogre4j.IRenderable rend);

    /** 
    Creates a new copy of this material with the same settings but a new name. **/
    public void clone(org.ogre4j.IMaterialPtr returnValue, String newName, boolean changeGroup, String newGroup);

    /** 
    Copies the details of this material into another, preserving the target's handle and name (unlike operator=) but copying everything else. **/
    public void copyDetailsTo(org.ogre4j.IMaterialPtr mat);

    /** 
    'Compiles' this . **/
    public void compile(boolean autoManageTextureUnits);

    /** 
    Sets the point size properties for every  in every . **/
    public void setPointSize(float ps);

    /** 
    Sets the ambient colour reflectance properties for every  in every . **/
    public void setAmbient(float red, float green, float blue);

    /** 
    Sets the ambient colour reflectance properties for every  in every . **/
    public void setAmbient(org.ogre4j.IColourValue ambient);

    /** 
    Sets the diffuse colour reflectance properties of every  in every . **/
    public void setDiffuse(float red, float green, float blue, float alpha);

    /** 
    Sets the diffuse colour reflectance properties of every  in every . **/
    public void setDiffuse(org.ogre4j.IColourValue diffuse);

    /** 
    Sets the specular colour reflectance properties of every  in every . **/
    public void setSpecular(float red, float green, float blue, float alpha);

    /** 
    Sets the specular colour reflectance properties of every  in every . **/
    public void setSpecular(org.ogre4j.IColourValue specular);

    /** 
    Sets the shininess properties of every  in every . **/
    public void setShininess(float val);

    /** 
    Sets the amount of self-illumination of every  in every . **/
    public void setSelfIllumination(float red, float green, float blue);

    /** 
    Sets the amount of self-illumination of every  in every . **/
    public void setSelfIllumination(org.ogre4j.IColourValue selfIllum);

    /** 
    Sets whether or not each  renders with depth-buffer checking on or not. **/
    public void setDepthCheckEnabled(boolean enabled);

    /** 
    Sets whether or not each  renders with depth-buffer writing on or not. **/
    public void setDepthWriteEnabled(boolean enabled);

    /** 
    Sets the function used to compare depth values when depth checking is on. **/
    public void setDepthFunction(org.ogre4j.CompareFunction func);

    /** 
    Sets whether or not colour buffer writing is enabled for each . **/
    public void setColourWriteEnabled(boolean enabled);

    /** 
    Sets the culling mode for each pass based on the 'vertex winding'. **/
    public void setCullingMode(org.ogre4j.CullingMode mode);

    /** 
    Sets the manual culling mode, performed by CPU rather than hardware. **/
    public void setManualCullingMode(org.ogre4j.ManualCullingMode mode);

    /** 
    Sets whether or not dynamic lighting is enabled for every . **/
    public void setLightingEnabled(boolean enabled);

    /** 
    Sets the type of light shading required **/
    public void setShadingMode(org.ogre4j.ShadeOptions mode);

    /** 
    Sets the fogging mode applied to each pass. **/
    public void setFog(boolean overrideScene, org.ogre4j.FogMode mode, org.ogre4j.IColourValue colour, float expDensity, float linearStart, float linearEnd);

    /** 
    Sets the depth bias to be used for each . **/
    public void setDepthBias(float constantBias, float slopeScaleBias);

    /** 
    Set texture filtering for every texture unit in every  and **/
    public void setTextureFiltering(org.ogre4j.TextureFilterOptions filterType);

    /** 
    Sets the anisotropy level to be used for all textures. **/
    public void setTextureAnisotropy(int maxAniso);

    /** 
    Sets the kind of blending every pass has with the existing contents of the scene. **/
    public void setSceneBlending(org.ogre4j.SceneBlendType sbt);

    /** 
    Sets the kind of blending every pass has with the existing contents of the scene, using individual factors for color and alpha channels **/
    public void setSeparateSceneBlending(org.ogre4j.SceneBlendType sbt, org.ogre4j.SceneBlendType sbta);

    /** 
    Allows very fine control of blending every  with the existing contents of the scene. **/
    public void setSceneBlending(org.ogre4j.SceneBlendFactor sourceFactor, org.ogre4j.SceneBlendFactor destFactor);

    /** 
    Allows very fine control of blending every  with the existing contents of the scene, using individual factors for color and alpha channels **/
    public void setSeparateSceneBlending(org.ogre4j.SceneBlendFactor sourceFactor, org.ogre4j.SceneBlendFactor destFactor, org.ogre4j.SceneBlendFactor sourceFactorAlpha, org.ogre4j.SceneBlendFactor destFactorAlpha);

    /** 
    Tells the material that it needs recompilation. **/
    public void _notifyNeedsRecompile();

    /** 
    Sets the distance at which level-of-detail (LOD) levels come into effect. **/
    public void setLodLevels(org.ogre4j.IMaterial.ILodDistanceList lodDistances);

    /** 
    Gets an iterator over the list of distances at which each LOD comes into effect. **/
    public void getLodDistanceIterator(org.ogre4j.IMaterial.ILodDistanceIterator returnValue);

    /** 
    Gets the LOD index to use at the given distance. **/
    public int getLodIndex(float d);

    /** 
    Gets the LOD index to use at the given squared distance. **/
    public int getLodIndexSquaredDepth(float squaredDepth);

    /** 
    **/
    public void touch();

    /** 
    Applies texture names to  Unit State with matching texture name aliases. All techniques, passes, and  Unit States within the material are checked. If matching texture aliases are found then true is returned.
    **/
    public boolean applyTextureAliases(org.ogre4j.IAliasTextureNamePairList aliasList, boolean apply);

    /** 
    Gets the compilation status of the material. **/
    public boolean getCompilationRequired();

}
