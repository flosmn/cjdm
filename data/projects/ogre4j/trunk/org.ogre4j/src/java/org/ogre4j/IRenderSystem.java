/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public interface IRenderSystem extends INativeObject, org.ogre4j.IRenderSysAllocatedObject {

public static interface IListener extends INativeObject {

    /** 
    A rendersystem-specific event occurred. **/
    public void eventOccurred(String eventName, org.ogre4j.INameValuePairList parameters);

}
public interface IRenderTargetIterator extends INativeObject, org.ogre4j.IMapIterator< org.ogre4j.IRenderTargetMap > {

    /** **/
    public boolean hasMoreElements();

    /** **/
    public org.ogre4j.IRenderTarget getNext();

    /** **/
    public org.ogre4j.IRenderTarget peekNextValue();

    /** **/
    public String peekNextKey();

    /** **/
    public org.ogre4j.IRenderSystem.IRenderTargetIterator operatorAssignment(org.ogre4j.IRenderSystem.IRenderTargetIterator rhs);

    /** **/
    public NativeObjectPointer<org.ogre4j.IRenderTarget> peekNextValuePtr();

    /** **/
    public void moveNext();

}
public interface IListenerList extends INativeObject, org.std.Ilist< org.ogre4j.IRenderSystem.IListener > {

    /** **/
    public void assign(int num, org.ogre4j.IRenderSystem.IListener val);

    /** **/
    public org.ogre4j.IRenderSystem.IListener back();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public org.ogre4j.IRenderSystem.IListener front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void pop_front();

    /** **/
    public void push_back(org.ogre4j.IRenderSystem.IListener val);

    /** **/
    public void push_front(org.ogre4j.IRenderSystem.IListener val);

    /** **/
    public void remove(org.ogre4j.IRenderSystem.IListener val);

    /** **/
    public void reverse();

    /** **/
    public int size();

    /** **/
    public void unique();

}
public interface IHardwareOcclusionQueryList extends INativeObject, org.std.Ilist< org.ogre4j.IHardwareOcclusionQuery > {

    /** **/
    public void assign(int num, org.ogre4j.IHardwareOcclusionQuery val);

    /** **/
    public org.ogre4j.IHardwareOcclusionQuery back();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public org.ogre4j.IHardwareOcclusionQuery front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void pop_front();

    /** **/
    public void push_back(org.ogre4j.IHardwareOcclusionQuery val);

    /** **/
    public void push_front(org.ogre4j.IHardwareOcclusionQuery val);

    /** **/
    public void remove(org.ogre4j.IHardwareOcclusionQuery val);

    /** **/
    public void reverse();

    /** **/
    public int size();

    /** **/
    public void unique();

}
    /** 
    Returns the name of the rendering system. **/
    public String getName();

    /** 
    Returns the details of this API's configuration options **/
    public org.ogre4j.IConfigOptionMap getConfigOptions();

    /** 
    Sets an option for this API **/
    public void setConfigOption(String name, String value);

    /** 
    Create an object for performing hardware occlusion queries. **/
    public org.ogre4j.IHardwareOcclusionQuery createHardwareOcclusionQuery();

    /** 
    Destroy a hardware occlusion query object. **/
    public void destroyHardwareOcclusionQuery(org.ogre4j.IHardwareOcclusionQuery hq);

    /** 
    Validates the options set for the rendering system, returning a message if there are problems. **/
    public String validateConfigOptions();

    /** 
    Start up the renderer using the settings selected (Or the defaults if none have been selected). **/
    public org.ogre4j.IRenderWindow _initialise(boolean autoCreateWindow, String windowTitle);

    /** 
    Query the real capabilities of the GPU and driver in the **/
    public org.ogre4j.IRenderSystemCapabilities createRenderSystemCapabilities();

    /** 
    Force the render system to use the special capabilities. Can only be called before the render system has been fully initializer (before createWindow is called) **/
    public void useCustomRenderSystemCapabilities(org.ogre4j.IRenderSystemCapabilities capabilities);

    /** 
    Restart the renderer (normally following a change in settings). **/
    public void reinitialise();

    /** 
    Shutdown the renderer and cleanup resources. **/
    public void shutdown();

    /** 
    Sets the colour & strength of the ambient (global directionless) light in the world. **/
    public void setAmbientLight(float r, float g, float b);

    /** 
    Sets the type of light shading required (default = Gouraud). **/
    public void setShadingType(org.ogre4j.ShadeOptions so);

    /** 
    Sets whether or not dynamic lighting is enabled. **/
    public void setLightingEnabled(boolean enabled);

    /** 
    Sets whether or not W-buffers are enabled if they are available for this renderer. **/
    public void setWBufferEnabled(boolean enabled);

    /** 
    Returns true if the renderer will try to use W-buffers when avalible. **/
    public boolean getWBufferEnabled();

    /** 
    Creates a new rendering window. 
Key: "title" Description: The title of the window that will appear in the title bar Values: string Default:  name
    Key: "colourDepth" Description: Colour depth of the resulting rendering window; only applies if fullScreen is set. Values: 16 or 32 Default: desktop depth Notes: [W32 specific]
    Key: "left" Description: screen x coordinate from left Values: positive integers Default: 'center window on screen' Notes: Ignored in case of full screen
    Key: "top" Description: screen y coordinate from top Values: positive integers Default: 'center window on screen' Notes: Ignored in case of full screen
    Key: "depthBuffer" [DX9 specific] Description: Use depth buffer Values: false or true Default: true
    Key: "externalWindowHandle" [API specific] Description: External window handle, for embedding the OGRE context Values: positive integer for W32 (HWND handle) poslong:posint:poslong (display*:screen:windowHandle) or poslong:posint:poslong:poslong (display*:screen:windowHandle:XVisualInfo*) for GLX Default: 0 (None)
    Key: "externalGLControl" [Win32 OpenGL specific] Description: Let the external window control OpenGL i.e. don't select a pixel format for the window, do not change v-sync and do not swap buffer. When set to true, the calling application is responsible of OpenGL initialization and buffer swapping. It should also create an OpenGL context for its own rendering,  will create one for its use. Then the calling application must also enable  OpenGL context before calling any  function and restore its OpenGL context after these calls. The  OpenGL context can be retrieved after  initialisation by calling wglGetCurrentDC() and wglGetCurrentContext(). It is only used when the externalWindowHandle parameter is used. Values: true, false Default: false
    Key: "externalGLContext" [Win32 OpenGL specific] Description: Use an externally created GL context Values: <Context as="" unsigned="" long>=""> Default: 0 (create own context)
    Key: "parentWindowHandle" [API specific] Description: Parent window handle, for embedding the OGRE context Values: positive integer for W32 (HWND handle) poslong:posint:poslong for GLX (display*:screen:windowHandle) Default: 0 (None)
    Key: "FSAA" Description: Full screen antialiasing factor Values: 0,2,4,6,... Default: 0
    Key: "displayFrequency" Description: Display frequency rate, for fullscreen mode Values: 60...? Default: Desktop vsync rate
    Key: "vsync" Description: Synchronize buffer swaps to vsync Values: true, false Default: 0
    Key: "border" Description: The type of window border (in windowed mode) Values: none, fixed, resize Default: resize
    Key: "outerDimensions" Description: Whether the width/height is expressed as the size of the outer window, rather than the content area Values: true, false Default: false
    Key: "useNVPerfHUD" [DX9 specific] Description: Enable the use of nVidia NVPerfHUD Values: true, false Default: false
    Key: "gamma" Description: Enable hardware conversion from linear colour space to gamma colour space on rendering to the window. Values: true, false Default: false **/
    public org.ogre4j.IRenderWindow _createRenderWindow(String name, long width, long height, boolean fullScreen, org.ogre4j.INameValuePairList miscParams);

    /** 
    Create a , which is a render target that renders to multiple RenderTextures at once. Surfaces can be bound and unbound at will. This fails if mCapabilities->getNumMultiRenderTargets() is smaller than 2. **/
    public org.ogre4j.IMultiRenderTarget createMultiRenderTarget(String name);

    /** 
    Destroys a render window **/
    public void destroyRenderWindow(String name);

    /** 
    Destroys a render texture **/
    public void destroyRenderTexture(String name);

    /** 
    Destroys a render target of any sort **/
    public void destroyRenderTarget(String name);

    /** 
    Attaches the passed render target to the render system. **/
    public void attachRenderTarget(org.ogre4j.IRenderTarget target);

    /** 
    Returns a pointer to the render target with the passed name, or NULL if that render target cannot be found. **/
    public org.ogre4j.IRenderTarget getRenderTarget(String name);

    /** 
    Detaches the render target with the passed name from the render system and returns a pointer to it. **/
    public org.ogre4j.IRenderTarget detachRenderTarget(String name);

    /** 
    Returns a specialised  over all render targets attached to the . **/
    public void getRenderTargetIterator(org.ogre4j.IRenderSystem.IRenderTargetIterator returnValue);

    /** 
    Returns a description of an error code. **/
    public String getErrorDescription(long errorNumber);

    /** 
    Defines whether or now fullscreen render windows wait for the vertical blank before flipping buffers. **/
    public void setWaitForVerticalBlank(boolean enabled);

    /** 
    Returns true if the system is synchronising frames with the monitor vertical blank. **/
    public boolean getWaitForVerticalBlank();

    /** 
    Tells the rendersystem to use the attached set of lights (and no others) up to the number specified (this allows the same list to be used with different count limits) **/
    public void _useLights(org.ogre4j.ILightList lights, int limit);

    /** 
    Sets the world transform matrix. **/
    public void _setWorldMatrix(org.ogre4j.IMatrix4 m);

    /** 
    Sets multiple world matrices (vertex blending). **/
    public void _setWorldMatrices(org.ogre4j.IMatrix4 m, int count);

    /** 
    Sets the view transform matrix **/
    public void _setViewMatrix(org.ogre4j.IMatrix4 m);

    /** 
    Sets the projection transform matrix **/
    public void _setProjectionMatrix(org.ogre4j.IMatrix4 m);

    /** 
    Utility function for setting all the properties of a texture unit at once. This method is also worth using over the individual texture unit settings because it only sets those settings which are different from the current settings for this unit, thus minimising render state changes. **/
    public void _setTextureUnitSettings(int texUnit, org.ogre4j.ITextureUnitState tl);

    /** 
    Turns off a texture unit. **/
    public void _disableTextureUnit(int texUnit);

    /** 
    Disables all texture units from the given unit upwards **/
    public void _disableTextureUnitsFrom(int texUnit);

    /** 
    Sets the surface properties to be used for future rendering.
    This method sets the the properties of the surfaces of objects to be rendered after it. In this context these surface properties are the amount of each type of light the object reflects (determining it's colour under different types of light), whether it emits light itself, and how shiny it is. Textures are not dealt with here, see the _setTetxure method for details. This method is used by _setMaterial so does not need to be called direct if that method is being used.
    **/
    public void _setSurfaceParams(org.ogre4j.IColourValue ambient, org.ogre4j.IColourValue diffuse, org.ogre4j.IColourValue specular, org.ogre4j.IColourValue emissive, float shininess, int tracking);

    /** 
    Sets whether or not rendering points using OT_POINT_LIST will render point sprites (textured quads) or plain points. **/
    public void _setPointSpritesEnabled(boolean enabled);

    /** 
    Sets the size of points and how they are attenuated with distance. **/
    public void _setPointParameters(float size, boolean attenuationEnabled, float constant, float linear, float quadratic, float minSize, float maxSize);

    /** 
    Sets the texture to bind to a given texture unit.
    User processes would not normally call this direct unless rendering primitives themselves.
    **/
    public void _setTexture(int unit, boolean enabled, org.ogre4j.ITexturePtr texPtr);

    /** 
    Sets the texture to bind to a given texture unit.
    User processes would not normally call this direct unless rendering primitives themselves.
    **/
    public void _setTexture(int unit, boolean enabled, String texname);

    /** 
    Binds a texture to a vertex sampler. **/
    public void _setVertexTexture(int unit, org.ogre4j.ITexturePtr tex);

    /** 
    Sets the texture coordinate set to use for a texture unit.
    Meant for use internally - not generally used directly by apps - the  and  classes let you manage textures far more easily.
    **/
    public void _setTextureCoordSet(int unit, int index);

    /** 
    Sets a method for automatically calculating texture coordinates for a stage. Should not be used by apps - for use by  only. **/
    public void _setTextureCoordCalculation(int unit, org.ogre4j.TexCoordCalcMethod m, org.ogre4j.IFrustum frustum);

    /** 
    Sets the texture blend modes from a  record. Meant for use internally only - apps should use the  and  classes. **/
    public void _setTextureBlendMode(int unit, org.ogre4j.ILayerBlendModeEx bm);

    /** 
    Sets the filtering options for a given texture unit. **/
    public void _setTextureUnitFiltering(int unit, org.ogre4j.FilterOptions minFilter, org.ogre4j.FilterOptions magFilter, org.ogre4j.FilterOptions mipFilter);

    /** 
    Sets a single filter for a given texture unit. **/
    public void _setTextureUnitFiltering(int unit, org.ogre4j.FilterType ftype, org.ogre4j.FilterOptions filter);

    /** 
    Sets the maximal anisotropy for the specified texture unit. **/
    public void _setTextureLayerAnisotropy(int unit, long maxAnisotropy);

    /** 
    Sets the texture addressing mode for a texture unit. **/
    public void _setTextureAddressingMode(int unit, org.ogre4j.ITextureUnitState.IUVWAddressingMode uvw);

    /** 
    Sets the texture border colour for a texture unit. **/
    public void _setTextureBorderColour(int unit, org.ogre4j.IColourValue colour);

    /** 
    Sets the mipmap bias value for a given texture unit. **/
    public void _setTextureMipmapBias(int unit, float bias);

    /** 
    Sets the texture coordinate transformation matrix for a texture unit. **/
    public void _setTextureMatrix(int unit, org.ogre4j.IMatrix4 xform);

    /** 
    Sets the global blending factors for combining subsequent renders with the existing frame contents. The result of the blending operation is: 
    final = (texture * sourceFactor) + (pixel * destFactor) Each of the factors is specified as one of a number of options, as specified in the SceneBlendFactor enumerated type. **/
    public void _setSceneBlending(org.ogre4j.SceneBlendFactor sourceFactor, org.ogre4j.SceneBlendFactor destFactor);

    /** 
    Sets the global blending factors for combining subsequent renders with the existing frame contents. The result of the blending operation is: 
    final = (texture * sourceFactor) + (pixel * destFactor) Each of the factors is specified as one of a number of options, as specified in the SceneBlendFactor enumerated type. **/
    public void _setSeparateSceneBlending(org.ogre4j.SceneBlendFactor sourceFactor, org.ogre4j.SceneBlendFactor destFactor, org.ogre4j.SceneBlendFactor sourceFactorAlpha, org.ogre4j.SceneBlendFactor destFactorAlpha);

    /** 
    Sets the global alpha rejection approach for future renders. By default images are rendered regardless of texture alpha. This method lets you change that. **/
    public void _setAlphaRejectSettings(org.ogre4j.CompareFunction func, short value, boolean alphaToCoverage);

    /** 
    Notify the rendersystem that it should adjust texture projection to be relative to a different origin. **/
    public void _setTextureProjectionRelativeTo(boolean enabled, org.ogre4j.IVector3 pos);

    /** 
    Signifies the beginning of a frame, i.e. the start of rendering on a single viewport. Will occur several times per complete frame if multiple viewports exist. **/
    public void _beginFrame();

    /** 
    Ends rendering of a frame to the current viewport. **/
    public void _endFrame();

    /** 
    Sets the provided viewport as the active one for future rendering operations. This viewport is aware of it's own camera and render target. Must be implemented by subclass.
    **/
    public void _setViewport(org.ogre4j.IViewport vp);

    /** 
    Get the current active viewport for rendering. **/
    public org.ogre4j.IViewport _getViewport();

    /** 
    Sets the culling mode for the render system based on the 'vertex winding'. A typical way for the rendering engine to cull triangles is based on the 'vertex winding' of triangles. Vertex winding refers to the direction in which the vertices are passed or indexed to in the rendering operation as viewed from the camera, and will wither be clockwise or anticlockwise (that's 'counterclockwise' for you Americans out there ;) The default is CULL_CLOCKWISE i.e. that only triangles whose vertices are passed/indexed in anticlockwise order are rendered - this is a common approach and is used in 3D studio models for example. You can alter this culling mode if you wish but it is not advised unless you know what you are doing. You may wish to use the CULL_NONE option for mesh data that you cull yourself where the vertex winding is uncertain. **/
    public void _setCullingMode(org.ogre4j.CullingMode mode);

    /** **/
    public org.ogre4j.CullingMode _getCullingMode();

    /** 
    Sets the mode of operation for depth buffer tests from this point onwards. Sometimes you may wish to alter the behaviour of the depth buffer to achieve special effects. Because it's unlikely that you'll set these options for an entire frame, but rather use them to tweak settings between rendering objects, this is an internal method (indicated by the '_' prefix) which will be used by a  implementation rather than directly from the client application. If this method is never called the settings are automatically the same as the default parameters. **/
    public void _setDepthBufferParams(boolean depthTest, boolean depthWrite, org.ogre4j.CompareFunction depthFunction);

    /** 
    Sets whether or not the depth buffer check is performed before a pixel write. **/
    public void _setDepthBufferCheckEnabled(boolean enabled);

    /** 
    Sets whether or not the depth buffer is updated after a pixel write. **/
    public void _setDepthBufferWriteEnabled(boolean enabled);

    /** 
    Sets the comparison function for the depth buffer check. Advanced use only - allows you to choose the function applied to compare the depth values of new and existing pixels in the depth buffer. Only an issue if the deoth buffer check is enabled (see _setDepthBufferCheckEnabled) **/
    public void _setDepthBufferFunction(org.ogre4j.CompareFunction func);

    /** 
    Sets whether or not colour buffer writing is enabled, and for which channels. **/
    public void _setColourBufferWriteEnabled(boolean red, boolean green, boolean blue, boolean alpha);

    /** 
    Sets the depth bias, NB you should use the  version of this. **/
    public void _setDepthBias(float constantBias, float slopeScaleBias);

    /** 
    Sets the fogging mode for future geometry. **/
    public void _setFog(org.ogre4j.FogMode mode, org.ogre4j.IColourValue colour, float expDensity, float linearStart, float linearEnd);

    /** 
    The  will keep a count of tris rendered, this resets the count. **/
    public void _beginGeometryCount();

    /** 
    Reports the number of tris rendered since the last _beginGeometryCount call. **/
    public long _getFaceCount();

    /** 
    Reports the number of batches rendered since the last _beginGeometryCount call. **/
    public long _getBatchCount();

    /** 
    Reports the number of vertices passed to the renderer since the last _beginGeometryCount call. **/
    public long _getVertexCount();

    /** 
    Generates a packed data version of the passed in  suitable for use as with this . **/
    public void convertColourValue(org.ogre4j.IColourValue colour, LongPointer pDest);

    /** 
    Get the native VertexElementType for a compact 32-bit colour value for this rendersystem. **/
    public org.ogre4j.VertexElementType getColourVertexElementType();

    /** 
    Converts a uniform projection matrix to suitable for this render system. **/
    public void _convertProjectionMatrix(org.ogre4j.IMatrix4 matrix, org.ogre4j.IMatrix4 dest, boolean forGpuProgram);

    /** 
    Builds a perspective projection matrix suitable for this render system. **/
    public void _makeProjectionMatrix(org.ogre4j.IRadian fovy, float aspect, float nearPlane, float farPlane, org.ogre4j.IMatrix4 dest, boolean forGpuProgram);

    /** 
    Builds a perspective projection matrix for the case when frustum is not centered around camera. **/
    public void _makeProjectionMatrix(float left, float right, float bottom, float top, float nearPlane, float farPlane, org.ogre4j.IMatrix4 dest, boolean forGpuProgram);

    /** 
    Builds an orthographic projection matrix suitable for this render system. **/
    public void _makeOrthoMatrix(org.ogre4j.IRadian fovy, float aspect, float nearPlane, float farPlane, org.ogre4j.IMatrix4 dest, boolean forGpuProgram);

    /** 
    Update a perspective projection matrix to use 'oblique depth projection'. **/
    public void _applyObliqueDepthProjection(org.ogre4j.IMatrix4 matrix, org.ogre4j.IPlane plane, boolean forGpuProgram);

    /** 
    Sets how to rasterise triangles, as points, wireframe or solid polys. **/
    public void _setPolygonMode(org.ogre4j.PolygonMode level);

    /** 
    Turns stencil buffer checking on or off. **/
    public void setStencilCheckEnabled(boolean enabled);

    /** 
    This method allows you to set all the stencil buffer parameters in one call. **/
    public void setStencilBufferParams(org.ogre4j.CompareFunction func, long refValue, long mask, org.ogre4j.StencilOperation stencilFailOp, org.ogre4j.StencilOperation depthFailOp, org.ogre4j.StencilOperation passOp, boolean twoSidedOperation);

    /** 
    Sets the current vertex declaration, ie the source of vertex data. **/
    public void setVertexDeclaration(org.ogre4j.IVertexDeclaration decl);

    /** 
    Sets the current vertex buffer binding state. **/
    public void setVertexBufferBinding(org.ogre4j.IVertexBufferBinding binding);

    /** 
    Sets whether or not normals are to be automatically normalised. **/
    public void setNormaliseNormals(boolean normalise);

    /** 
    Render something to the active viewport.
    Low-level rendering interface to perform rendering operations. Unlikely to be used directly by client applications, since the  and various support classes will be responsible for calling this method. Can only be called between _beginScene and _endScene
    **/
    public void _render(org.ogre4j.IRenderOperation op);

    /** 
    Gets the capabilities of the render system. **/
    public org.ogre4j.IRenderSystemCapabilities getCapabilities();

    /** 
    Returns the driver version. **/
    public org.ogre4j.IDriverVersion getDriverVersion();

    /** 
    Binds a given  (but not the parameters). **/
    public void bindGpuProgram(org.ogre4j.IGpuProgram prg);

    /** 
    Bind Gpu program parameters. **/
    public void bindGpuProgramParameters(org.ogre4j.GpuProgramType gptype, org.ogre4j.IGpuProgramParametersSharedPtr params);

    /** 
    Only binds Gpu program parameters used for passes that have more than one iteration rendering **/
    public void bindGpuProgramPassIterationParameters(org.ogre4j.GpuProgramType gptype);

    /** 
    Unbinds GpuPrograms of a given GpuProgramType. **/
    public void unbindGpuProgram(org.ogre4j.GpuProgramType gptype);

    /** 
    Returns whether or not a Gpu program of the given type is currently bound. **/
    public boolean isGpuProgramBound(org.ogre4j.GpuProgramType gptype);

    /** 
    Sets the user clipping region. **/
    public void setClipPlanes(org.ogre4j.IPlaneList clipPlanes);

    /** 
    Add a user clipping plane. **/
    public void addClipPlane(org.ogre4j.IPlane p);

    /** 
    Add a user clipping plane. **/
    public void addClipPlane(float A, float B, float C, float D);

    /** 
    Clears the user clipping region. **/
    public void resetClipPlanes();

    /** 
    Utility method for initialising all render targets attached to this rendering system. **/
    public void _initRenderTargets();

    /** 
    Utility method to notify all render targets that a camera has been removed, in case they were referring to it as their viewer. **/
    public void _notifyCameraRemoved(org.ogre4j.ICamera cam);

    /** 
    Internal method for updating all render targets attached to this rendering system. **/
    public void _updateAllRenderTargets(boolean swapBuffers);

    /** 
    Internal method for swapping all the buffers on all render targets, if _updateAllRenderTargets was called with a 'false' parameter. **/
    public void _swapAllRenderTargetBuffers(boolean waitForVsync);

    /** 
    Sets whether or not vertex windings set should be inverted; this can be important for rendering reflections. **/
    public void setInvertVertexWinding(boolean invert);

    /** 
    Sets the 'scissor region' ie the region of the target in which rendering can take place. **/
    public void setScissorTest(boolean enabled, int left, int top, int right, int bottom);

    /** 
    Clears one or more frame buffers on the active render target. **/
    public void clearFrameBuffer(long buffers, org.ogre4j.IColourValue colour, float depth, int stencil);

    /** 
    Returns the horizontal texel offset value required for mapping texel origins to pixel origins in this rendersystem. **/
    public float getHorizontalTexelOffset();

    /** 
    Returns the vertical texel offset value required for mapping texel origins to pixel origins in this rendersystem. **/
    public float getVerticalTexelOffset();

    /** 
    Gets the minimum (closest) depth value to be used when rendering using identity transforms. **/
    public float getMinimumDepthInputValue();

    /** 
    Gets the maximum (farthest) depth value to be used when rendering using identity transforms. **/
    public float getMaximumDepthInputValue();

    /** 
    set the current multi pass count value. This must be set prior to calling  if multiple renderings of the same pass state are required. **/
    public void setCurrentPassIterationCount(int count);

    /** 
    Tell the render system whether to derive a depth bias on its own based on the values passed to it in setCurrentPassIterationCount. The depth bias set will be baseValue + iteration * multiplier **/
    public void setDeriveDepthBias(boolean derive, float baseValue, float multiplier, float slopeScale);

    /** 
    Adds a listener to the custom events that this render system can raise. **/
    public void addListener(org.ogre4j.IRenderSystem.IListener l);

    /** 
    Remove a listener to the custom events that this render system can raise. **/
    public void removeListener(org.ogre4j.IRenderSystem.IListener l);

    /** 
    Gets a list of the rendersystem specific events that this rendersystem can raise. **/
    public org.ogre4j.IStringVector getRenderSystemEvents();

    /** 
    Tell the rendersystem to perform any prep tasks it needs to directly before other threads which might access the rendering API are registered. **/
    public void preExtraThreadsStarted();

    /** **/
    public void postExtraThreadsStarted();

    /** 
    Register the an additional thread which may make calls to rendersystem-related objects. **/
    public void registerThread();

    /** 
    Unregister an additional thread which may make calls to rendersystem-related objects. **/
    public void unregisterThread();

}
