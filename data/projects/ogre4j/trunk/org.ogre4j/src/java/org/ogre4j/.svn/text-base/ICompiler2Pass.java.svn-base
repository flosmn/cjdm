/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public interface ICompiler2Pass extends INativeObject, org.ogre4j.IScriptingAllocatedObject {

public static interface ILexemeTokenDef extends INativeObject {

    /** **/
    public int getID();

    /** **/
    public void setID(int _jni_value_);

    /** **/
    public boolean gethasAction();

    /** **/
    public void sethasAction(boolean _jni_value_);

    /** **/
    public boolean getisNonTerminal();

    /** **/
    public void setisNonTerminal(boolean _jni_value_);

    /** **/
    public int getruleID();

    /** **/
    public void setruleID(int _jni_value_);

    /** **/
    public boolean getisCaseSensitive();

    /** **/
    public void setisCaseSensitive(boolean _jni_value_);

    /** **/
    public String getlexeme();

    /** **/
    public void setlexeme(String _jni_value_);

}
public static interface ITokenInst extends INativeObject {

    /** **/
    public int getNTTRuleID();

    /** **/
    public void setNTTRuleID(int _jni_value_);

    /** **/
    public int gettokenID();

    /** **/
    public void settokenID(int _jni_value_);

    /** **/
    public int getline();

    /** **/
    public void setline(int _jni_value_);

    /** **/
    public int getpos();

    /** **/
    public void setpos(int _jni_value_);

    /** **/
    public boolean getfound();

    /** **/
    public void setfound(boolean _jni_value_);

}
public static interface ITokenRule extends INativeObject {

    /** **/
    public org.ogre4j.Compiler2Pass.OperationType getoperation();

    /** **/
    public void setoperation(org.ogre4j.Compiler2Pass.OperationType _jni_value_);

    /** **/
    public int gettokenID();

    /** **/
    public void settokenID(int _jni_value_);

}
public static interface ITokenState extends INativeObject {

    /** **/
    public void gettokenQue(org.ogre4j.ICompiler2Pass.ITokenInstContainer returnValue);

    /** **/
    public void settokenQue(org.ogre4j.ICompiler2Pass.ITokenInstContainer _jni_value_);

    /** **/
    public void getlexemeTokenDefinitions(org.ogre4j.ICompiler2Pass.ILexemeTokenDefContainer returnValue);

    /** **/
    public void setlexemeTokenDefinitions(org.ogre4j.ICompiler2Pass.ILexemeTokenDefContainer _jni_value_);

    /** **/
    public void getrootRulePath(org.ogre4j.ICompiler2Pass.ITokenRuleContainer returnValue);

    /** **/
    public void setrootRulePath(org.ogre4j.ICompiler2Pass.ITokenRuleContainer _jni_value_);

    /** **/
    public void getlexemeTokenMap(org.ogre4j.ICompiler2Pass.ILexemeTokenMap returnValue);

    /** **/
    public void setlexemeTokenMap(org.ogre4j.ICompiler2Pass.ILexemeTokenMap _jni_value_);

}
public interface ITokenRuleContainer extends INativeObject, org.std.Ivector< org.ogre4j.ICompiler2Pass.ITokenRule > {

    /** **/
    public void assign(int num, org.ogre4j.ICompiler2Pass.ITokenRule val);

    /** **/
    public org.ogre4j.ICompiler2Pass.ITokenRule at(int loc);

    /** **/
    public org.ogre4j.ICompiler2Pass.ITokenRule back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public org.ogre4j.ICompiler2Pass.ITokenRule front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(org.ogre4j.ICompiler2Pass.ITokenRule val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
public interface ILexemeTokenDefContainer extends INativeObject, org.std.Ivector< org.ogre4j.ICompiler2Pass.ILexemeTokenDef > {

    /** **/
    public void assign(int num, org.ogre4j.ICompiler2Pass.ILexemeTokenDef val);

    /** **/
    public org.ogre4j.ICompiler2Pass.ILexemeTokenDef at(int loc);

    /** **/
    public org.ogre4j.ICompiler2Pass.ILexemeTokenDef back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public org.ogre4j.ICompiler2Pass.ILexemeTokenDef front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(org.ogre4j.ICompiler2Pass.ILexemeTokenDef val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
public interface ILexemeTokenMap extends INativeObject, org.std.Imap< String, Integer > {

    /** **/
    public void clear();

    /** **/
    public int count(String key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(String key);

    /** **/
    public int max_size();

    /** **/
    public int size();

    /** **/
    public IntegerPointer get(String key);

    /** **/
    public void insert(String key, IntegerPointer value);

}
public interface ITokenInstContainer extends INativeObject, org.std.Ivector< org.ogre4j.ICompiler2Pass.ITokenInst > {

    /** **/
    public void assign(int num, org.ogre4j.ICompiler2Pass.ITokenInst val);

    /** **/
    public org.ogre4j.ICompiler2Pass.ITokenInst at(int loc);

    /** **/
    public org.ogre4j.ICompiler2Pass.ITokenInst back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public org.ogre4j.ICompiler2Pass.ITokenInst front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(org.ogre4j.ICompiler2Pass.ITokenInst val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
public interface ILabelContainer extends INativeObject, org.std.Imap< Integer, String > {

    /** **/
    public void clear();

    /** **/
    public int count(int key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(int key);

    /** **/
    public int max_size();

    /** **/
    public int size();

    /** **/
    public StringPointer get(int key);

    /** **/
    public void insert(int key, StringPointer value);

}
public interface ITokenStateContainer extends INativeObject, org.std.Imap< String, org.ogre4j.ICompiler2Pass.ITokenState > {

    /** **/
    public void clear();

    /** **/
    public int count(String key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(String key);

    /** **/
    public int max_size();

    /** **/
    public int size();

    /** **/
    public org.ogre4j.ICompiler2Pass.ITokenState get(String key);

    /** **/
    public void insert(String key, org.ogre4j.ICompiler2Pass.ITokenState value);

}
    /** 
    compile the source - performs 2 passes. First pass is to tokenize, check semantics and context. The second pass is performed by using tokens to look up function implementors and executing them which convert tokens to application specific instructions. **/
    public boolean compile(String source, String sourceName);

    /** 
    gets BNF Grammar. Gets called when BNF grammar has to be compiled for the first time. **/
    public String getClientBNFGrammer();

    /** 
    get the name of the BNF grammar. **/
    public String getClientGrammerName();

}
