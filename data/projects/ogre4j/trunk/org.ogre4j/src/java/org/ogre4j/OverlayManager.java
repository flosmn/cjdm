/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class OverlayManager extends org.xbig.base.NativeObject implements org.ogre4j.IOverlayManager {
static { System.loadLibrary("ogre4j");}
public static class OverlayMap extends org.xbig.base.NativeObject implements org.ogre4j.IOverlayManager.IOverlayMap {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public OverlayMap(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected OverlayMap(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public OverlayMap(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public OverlayMap() {
         super( new org.xbig.base.InstancePointer(__createOverlayMap()), false);
    }

    private native static long __createOverlayMap();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.IOverlay get(String key) {
         return new org.ogre4j.Overlay(new InstancePointer(_get__sR(this.object.pointer, key)));
    }

    private native long _get__sR(long _pointer_, String key);

    /** **/
    public void insert(String key, org.ogre4j.IOverlay value) {
        _insert__sROgre_Overlayp(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__sROgre_Overlayp(long _pointer_, String key, long value);

}
public static class ElementMap extends org.xbig.base.NativeObject implements org.ogre4j.IOverlayManager.IElementMap {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public ElementMap(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected ElementMap(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public ElementMap(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public ElementMap() {
         super( new org.xbig.base.InstancePointer(__createElementMap()), false);
    }

    private native static long __createElementMap();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.IOverlayElement get(String key) {
         return new org.ogre4j.OverlayElement(new InstancePointer(_get__sR(this.object.pointer, key)));
    }

    private native long _get__sR(long _pointer_, String key);

    /** **/
    public void insert(String key, org.ogre4j.IOverlayElement value) {
        _insert__sROgre_OverlayElementp(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__sROgre_OverlayElementp(long _pointer_, String key, long value);

}
public static class OverlayMapIterator extends org.xbig.base.NativeObject implements org.ogre4j.IOverlayManager.IOverlayMapIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public OverlayMapIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected OverlayMapIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public OverlayMapIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public OverlayMapIterator(org.ogre4j.IOverlayManager.IOverlayMap c) {
         super( new org.xbig.base.InstancePointer(__createOverlayMapIterator__Ogre_OverlayManager_OverlayMapr( c.getInstancePointer().pointer)), false);
    }

    private native static long __createOverlayMapIterator__Ogre_OverlayManager_OverlayMapr(long c);

    /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public org.ogre4j.IOverlay getNext() {
         return new org.ogre4j.Overlay(new InstancePointer(_getNext(this.object.pointer)));
    }

    private native long _getNext(long _pointer_);

    /** **/
    public org.ogre4j.IOverlay peekNextValue() {
         return new org.ogre4j.Overlay(new InstancePointer(_peekNextValue(this.object.pointer)));
    }

    private native long _peekNextValue(long _pointer_);

    /** **/
    public String peekNextKey() {
         return _peekNextKey(this.object.pointer);
    }

    private native String _peekNextKey(long _pointer_);

    /** **/
    public org.ogre4j.IOverlayManager.IOverlayMapIterator operatorAssignment(org.ogre4j.IOverlayManager.IOverlayMapIterator rhs) {
         return new org.ogre4j.OverlayManager.OverlayMapIterator(new InstancePointer(_operatorAssignment___Ogre_OverlayManager_OverlayMapIteratorr(this.object.pointer, rhs.getInstancePointer().pointer)));
    }

    private native long _operatorAssignment___Ogre_OverlayManager_OverlayMapIteratorr(long _pointer_, long rhs);

    /** **/
    public NativeObjectPointer<org.ogre4j.IOverlay> peekNextValuePtr() {
         return new NativeObjectPointer<org.ogre4j.IOverlay>(new InstancePointer(_peekNextValuePtr(this.object.pointer)));
    }

    private native long _peekNextValuePtr(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext(this.object.pointer);
    }

    private native void _moveNext(long _pointer_);

}
public static class TemplateIterator extends org.xbig.base.NativeObject implements org.ogre4j.IOverlayManager.ITemplateIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public TemplateIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected TemplateIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public TemplateIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public TemplateIterator(org.ogre4j.IOverlayManager.IElementMap c) {
         super( new org.xbig.base.InstancePointer(__createTemplateIterator__Ogre_OverlayManager_ElementMapr( c.getInstancePointer().pointer)), false);
    }

    private native static long __createTemplateIterator__Ogre_OverlayManager_ElementMapr(long c);

    /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public org.ogre4j.IOverlayElement getNext() {
         return new org.ogre4j.OverlayElement(new InstancePointer(_getNext(this.object.pointer)));
    }

    private native long _getNext(long _pointer_);

    /** **/
    public org.ogre4j.IOverlayElement peekNextValue() {
         return new org.ogre4j.OverlayElement(new InstancePointer(_peekNextValue(this.object.pointer)));
    }

    private native long _peekNextValue(long _pointer_);

    /** **/
    public String peekNextKey() {
         return _peekNextKey(this.object.pointer);
    }

    private native String _peekNextKey(long _pointer_);

    /** **/
    public org.ogre4j.IOverlayManager.ITemplateIterator operatorAssignment(org.ogre4j.IOverlayManager.ITemplateIterator rhs) {
         return new org.ogre4j.OverlayManager.TemplateIterator(new InstancePointer(_operatorAssignment___Ogre_OverlayManager_TemplateIteratorr(this.object.pointer, rhs.getInstancePointer().pointer)));
    }

    private native long _operatorAssignment___Ogre_OverlayManager_TemplateIteratorr(long _pointer_, long rhs);

    /** **/
    public NativeObjectPointer<org.ogre4j.IOverlayElement> peekNextValuePtr() {
         return new NativeObjectPointer<org.ogre4j.IOverlayElement>(new InstancePointer(_peekNextValuePtr(this.object.pointer)));
    }

    private native long _peekNextValuePtr(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext(this.object.pointer);
    }

    private native void _moveNext(long _pointer_);

}
protected static class FactoryMap extends org.xbig.base.NativeObject implements org.ogre4j.IOverlayManager.IFactoryMap {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public FactoryMap(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected FactoryMap(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public FactoryMap(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public FactoryMap() {
         super( new org.xbig.base.InstancePointer(__createFactoryMap()), false);
    }

    private native static long __createFactoryMap();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.IOverlayElementFactory get(String key) {
         return new org.ogre4j.OverlayElementFactory(new InstancePointer(_get__sR(this.object.pointer, key)));
    }

    private native long _get__sR(long _pointer_, String key);

    /** **/
    public void insert(String key, org.ogre4j.IOverlayElementFactory value) {
        _insert__sROgre_OverlayElementFactoryp(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__sROgre_OverlayElementFactoryp(long _pointer_, String key, long value);

}
protected static class LoadedScripts extends org.xbig.base.NativeObject implements org.ogre4j.IOverlayManager.ILoadedScripts {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public LoadedScripts(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected LoadedScripts(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public LoadedScripts(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public LoadedScripts() {
         super( new org.xbig.base.InstancePointer(__createLoadedScripts()), false);
    }

    private native static long __createLoadedScripts();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public OverlayManager(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected OverlayManager(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public OverlayManager(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public OverlayManager() {
         super( new org.xbig.base.InstancePointer(__createOverlayManager()), false);
    }

    private native static long __createOverlayManager();

    /** **/
    public org.ogre4j.IStringVector getScriptPatterns() {
         return new org.ogre4j.StringVector(new InstancePointer(_getScriptPatterns_const(this.object.pointer)));
    }

    private native long _getScriptPatterns_const(long _pointer_);

    /** **/
    public void parseScript(org.ogre4j.IDataStreamPtr stream, String groupName) {
        _parseScript__DataStreamPtrrStringR(this.object.pointer, stream.getInstancePointer().pointer,  groupName);
    }

    private native void _parseScript__DataStreamPtrrStringR(long _pointer_, long stream, String groupName);

    /** **/
    public float getLoadingOrder() {
         return _getLoadingOrder_const(this.object.pointer);
    }

    private native float _getLoadingOrder_const(long _pointer_);

    /** 
    Create a new . **/
    public org.ogre4j.IOverlay create(String name) {
         return new org.ogre4j.Overlay(new InstancePointer(_create__StringR(this.object.pointer, name)));
    }

    private native long _create__StringR(long _pointer_, String name);

    /** 
    Retrieve an  by name **/
    public org.ogre4j.IOverlay getByName(String name) {
         return new org.ogre4j.Overlay(new InstancePointer(_getByName__StringR(this.object.pointer, name)));
    }

    private native long _getByName__StringR(long _pointer_, String name);

    /** 
    Destroys an existing overlay by name **/
    public void destroy(String name) {
        _destroy__StringR(this.object.pointer, name);
    }

    private native void _destroy__StringR(long _pointer_, String name);

    /** 
    Destroys an existing overlay **/
    public void destroy(org.ogre4j.IOverlay overlay) {
        _destroy__Overlayp(this.object.pointer, overlay.getInstancePointer().pointer);
    }

    private native void _destroy__Overlayp(long _pointer_, long overlay);

    /** 
    Destroys all existing overlays **/
    public void destroyAll() {
        _destroyAll(this.object.pointer);
    }

    private native void _destroyAll(long _pointer_);

    /** **/
    public void getOverlayIterator(org.ogre4j.IOverlayManager.IOverlayMapIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getOverlayIterator(this.object.pointer)), false);
    }

    private native long _getOverlayIterator(long _pointer_);

    /** 
    Internal method for queueing the visible overlays for rendering. **/
    public void _queueOverlaysForRendering(org.ogre4j.ICamera cam, org.ogre4j.IRenderQueue pQueue, org.ogre4j.IViewport vp) {
        __queueOverlaysForRendering__CamerapRenderQueuepViewportp(this.object.pointer, cam.getInstancePointer().pointer,  pQueue.getInstancePointer().pointer,  vp.getInstancePointer().pointer);
    }

    private native void __queueOverlaysForRendering__CamerapRenderQueuepViewportp(long _pointer_, long cam, long pQueue, long vp);

    /** 
    Method for determining if the viewport has changed dimensions. **/
    public boolean hasViewportChanged() {
         return _hasViewportChanged_const(this.object.pointer);
    }

    private native boolean _hasViewportChanged_const(long _pointer_);

    /** 
    Gets the height of the destination viewport in pixels. **/
    public int getViewportHeight() {
         return _getViewportHeight_const(this.object.pointer);
    }

    private native int _getViewportHeight_const(long _pointer_);

    /** 
    Gets the width of the destination viewport in pixels. **/
    public int getViewportWidth() {
         return _getViewportWidth_const(this.object.pointer);
    }

    private native int _getViewportWidth_const(long _pointer_);

    /** **/
    public float getViewportAspectRatio() {
         return _getViewportAspectRatio_const(this.object.pointer);
    }

    private native float _getViewportAspectRatio_const(long _pointer_);

    /** 
    Creates a new  of the type requested. **/
    public org.ogre4j.IOverlayElement createOverlayElement(String typeName, String instanceName, boolean isTemplate) {
         return new org.ogre4j.OverlayElement(new InstancePointer(_createOverlayElement__StringRStringRbv(this.object.pointer, typeName,  instanceName,  isTemplate)));
    }

    private native long _createOverlayElement__StringRStringRbv(long _pointer_, String typeName, String instanceName, boolean isTemplate);

    /** 
    Gets a reference to an existing element. **/
    public org.ogre4j.IOverlayElement getOverlayElement(String name, boolean isTemplate) {
         return new org.ogre4j.OverlayElement(new InstancePointer(_getOverlayElement__StringRbv(this.object.pointer, name,  isTemplate)));
    }

    private native long _getOverlayElement__StringRbv(long _pointer_, String name, boolean isTemplate);

    /** 
    Destroys a . **/
    public void destroyOverlayElement(String instanceName, boolean isTemplate) {
        _destroyOverlayElement__StringRbv(this.object.pointer, instanceName,  isTemplate);
    }

    private native void _destroyOverlayElement__StringRbv(long _pointer_, String instanceName, boolean isTemplate);

    /** 
    Destroys a . **/
    public void destroyOverlayElement(org.ogre4j.IOverlayElement pInstance, boolean isTemplate) {
        _destroyOverlayElement__OverlayElementpbv(this.object.pointer, pInstance.getInstancePointer().pointer,  isTemplate);
    }

    private native void _destroyOverlayElement__OverlayElementpbv(long _pointer_, long pInstance, boolean isTemplate);

    /** 
    Destroys all the  created so far. **/
    public void destroyAllOverlayElements(boolean isTemplate) {
        _destroyAllOverlayElements__bv(this.object.pointer, isTemplate);
    }

    private native void _destroyAllOverlayElements__bv(long _pointer_, boolean isTemplate);

    /** 
    Registers a new  with this manager. **/
    public void addOverlayElementFactory(org.ogre4j.IOverlayElementFactory elemFactory) {
        _addOverlayElementFactory__OverlayElementFactoryp(this.object.pointer, elemFactory.getInstancePointer().pointer);
    }

    private native void _addOverlayElementFactory__OverlayElementFactoryp(long _pointer_, long elemFactory);

    /** **/
    public org.ogre4j.IOverlayElement createOverlayElementFromTemplate(String templateName, String typeName, String instanceName, boolean isTemplate) {
         return new org.ogre4j.OverlayElement(new InstancePointer(_createOverlayElementFromTemplate__StringRStringRStringRbv(this.object.pointer, templateName,  typeName,  instanceName,  isTemplate)));
    }

    private native long _createOverlayElementFromTemplate__StringRStringRStringRbv(long _pointer_, String templateName, String typeName, String instanceName, boolean isTemplate);

    /** 
    **/
    public org.ogre4j.IOverlayElement cloneOverlayElementFromTemplate(String templateName, String instanceName) {
         return new org.ogre4j.OverlayElement(new InstancePointer(_cloneOverlayElementFromTemplate__StringRStringR(this.object.pointer, templateName,  instanceName)));
    }

    private native long _cloneOverlayElementFromTemplate__StringRStringR(long _pointer_, String templateName, String instanceName);

    /** **/
    public org.ogre4j.IOverlayElement createOverlayElementFromFactory(String typeName, String instanceName) {
         return new org.ogre4j.OverlayElement(new InstancePointer(_createOverlayElementFromFactory__StringRStringR(this.object.pointer, typeName,  instanceName)));
    }

    private native long _createOverlayElementFromFactory__StringRStringR(long _pointer_, String typeName, String instanceName);

    /** 
    Returns an iterator over all templates in this manager. **/
    public void getTemplateIterator(org.ogre4j.IOverlayManager.ITemplateIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getTemplateIterator(this.object.pointer)), false);
    }

    private native long _getTemplateIterator(long _pointer_);

    /** **/
    public boolean isTemplate(String strName) {
         return _isTemplate__Stringv_const(this.object.pointer, strName);
    }

    private native boolean _isTemplate__Stringv_const(long _pointer_, String strName);

    /** 
    Override standard  retrieval. **/
    public static org.ogre4j.IOverlayManager getSingleton() {
         return new org.ogre4j.OverlayManager(new InstancePointer(_getSingleton()));
    }

    private native static long _getSingleton();

    /** 
    Override standard  retrieval. **/
    public static org.ogre4j.IOverlayManager getSingletonPtr() {
         return new org.ogre4j.OverlayManager(new InstancePointer(_getSingletonPtr()));
    }

    private native static long _getSingletonPtr();

}
