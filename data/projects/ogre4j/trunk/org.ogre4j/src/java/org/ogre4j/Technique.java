/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class Technique extends org.xbig.base.NativeObject implements org.ogre4j.ITechnique {
static { System.loadLibrary("ogre4j");}
public static class GPUDeviceNameRule extends org.xbig.base.NativeObject implements org.ogre4j.ITechnique.IGPUDeviceNameRule {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public GPUDeviceNameRule(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected GPUDeviceNameRule(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public GPUDeviceNameRule(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public GPUDeviceNameRule() {
         super( new org.xbig.base.InstancePointer(__createGPUDeviceNameRule()), false);
    }

    private native static long __createGPUDeviceNameRule();

    /** **/
    public GPUDeviceNameRule(String pattern, org.ogre4j.Technique.IncludeOrExclude ie, boolean caseSen) {
         super( new org.xbig.base.InstancePointer(__createGPUDeviceNameRule__StringRIncludeOrExcludevbv( pattern,  ie.getValue(),  caseSen)), false);
    }

    private native static long __createGPUDeviceNameRule__StringRIncludeOrExcludevbv(String pattern, int ie, boolean caseSen);

    /** **/
    public String getdevicePattern() {
         return _getdevicePattern(this.object.pointer);
    }

    private native String _getdevicePattern(long _pointer_);

    /** **/
    public void setdevicePattern(String _jni_value_) {
        _setdevicePattern(this.object.pointer, _jni_value_);
    }

    private native void _setdevicePattern(long _pointer_, String _jni_value_);

    /** **/
    public org.ogre4j.Technique.IncludeOrExclude getincludeOrExclude() {
         return org.ogre4j.Technique.IncludeOrExclude.toEnum(_getincludeOrExclude(this.object.pointer));
    }

    private native int _getincludeOrExclude(long _pointer_);

    /** **/
    public void setincludeOrExclude(org.ogre4j.Technique.IncludeOrExclude _jni_value_) {
        _setincludeOrExclude(this.object.pointer, _jni_value_.getValue());
    }

    private native void _setincludeOrExclude(long _pointer_, int _jni_value_);

    /** **/
    public boolean getcaseSensitive() {
         return _getcaseSensitive(this.object.pointer);
    }

    private native boolean _getcaseSensitive(long _pointer_);

    /** **/
    public void setcaseSensitive(boolean _jni_value_) {
        _setcaseSensitive(this.object.pointer, _jni_value_);
    }

    private native void _setcaseSensitive(long _pointer_, boolean _jni_value_);

}
public static class GPUVendorRule extends org.xbig.base.NativeObject implements org.ogre4j.ITechnique.IGPUVendorRule {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public GPUVendorRule(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected GPUVendorRule(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public GPUVendorRule(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public GPUVendorRule() {
         super( new org.xbig.base.InstancePointer(__createGPUVendorRule()), false);
    }

    private native static long __createGPUVendorRule();

    /** **/
    public GPUVendorRule(org.ogre4j.GPUVendor v, org.ogre4j.Technique.IncludeOrExclude ie) {
         super( new org.xbig.base.InstancePointer(__createGPUVendorRule__GPUVendorvIncludeOrExcludev( v.getValue(),  ie.getValue())), false);
    }

    private native static long __createGPUVendorRule__GPUVendorvIncludeOrExcludev(int v, int ie);

    /** **/
    public org.ogre4j.GPUVendor getvendor() {
         return org.ogre4j.GPUVendor.toEnum(_getvendor(this.object.pointer));
    }

    private native int _getvendor(long _pointer_);

    /** **/
    public void setvendor(org.ogre4j.GPUVendor _jni_value_) {
        _setvendor(this.object.pointer, _jni_value_.getValue());
    }

    private native void _setvendor(long _pointer_, int _jni_value_);

    /** **/
    public org.ogre4j.Technique.IncludeOrExclude getincludeOrExclude() {
         return org.ogre4j.Technique.IncludeOrExclude.toEnum(_getincludeOrExclude(this.object.pointer));
    }

    private native int _getincludeOrExclude(long _pointer_);

    /** **/
    public void setincludeOrExclude(org.ogre4j.Technique.IncludeOrExclude _jni_value_) {
        _setincludeOrExclude(this.object.pointer, _jni_value_.getValue());
    }

    private native void _setincludeOrExclude(long _pointer_, int _jni_value_);

}
protected enum IlluminationPassesState implements INativeEnum < IlluminationPassesState > {
    IPS_COMPILE_DISABLED(IlluminationPassesStateHelper.ENUM_VALUES[0]),
    IPS_NOT_COMPILED(IlluminationPassesStateHelper.ENUM_VALUES[1]),
    IPS_COMPILED(IlluminationPassesStateHelper.ENUM_VALUES[2]);

    private int value;

    IlluminationPassesState(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public IlluminationPassesState getEnum(int val) {
        return toEnum(val);
    }

    public static final IlluminationPassesState toEnum(int retval) {
    if (retval ==IPS_COMPILE_DISABLED.value)
        return IlluminationPassesState.IPS_COMPILE_DISABLED;
    else if (retval ==IPS_NOT_COMPILED.value)
        return IlluminationPassesState.IPS_NOT_COMPILED;
    else if (retval ==IPS_COMPILED.value)
        return IlluminationPassesState.IPS_COMPILED;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class IlluminationPassesStateHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

public enum IncludeOrExclude implements INativeEnum < IncludeOrExclude > {
    INCLUDE(IncludeOrExcludeHelper.ENUM_VALUES[0]),
    EXCLUDE(IncludeOrExcludeHelper.ENUM_VALUES[1]);

    private int value;

    IncludeOrExclude(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public IncludeOrExclude getEnum(int val) {
        return toEnum(val);
    }

    public static final IncludeOrExclude toEnum(int retval) {
    if (retval ==INCLUDE.value)
        return IncludeOrExclude.INCLUDE;
    else if (retval ==EXCLUDE.value)
        return IncludeOrExclude.EXCLUDE;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class IncludeOrExcludeHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

protected static class Passes extends org.xbig.base.NativeObject implements org.ogre4j.ITechnique.IPasses {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public Passes(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected Passes(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public Passes(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public Passes() {
         super( new org.xbig.base.InstancePointer(__createPasses()), false);
    }

    private native static long __createPasses();

    /** **/
    public void assign(int num, org.ogre4j.IPass val) {
        _assign__ivOgre_PassP(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_PassP(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.IPass at(int loc) {
         return new org.ogre4j.Pass(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.IPass back() {
         return new org.ogre4j.Pass(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.IPass front() {
         return new org.ogre4j.Pass(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.IPass val) {
        _push_back__Ogre_PassP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_PassP(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
public static class GPUVendorRuleList extends org.xbig.base.NativeObject implements org.ogre4j.ITechnique.IGPUVendorRuleList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public GPUVendorRuleList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected GPUVendorRuleList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public GPUVendorRuleList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public GPUVendorRuleList() {
         super( new org.xbig.base.InstancePointer(__createGPUVendorRuleList()), false);
    }

    private native static long __createGPUVendorRuleList();

    /** **/
    public void assign(int num, org.ogre4j.ITechnique.IGPUVendorRule val) {
        _assign__ivOgre_Technique_GPUVendorRuleR(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_Technique_GPUVendorRuleR(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.ITechnique.IGPUVendorRule at(int loc) {
         return new org.ogre4j.Technique.GPUVendorRule(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.ITechnique.IGPUVendorRule back() {
         return new org.ogre4j.Technique.GPUVendorRule(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.ITechnique.IGPUVendorRule front() {
         return new org.ogre4j.Technique.GPUVendorRule(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.ITechnique.IGPUVendorRule val) {
        _push_back__Ogre_Technique_GPUVendorRuleR(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_Technique_GPUVendorRuleR(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
public static class GPUDeviceNameRuleList extends org.xbig.base.NativeObject implements org.ogre4j.ITechnique.IGPUDeviceNameRuleList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public GPUDeviceNameRuleList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected GPUDeviceNameRuleList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public GPUDeviceNameRuleList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public GPUDeviceNameRuleList() {
         super( new org.xbig.base.InstancePointer(__createGPUDeviceNameRuleList()), false);
    }

    private native static long __createGPUDeviceNameRuleList();

    /** **/
    public void assign(int num, org.ogre4j.ITechnique.IGPUDeviceNameRule val) {
        _assign__ivOgre_Technique_GPUDeviceNameRuleR(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_Technique_GPUDeviceNameRuleR(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.ITechnique.IGPUDeviceNameRule at(int loc) {
         return new org.ogre4j.Technique.GPUDeviceNameRule(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.ITechnique.IGPUDeviceNameRule back() {
         return new org.ogre4j.Technique.GPUDeviceNameRule(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.ITechnique.IGPUDeviceNameRule front() {
         return new org.ogre4j.Technique.GPUDeviceNameRule(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.ITechnique.IGPUDeviceNameRule val) {
        _push_back__Ogre_Technique_GPUDeviceNameRuleR(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_Technique_GPUDeviceNameRuleR(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
public static class PassIterator extends org.xbig.base.NativeObject implements org.ogre4j.ITechnique.IPassIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public PassIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected PassIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public PassIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public org.ogre4j.IPass getNext() {
         return new org.ogre4j.Pass(new InstancePointer(_getNext(this.object.pointer)));
    }

    private native long _getNext(long _pointer_);

    /** **/
    public org.ogre4j.IPass peekNext() {
         return new org.ogre4j.Pass(new InstancePointer(_peekNext(this.object.pointer)));
    }

    private native long _peekNext(long _pointer_);

    /** **/
    public NativeObjectPointer<org.ogre4j.IPass> peekNextPtr() {
         return new NativeObjectPointer<org.ogre4j.IPass>(new InstancePointer(_peekNextPtr(this.object.pointer)));
    }

    private native long _peekNextPtr(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext(this.object.pointer);
    }

    private native void _moveNext(long _pointer_);

}
public static class IlluminationPassIterator extends org.xbig.base.NativeObject implements org.ogre4j.ITechnique.IIlluminationPassIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public IlluminationPassIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected IlluminationPassIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public IlluminationPassIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public IlluminationPassIterator(org.ogre4j.IIlluminationPassList c) {
         super( new org.xbig.base.InstancePointer(__createIlluminationPassIterator__Ogre_IlluminationPassListr( c.getInstancePointer().pointer)), false);
    }

    private native static long __createIlluminationPassIterator__Ogre_IlluminationPassListr(long c);

    /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public org.ogre4j.IIlluminationPass getNext() {
         return new org.ogre4j.IlluminationPass(new InstancePointer(_getNext(this.object.pointer)));
    }

    private native long _getNext(long _pointer_);

    /** **/
    public org.ogre4j.IIlluminationPass peekNext() {
         return new org.ogre4j.IlluminationPass(new InstancePointer(_peekNext(this.object.pointer)));
    }

    private native long _peekNext(long _pointer_);

    /** **/
    public NativeObjectPointer<org.ogre4j.IIlluminationPass> peekNextPtr() {
         return new NativeObjectPointer<org.ogre4j.IIlluminationPass>(new InstancePointer(_peekNextPtr(this.object.pointer)));
    }

    private native long _peekNextPtr(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext(this.object.pointer);
    }

    private native void _moveNext(long _pointer_);

}
public static class GPUVendorRuleIterator extends org.xbig.base.NativeObject implements org.ogre4j.ITechnique.IGPUVendorRuleIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public GPUVendorRuleIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected GPUVendorRuleIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public GPUVendorRuleIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public GPUVendorRuleIterator(org.ogre4j.ITechnique.IGPUVendorRuleList c) {
         super( new org.xbig.base.InstancePointer(__createGPUVendorRuleIterator__Ogre_Technique_GPUVendorRuleListR( c.getInstancePointer().pointer)), false);
    }

    private native static long __createGPUVendorRuleIterator__Ogre_Technique_GPUVendorRuleListR(long c);

    /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public void getNext(org.ogre4j.ITechnique.IGPUVendorRule returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getNext(this.object.pointer)), false);
    }

    private native long _getNext(long _pointer_);

    /** **/
    public void peekNext(org.ogre4j.ITechnique.IGPUVendorRule returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_peekNext_const(this.object.pointer)), false);
    }

    private native long _peekNext_const(long _pointer_);

    /** **/
    public org.ogre4j.ITechnique.IGPUVendorRule peekNextPtr() {
         return new org.ogre4j.Technique.GPUVendorRule(new InstancePointer(_peekNextPtr_const(this.object.pointer)));
    }

    private native long _peekNextPtr_const(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext_const(this.object.pointer);
    }

    private native void _moveNext_const(long _pointer_);

}
public static class GPUDeviceNameRuleIterator extends org.xbig.base.NativeObject implements org.ogre4j.ITechnique.IGPUDeviceNameRuleIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public GPUDeviceNameRuleIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected GPUDeviceNameRuleIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public GPUDeviceNameRuleIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public GPUDeviceNameRuleIterator(org.ogre4j.ITechnique.IGPUDeviceNameRuleList c) {
         super( new org.xbig.base.InstancePointer(__createGPUDeviceNameRuleIterator__Ogre_Technique_GPUDeviceNameRuleListR( c.getInstancePointer().pointer)), false);
    }

    private native static long __createGPUDeviceNameRuleIterator__Ogre_Technique_GPUDeviceNameRuleListR(long c);

    /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public void getNext(org.ogre4j.ITechnique.IGPUDeviceNameRule returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getNext(this.object.pointer)), false);
    }

    private native long _getNext(long _pointer_);

    /** **/
    public void peekNext(org.ogre4j.ITechnique.IGPUDeviceNameRule returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_peekNext_const(this.object.pointer)), false);
    }

    private native long _peekNext_const(long _pointer_);

    /** **/
    public org.ogre4j.ITechnique.IGPUDeviceNameRule peekNextPtr() {
         return new org.ogre4j.Technique.GPUDeviceNameRule(new InstancePointer(_peekNextPtr_const(this.object.pointer)));
    }

    private native long _peekNextPtr_const(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext_const(this.object.pointer);
    }

    private native void _moveNext_const(long _pointer_);

}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public Technique(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected Technique(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public Technique(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public Technique(org.ogre4j.IMaterial parent) {
         super( new org.xbig.base.InstancePointer(__createTechnique__Materialp( parent.getInstancePointer().pointer)), false);
    }

    private native static long __createTechnique__Materialp(long parent);

    /** **/
    public Technique(org.ogre4j.IMaterial parent, org.ogre4j.ITechnique oth) {
         super( new org.xbig.base.InstancePointer(__createTechnique__MaterialpTechniqueR( parent.getInstancePointer().pointer,  oth.getInstancePointer().pointer)), false);
    }

    private native static long __createTechnique__MaterialpTechniqueR(long parent, long oth);

    /** 
    Indicates if this technique is supported by the current graphics card. **/
    public boolean isSupported() {
         return _isSupported_const(this.object.pointer);
    }

    private native boolean _isSupported_const(long _pointer_);

    /** 
    Internal compilation method; see . **/
    public String _compile(boolean autoManageTextureUnits) {
         return __compile__bv(this.object.pointer, autoManageTextureUnits);
    }

    private native String __compile__bv(long _pointer_, boolean autoManageTextureUnits);

    /** **/
    public boolean checkGPURules(org.std.Iostringstream errors) {
         return _checkGPURules__StringUtil_StrStreamTyper(this.object.pointer, errors.getInstancePointer().pointer);
    }

    private native boolean _checkGPURules__StringUtil_StrStreamTyper(long _pointer_, long errors);

    /** **/
    public boolean checkHardwareSupport(boolean autoManageTextureUnits, org.std.Iostringstream compileErrors) {
         return _checkHardwareSupport__bvStringUtil_StrStreamTyper(this.object.pointer, autoManageTextureUnits,  compileErrors.getInstancePointer().pointer);
    }

    private native boolean _checkHardwareSupport__bvStringUtil_StrStreamTyper(long _pointer_, boolean autoManageTextureUnits, long compileErrors);

    /** 
    Internal method for splitting the passes into illumination passes. **/
    public void _compileIlluminationPasses() {
        __compileIlluminationPasses(this.object.pointer);
    }

    private native void __compileIlluminationPasses(long _pointer_);

    /** 
    Creates a new  for this . **/
    public org.ogre4j.IPass createPass() {
         return new org.ogre4j.Pass(new InstancePointer(_createPass(this.object.pointer)));
    }

    private native long _createPass(long _pointer_);

    /** 
    Retrieves the  with the given index. **/
    public org.ogre4j.IPass getPass(int index) {
         return new org.ogre4j.Pass(new InstancePointer(_getPass__Hv(this.object.pointer, index)));
    }

    private native long _getPass__Hv(long _pointer_, int index);

    /** 
    Retrieves the  matching name. Returns 0 if name match is not found. **/
    public org.ogre4j.IPass getPass(String name) {
         return new org.ogre4j.Pass(new InstancePointer(_getPass__StringR(this.object.pointer, name)));
    }

    private native long _getPass__StringR(long _pointer_, String name);

    /** 
    Retrieves the number of passes. **/
    public int getNumPasses() {
         return _getNumPasses_const(this.object.pointer);
    }

    private native int _getNumPasses_const(long _pointer_);

    /** 
    Removes the  with the given index. **/
    public void removePass(int index) {
        _removePass__Hv(this.object.pointer, index);
    }

    private native void _removePass__Hv(long _pointer_, int index);

    /** 
    Removes all Passes from this . **/
    public void removeAllPasses() {
        _removeAllPasses(this.object.pointer);
    }

    private native void _removeAllPasses(long _pointer_);

    /** 
    Move a pass from source index to destination index. If successful then returns true. **/
    public boolean movePass(int sourceIndex, int destinationIndex) {
         return _movePass__HVHV(this.object.pointer, sourceIndex,  destinationIndex);
    }

    private native boolean _movePass__HVHV(long _pointer_, int sourceIndex, int destinationIndex);

    /** 
    Gets an iterator over the passes in this . **/
    public void getPassIterator(org.ogre4j.ITechnique.IPassIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getPassIterator(this.object.pointer)), false);
    }

    private native long _getPassIterator(long _pointer_);

    /** 
    Gets an iterator over the illumination-stage categorised passes. **/
    public void getIlluminationPassIterator(org.ogre4j.ITechnique.IIlluminationPassIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getIlluminationPassIterator(this.object.pointer)), false);
    }

    private native long _getIlluminationPassIterator(long _pointer_);

    /** **/
    public org.ogre4j.IMaterial getParent() {
         return new org.ogre4j.Material(new InstancePointer(_getParent_const(this.object.pointer)));
    }

    private native long _getParent_const(long _pointer_);

    /** 
    Overloaded operator to copy on  to another. **/
    public org.ogre4j.ITechnique operatorAssignment(org.ogre4j.ITechnique rhs) {
         return new org.ogre4j.Technique(new InstancePointer(_operatorAssignment__TechniqueR(this.object.pointer, rhs.getInstancePointer().pointer)));
    }

    private native long _operatorAssignment__TechniqueR(long _pointer_, long rhs);

    /** **/
    public String getResourceGroup() {
         return _getResourceGroup_const(this.object.pointer);
    }

    private native String _getResourceGroup_const(long _pointer_);

    /** 
    Returns true if this  involves transparency. **/
    public boolean isTransparent() {
         return _isTransparent_const(this.object.pointer);
    }

    private native boolean _isTransparent_const(long _pointer_);

    /** 
    Returns true if this  has transparent sorting enabled. **/
    public boolean isTransparentSortingEnabled() {
         return _isTransparentSortingEnabled_const(this.object.pointer);
    }

    private native boolean _isTransparentSortingEnabled_const(long _pointer_);

    /** 
    Internal prepare method, derived from call to . **/
    public void _prepare() {
        __prepare(this.object.pointer);
    }

    private native void __prepare(long _pointer_);

    /** 
    Internal unprepare method, derived from call to Material::unprepare. **/
    public void _unprepare() {
        __unprepare(this.object.pointer);
    }

    private native void __unprepare(long _pointer_);

    /** 
    Internal load method, derived from call to . **/
    public void _load() {
        __load(this.object.pointer);
    }

    private native void __load(long _pointer_);

    /** 
    Internal unload method, derived from call to . **/
    public void _unload() {
        __unload(this.object.pointer);
    }

    private native void __unload(long _pointer_);

    /** **/
    public boolean isLoaded() {
         return _isLoaded_const(this.object.pointer);
    }

    private native boolean _isLoaded_const(long _pointer_);

    /** 
    Tells the technique that it needs recompilation. **/
    public void _notifyNeedsRecompile() {
        __notifyNeedsRecompile(this.object.pointer);
    }

    private native void __notifyNeedsRecompile(long _pointer_);

    /** 
    return this material specific shadow casting specific material **/
    public void getShadowCasterMaterial(org.ogre4j.IMaterialPtr returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getShadowCasterMaterial_const(this.object.pointer)), false);
    }

    private native long _getShadowCasterMaterial_const(long _pointer_);

    /** 
    set this material specific shadow casting specific material **/
    public void setShadowCasterMaterial(org.ogre4j.IMaterialPtr val) {
        _setShadowCasterMaterial__Ogre_MaterialPtrv(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _setShadowCasterMaterial__Ogre_MaterialPtrv(long _pointer_, long val);

    /** 
    set this material specific shadow casting specific material **/
    public void setShadowCasterMaterial(String name) {
        _setShadowCasterMaterial__Ogre_StringR(this.object.pointer, name);
    }

    private native void _setShadowCasterMaterial__Ogre_StringR(long _pointer_, String name);

    /** 
    return this material specific shadow receiving specific material **/
    public void getShadowReceiverMaterial(org.ogre4j.IMaterialPtr returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getShadowReceiverMaterial_const(this.object.pointer)), false);
    }

    private native long _getShadowReceiverMaterial_const(long _pointer_);

    /** 
    set this material specific shadow receiving specific material **/
    public void setShadowReceiverMaterial(org.ogre4j.IMaterialPtr val) {
        _setShadowReceiverMaterial__Ogre_MaterialPtrv(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _setShadowReceiverMaterial__Ogre_MaterialPtrv(long _pointer_, long val);

    /** 
    set this material specific shadow receiving specific material **/
    public void setShadowReceiverMaterial(String name) {
        _setShadowReceiverMaterial__Ogre_StringR(this.object.pointer, name);
    }

    private native void _setShadowReceiverMaterial__Ogre_StringR(long _pointer_, String name);

    /** 
    Sets the point size properties for every  in this . **/
    public void setPointSize(float ps) {
        _setPointSize__Realv(this.object.pointer, ps);
    }

    private native void _setPointSize__Realv(long _pointer_, float ps);

    /** 
    Sets the ambient colour reflectance properties for every  in every . **/
    public void setAmbient(float red, float green, float blue) {
        _setAmbient__RealvRealvRealv(this.object.pointer, red,  green,  blue);
    }

    private native void _setAmbient__RealvRealvRealv(long _pointer_, float red, float green, float blue);

    /** 
    Sets the ambient colour reflectance properties for every  in every . **/
    public void setAmbient(org.ogre4j.IColourValue ambient) {
        _setAmbient__ColourValueR(this.object.pointer, ambient.getInstancePointer().pointer);
    }

    private native void _setAmbient__ColourValueR(long _pointer_, long ambient);

    /** 
    Sets the diffuse colour reflectance properties of every  in every . **/
    public void setDiffuse(float red, float green, float blue, float alpha) {
        _setDiffuse__RealvRealvRealvRealv(this.object.pointer, red,  green,  blue,  alpha);
    }

    private native void _setDiffuse__RealvRealvRealvRealv(long _pointer_, float red, float green, float blue, float alpha);

    /** 
    Sets the diffuse colour reflectance properties of every  in every . **/
    public void setDiffuse(org.ogre4j.IColourValue diffuse) {
        _setDiffuse__ColourValueR(this.object.pointer, diffuse.getInstancePointer().pointer);
    }

    private native void _setDiffuse__ColourValueR(long _pointer_, long diffuse);

    /** 
    Sets the specular colour reflectance properties of every  in every . **/
    public void setSpecular(float red, float green, float blue, float alpha) {
        _setSpecular__RealvRealvRealvRealv(this.object.pointer, red,  green,  blue,  alpha);
    }

    private native void _setSpecular__RealvRealvRealvRealv(long _pointer_, float red, float green, float blue, float alpha);

    /** 
    Sets the specular colour reflectance properties of every  in every . **/
    public void setSpecular(org.ogre4j.IColourValue specular) {
        _setSpecular__ColourValueR(this.object.pointer, specular.getInstancePointer().pointer);
    }

    private native void _setSpecular__ColourValueR(long _pointer_, long specular);

    /** 
    Sets the shininess properties of every  in every . **/
    public void setShininess(float val) {
        _setShininess__Realv(this.object.pointer, val);
    }

    private native void _setShininess__Realv(long _pointer_, float val);

    /** 
    Sets the amount of self-illumination of every  in every . **/
    public void setSelfIllumination(float red, float green, float blue) {
        _setSelfIllumination__RealvRealvRealv(this.object.pointer, red,  green,  blue);
    }

    private native void _setSelfIllumination__RealvRealvRealv(long _pointer_, float red, float green, float blue);

    /** 
    Sets the amount of self-illumination of every  in every . **/
    public void setSelfIllumination(org.ogre4j.IColourValue selfIllum) {
        _setSelfIllumination__ColourValueR(this.object.pointer, selfIllum.getInstancePointer().pointer);
    }

    private native void _setSelfIllumination__ColourValueR(long _pointer_, long selfIllum);

    /** 
    Sets whether or not each  renders with depth-buffer checking on or not. **/
    public void setDepthCheckEnabled(boolean enabled) {
        _setDepthCheckEnabled__bv(this.object.pointer, enabled);
    }

    private native void _setDepthCheckEnabled__bv(long _pointer_, boolean enabled);

    /** 
    Sets whether or not each  renders with depth-buffer writing on or not. **/
    public void setDepthWriteEnabled(boolean enabled) {
        _setDepthWriteEnabled__bv(this.object.pointer, enabled);
    }

    private native void _setDepthWriteEnabled__bv(long _pointer_, boolean enabled);

    /** 
    Sets the function used to compare depth values when depth checking is on. **/
    public void setDepthFunction(org.ogre4j.CompareFunction func) {
        _setDepthFunction__CompareFunctionv(this.object.pointer, func.getValue());
    }

    private native void _setDepthFunction__CompareFunctionv(long _pointer_, int func);

    /** 
    Sets whether or not colour buffer writing is enabled for each . **/
    public void setColourWriteEnabled(boolean enabled) {
        _setColourWriteEnabled__bv(this.object.pointer, enabled);
    }

    private native void _setColourWriteEnabled__bv(long _pointer_, boolean enabled);

    /** 
    Sets the culling mode for each pass based on the 'vertex winding'. **/
    public void setCullingMode(org.ogre4j.CullingMode mode) {
        _setCullingMode__CullingModev(this.object.pointer, mode.getValue());
    }

    private native void _setCullingMode__CullingModev(long _pointer_, int mode);

    /** 
    Sets the manual culling mode, performed by CPU rather than hardware. **/
    public void setManualCullingMode(org.ogre4j.ManualCullingMode mode) {
        _setManualCullingMode__ManualCullingModev(this.object.pointer, mode.getValue());
    }

    private native void _setManualCullingMode__ManualCullingModev(long _pointer_, int mode);

    /** 
    Sets whether or not dynamic lighting is enabled for every . **/
    public void setLightingEnabled(boolean enabled) {
        _setLightingEnabled__bv(this.object.pointer, enabled);
    }

    private native void _setLightingEnabled__bv(long _pointer_, boolean enabled);

    /** 
    Sets the type of light shading required **/
    public void setShadingMode(org.ogre4j.ShadeOptions mode) {
        _setShadingMode__ShadeOptionsv(this.object.pointer, mode.getValue());
    }

    private native void _setShadingMode__ShadeOptionsv(long _pointer_, int mode);

    /** 
    Sets the fogging mode applied to each pass. **/
    public void setFog(boolean overrideScene, org.ogre4j.FogMode mode, org.ogre4j.IColourValue colour, float expDensity, float linearStart, float linearEnd) {
        _setFog__bvFogModevColourValueRRealvRealvRealv(this.object.pointer, overrideScene,  mode.getValue(),  colour.getInstancePointer().pointer,  expDensity,  linearStart,  linearEnd);
    }

    private native void _setFog__bvFogModevColourValueRRealvRealvRealv(long _pointer_, boolean overrideScene, int mode, long colour, float expDensity, float linearStart, float linearEnd);

    /** 
    Sets the depth bias to be used for each . **/
    public void setDepthBias(float constantBias, float slopeScaleBias) {
        _setDepthBias__FvFv(this.object.pointer, constantBias,  slopeScaleBias);
    }

    private native void _setDepthBias__FvFv(long _pointer_, float constantBias, float slopeScaleBias);

    /** 
    Set texture filtering for every texture unit in every **/
    public void setTextureFiltering(org.ogre4j.TextureFilterOptions filterType) {
        _setTextureFiltering__TextureFilterOptionsv(this.object.pointer, filterType.getValue());
    }

    private native void _setTextureFiltering__TextureFilterOptionsv(long _pointer_, int filterType);

    /** 
    Sets the anisotropy level to be used for all textures. **/
    public void setTextureAnisotropy(long maxAniso) {
        _setTextureAnisotropy__Iv(this.object.pointer, maxAniso);
    }

    private native void _setTextureAnisotropy__Iv(long _pointer_, long maxAniso);

    /** 
    Sets the kind of blending every pass has with the existing contents of the scene. **/
    public void setSceneBlending(org.ogre4j.SceneBlendType sbt) {
        _setSceneBlending__SceneBlendTypeV(this.object.pointer, sbt.getValue());
    }

    private native void _setSceneBlending__SceneBlendTypeV(long _pointer_, int sbt);

    /** 
    Sets the kind of blending every pass has with the existing contents of the scene, using individual factors both color and alpha channels **/
    public void setSeparateSceneBlending(org.ogre4j.SceneBlendType sbt, org.ogre4j.SceneBlendType sbta) {
        _setSeparateSceneBlending__SceneBlendTypeVSceneBlendTypeV(this.object.pointer, sbt.getValue(),  sbta.getValue());
    }

    private native void _setSeparateSceneBlending__SceneBlendTypeVSceneBlendTypeV(long _pointer_, int sbt, int sbta);

    /** 
    Allows very fine control of blending every  with the existing contents of the scene. **/
    public void setSceneBlending(org.ogre4j.SceneBlendFactor sourceFactor, org.ogre4j.SceneBlendFactor destFactor) {
        _setSceneBlending__SceneBlendFactorVSceneBlendFactorV(this.object.pointer, sourceFactor.getValue(),  destFactor.getValue());
    }

    private native void _setSceneBlending__SceneBlendFactorVSceneBlendFactorV(long _pointer_, int sourceFactor, int destFactor);

    /** 
    Allows very fine control of blending every  with the existing contents of the scene, using individual factors both color and alpha channels **/
    public void setSeparateSceneBlending(org.ogre4j.SceneBlendFactor sourceFactor, org.ogre4j.SceneBlendFactor destFactor, org.ogre4j.SceneBlendFactor sourceFactorAlpha, org.ogre4j.SceneBlendFactor destFactorAlpha) {
        _setSeparateSceneBlending__SceneBlendFactorVSceneBlendFactorVSceneBlendFactorVSceneBlendFactorV(this.object.pointer, sourceFactor.getValue(),  destFactor.getValue(),  sourceFactorAlpha.getValue(),  destFactorAlpha.getValue());
    }

    private native void _setSeparateSceneBlending__SceneBlendFactorVSceneBlendFactorVSceneBlendFactorVSceneBlendFactorV(long _pointer_, int sourceFactor, int destFactor, int sourceFactorAlpha, int destFactorAlpha);

    /** 
    Assigns a level-of-detail (LOD) index to this . **/
    public void setLodIndex(int index) {
        _setLodIndex__Hv(this.object.pointer, index);
    }

    private native void _setLodIndex__Hv(long _pointer_, int index);

    /** 
    Gets the level-of-detail index assigned to this . **/
    public int getLodIndex() {
         return _getLodIndex_const(this.object.pointer);
    }

    private native int _getLodIndex_const(long _pointer_);

    /** 
    Set the 'scheme name' for this technique. **/
    public void setSchemeName(String schemeName) {
        _setSchemeName__StringR(this.object.pointer, schemeName);
    }

    private native void _setSchemeName__StringR(long _pointer_, String schemeName);

    /** 
    Returns the scheme to which this technique is assigned. **/
    public String getSchemeName() {
         return _getSchemeName_const(this.object.pointer);
    }

    private native String _getSchemeName_const(long _pointer_);

    /** **/
    public int _getSchemeIndex() {
         return __getSchemeIndex_const(this.object.pointer);
    }

    private native int __getSchemeIndex_const(long _pointer_);

    /** 
    Is depth writing going to occur on this technique? **/
    public boolean isDepthWriteEnabled() {
         return _isDepthWriteEnabled_const(this.object.pointer);
    }

    private native boolean _isDepthWriteEnabled_const(long _pointer_);

    /** 
    Is depth checking going to occur on this technique? **/
    public boolean isDepthCheckEnabled() {
         return _isDepthCheckEnabled_const(this.object.pointer);
    }

    private native boolean _isDepthCheckEnabled_const(long _pointer_);

    /** 
    Exists colour writing disabled pass on this technique? **/
    public boolean hasColourWriteDisabled() {
         return _hasColourWriteDisabled_const(this.object.pointer);
    }

    private native boolean _hasColourWriteDisabled_const(long _pointer_);

    /** 
    Set the name of the technique. **/
    public void setName(String name) {
        _setName__StringR(this.object.pointer, name);
    }

    private native void _setName__StringR(long _pointer_, String name);

    /** **/
    public String getName() {
         return _getName_const(this.object.pointer);
    }

    private native String _getName_const(long _pointer_);

    /** 
    Applies texture names to  Unit State with matching texture name aliases. All passes, and  Unit States within the technique are checked. If matching texture aliases are found then true is returned.
    **/
    public boolean applyTextureAliases(org.ogre4j.IAliasTextureNamePairList aliasList, boolean apply) {
         return _applyTextureAliases__AliasTextureNamePairListRbV_const(this.object.pointer, aliasList.getInstancePointer().pointer,  apply);
    }

    private native boolean _applyTextureAliases__AliasTextureNamePairListRbV_const(long _pointer_, long aliasList, boolean apply);

    /** 
    Add a rule which manually influences the support for this technique based on a GPU vendor. **/
    public void addGPUVendorRule(org.ogre4j.GPUVendor vendor, org.ogre4j.Technique.IncludeOrExclude includeOrExclude) {
        _addGPUVendorRule__GPUVendorvIncludeOrExcludev(this.object.pointer, vendor.getValue(),  includeOrExclude.getValue());
    }

    private native void _addGPUVendorRule__GPUVendorvIncludeOrExcludev(long _pointer_, int vendor, int includeOrExclude);

    /** 
    Add a rule which manually influences the support for this technique based on a GPU vendor. **/
    public void addGPUVendorRule(org.ogre4j.ITechnique.IGPUVendorRule rule) {
        _addGPUVendorRule__GPUVendorRuleR(this.object.pointer, rule.getInstancePointer().pointer);
    }

    private native void _addGPUVendorRule__GPUVendorRuleR(long _pointer_, long rule);

    /** 
    Removes a matching vendor rule. **/
    public void removeGPUVendorRule(org.ogre4j.GPUVendor vendor) {
        _removeGPUVendorRule__GPUVendorv(this.object.pointer, vendor.getValue());
    }

    private native void _removeGPUVendorRule__GPUVendorv(long _pointer_, int vendor);

    /** **/
    public void getGPUVendorRuleIterator(org.ogre4j.ITechnique.IGPUVendorRuleIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getGPUVendorRuleIterator_const(this.object.pointer)), false);
    }

    private native long _getGPUVendorRuleIterator_const(long _pointer_);

    /** 
    Add a rule which manually influences the support for this technique based on a pattern that matches a GPU device name (e.g. '*8800*'). **/
    public void addGPUDeviceNameRule(String devicePattern, org.ogre4j.Technique.IncludeOrExclude includeOrExclude, boolean caseSensitive) {
        _addGPUDeviceNameRule__StringRIncludeOrExcludevbv(this.object.pointer, devicePattern,  includeOrExclude.getValue(),  caseSensitive);
    }

    private native void _addGPUDeviceNameRule__StringRIncludeOrExcludevbv(long _pointer_, String devicePattern, int includeOrExclude, boolean caseSensitive);

    /** 
    Add a rule which manually influences the support for this technique based on a pattern that matches a GPU device name (e.g. '*8800*'). **/
    public void addGPUDeviceNameRule(org.ogre4j.ITechnique.IGPUDeviceNameRule rule) {
        _addGPUDeviceNameRule__GPUDeviceNameRuleR(this.object.pointer, rule.getInstancePointer().pointer);
    }

    private native void _addGPUDeviceNameRule__GPUDeviceNameRuleR(long _pointer_, long rule);

    /** 
    Removes a matching device name rule. **/
    public void removeGPUDeviceNameRule(String devicePattern) {
        _removeGPUDeviceNameRule__StringR(this.object.pointer, devicePattern);
    }

    private native void _removeGPUDeviceNameRule__StringR(long _pointer_, String devicePattern);

    /** **/
    public void getGPUDeviceNameRuleIterator(org.ogre4j.ITechnique.IGPUDeviceNameRuleIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getGPUDeviceNameRuleIterator_const(this.object.pointer)), false);
    }

    private native long _getGPUDeviceNameRuleIterator_const(long _pointer_);

}
