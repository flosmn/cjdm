/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public interface IPixelBox extends INativeObject, org.ogre4j.IBox {

    /** 
    Set the rowPitch and slicePitch so that the buffer is laid out consecutive in memory. **/
    public void setConsecutive();

    /** 
    Get the number of elements between one past the rightmost pixel of one row and the leftmost pixel of the next row. (IE this is zero if rows are consecutive). **/
    public int getRowSkip();

    /** 
    Get the number of elements between one past the right bottom pixel of one slice and the left top pixel of the next slice. (IE this is zero if slices are consecutive). **/
    public int getSliceSkip();

    /** 
    Return whether this buffer is laid out consecutive in memory (ie the pitches are equal to the dimensions) **/
    public boolean isConsecutive();

    /** 
    Return the size (in bytes) this image would take if it was laid out consecutive in memory **/
    public int getConsecutiveSize();

    /** 
    Return a subvolume of this . **/
    public void getSubVolume(org.ogre4j.IPixelBox returnValue, org.ogre4j.IBox def);

    /** **/
    public VoidPointer getdata();

    /** **/
    public void setdata(VoidPointer _jni_value_);

    /** **/
    public org.ogre4j.PixelFormat getformat();

    /** **/
    public void setformat(org.ogre4j.PixelFormat _jni_value_);

    /** **/
    public int getrowPitch();

    /** **/
    public void setrowPitch(int _jni_value_);

    /** **/
    public int getslicePitch();

    /** **/
    public void setslicePitch(int _jni_value_);

}
