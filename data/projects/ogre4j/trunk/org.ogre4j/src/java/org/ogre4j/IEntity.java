/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public interface IEntity extends INativeObject, org.ogre4j.IMovableObject, org.ogre4j.IMovableObject.IListener {

public static interface IEntityShadowRenderable extends INativeObject, org.ogre4j.IShadowRenderable {

    /** **/
    public void getWorldTransforms(org.ogre4j.IMatrix4 xform);

    /** **/
    public void getPositionBuffer(org.ogre4j.IHardwareVertexBufferSharedPtr returnValue);

    /** **/
    public void getWBuffer(org.ogre4j.IHardwareVertexBufferSharedPtr returnValue);

    /** **/
    public void rebindPositionBuffer(org.ogre4j.IVertexData vertexData, boolean force);

    /** **/
    public boolean isVisible();

}
public interface IEntitySet extends INativeObject, org.std.Iset< org.ogre4j.IEntity > {

    /** **/
    public void clear();

    /** **/
    public int count(org.ogre4j.IEntity key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(org.ogre4j.IEntity key);

    /** **/
    public int max_size();

    /** **/
    public int size();

}
public interface IChildObjectList extends INativeObject, org.std.Imap< String, org.ogre4j.IMovableObject > {

    /** **/
    public void clear();

    /** **/
    public int count(String key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(String key);

    /** **/
    public int max_size();

    /** **/
    public int size();

    /** **/
    public org.ogre4j.IMovableObject get(String key);

    /** **/
    public void insert(String key, org.ogre4j.IMovableObject value);

}
public interface IChildObjectListIterator extends INativeObject, org.ogre4j.IMapIterator< org.ogre4j.IEntity.IChildObjectList > {

    /** **/
    public boolean hasMoreElements();

    /** **/
    public org.ogre4j.IMovableObject getNext();

    /** **/
    public org.ogre4j.IMovableObject peekNextValue();

    /** **/
    public String peekNextKey();

    /** **/
    public org.ogre4j.IEntity.IChildObjectListIterator operatorAssignment(org.ogre4j.IEntity.IChildObjectListIterator rhs);

    /** **/
    public NativeObjectPointer<org.ogre4j.IMovableObject> peekNextValuePtr();

    /** **/
    public void moveNext();

}
public interface ISubEntityList extends INativeObject, org.std.Ivector< org.ogre4j.ISubEntity > {

    /** **/
    public void assign(int num, org.ogre4j.ISubEntity val);

    /** **/
    public org.ogre4j.ISubEntity at(int loc);

    /** **/
    public org.ogre4j.ISubEntity back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public org.ogre4j.ISubEntity front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(org.ogre4j.ISubEntity val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
public interface ILODEntityList extends INativeObject, org.std.Ivector< org.ogre4j.IEntity > {

    /** **/
    public void assign(int num, org.ogre4j.IEntity val);

    /** **/
    public org.ogre4j.IEntity at(int loc);

    /** **/
    public org.ogre4j.IEntity back();

    /** **/
    public int capacity();

    /** **/
    public void clear();

    /** **/
    public boolean empty();

    /** **/
    public org.ogre4j.IEntity front();

    /** **/
    public int max_size();

    /** **/
    public void pop_back();

    /** **/
    public void push_back(org.ogre4j.IEntity val);

    /** **/
    public void reserve(int size);

    /** **/
    public int size();

}
    /** 
    Gets the  that this  is based on. **/
    public org.ogre4j.IMeshPtr getMesh();

    /** 
    Gets a pointer to a , ie a part of an . **/
    public org.ogre4j.ISubEntity getSubEntity(long index);

    /** 
    Gets a pointer to a  by name **/
    public org.ogre4j.ISubEntity getSubEntity(String name);

    /** 
    Retrieves the number of  objects making up this entity. **/
    public long getNumSubEntities();

    /** 
    Clones this entity and returns a pointer to the clone. **/
    public org.ogre4j.IEntity clone(String newName);

    /** 
    Sets the material to use for the whole of this entity. **/
    public void setMaterialName(String name);

    /** 
    Overridden - see . **/
    public void _notifyCurrentCamera(org.ogre4j.ICamera cam);

    /** **/
    public void setRenderQueueGroup(short queueID);

    /** 
    Overridden - see . **/
    public org.ogre4j.IAxisAlignedBox getBoundingBox();

    /** **/
    public void getChildObjectsBoundingBox(org.ogre4j.IAxisAlignedBox returnValue);

    /** 
    Overridden - see . **/
    public void _updateRenderQueue(org.ogre4j.IRenderQueue queue);

    /** 
    Overridden from **/
    public String getMovableType();

    /** 
    For entities based on animated meshes, gets the  object for a single animation. **/
    public org.ogre4j.IAnimationState getAnimationState(String name);

    /** 
    For entities based on animated meshes, gets the  objects for all animations. **/
    public org.ogre4j.IAnimationStateSet getAllAnimationStates();

    /** 
    Tells the  whether or not it should display it's skeleton, if it has one. **/
    public void setDisplaySkeleton(boolean display);

    /** 
    Returns whether or not the entity is currently displaying its skeleton. **/
    public boolean getDisplaySkeleton();

    /** 
    Gets a pointer to the entity representing the numbered manual level of detail. **/
    public org.ogre4j.IEntity getManualLodLevel(int index);

    /** 
    Returns the number of manual levels of detail that this entity supports. **/
    public int getNumManualLodLevels();

    /** 
    Returns the current LOD used to render **/
    public int getCurrentLodIndex();

    /** 
    Sets a level-of-detail bias for the mesh detail of this entity. **/
    public void setMeshLodBias(float factor, int maxDetailIndex, int minDetailIndex);

    /** 
    Sets a level-of-detail bias for the material detail of this entity. **/
    public void setMaterialLodBias(float factor, int maxDetailIndex, int minDetailIndex);

    /** 
    Sets whether the polygon mode of this entire entity may be overridden by the camera detail settings. **/
    public void setPolygonModeOverrideable(boolean PolygonModeOverrideable);

    /** 
    Attaches another object to a certain bone of the skeleton which this entity uses. **/
    public org.ogre4j.ITagPoint attachObjectToBone(String boneName, org.ogre4j.IMovableObject pMovable, org.ogre4j.IQuaternion offsetOrientation, org.ogre4j.IVector3 offsetPosition);

    /** 
    Detach a  previously attached using attachObjectToBone. If the movable object name is not found then an exception is raised. **/
    public org.ogre4j.IMovableObject detachObjectFromBone(String movableName);

    /** 
    Detaches an object by pointer. **/
    public void detachObjectFromBone(org.ogre4j.IMovableObject obj);

    /** **/
    public void detachAllObjectsFromBone();

    /** 
    Gets an iterator to the list of objects attached to bones on this entity. **/
    public void getAttachedObjectIterator(org.ogre4j.IEntity.IChildObjectListIterator returnValue);

    /** 
    **/
    public float getBoundingRadius();

    /** 
    **/
    public org.ogre4j.IAxisAlignedBox getWorldBoundingBox(boolean derive);

    /** 
    **/
    public org.ogre4j.ISphere getWorldBoundingSphere(boolean derive);

    /** 
    Overridden member from . **/
    public org.ogre4j.IEdgeData getEdgeList();

    /** 
    Overridden member from . **/
    public boolean hasEdgeList();

    /** 
    Overridden member from . **/
    public void getShadowVolumeRenderableIterator(org.ogre4j.IShadowCaster.IShadowRenderableListIterator returnValue, org.ogre4j.ShadowTechnique shadowTechnique, org.ogre4j.ILight light, org.ogre4j.IHardwareIndexBufferSharedPtr indexBuffer, boolean extrudeVertices, float extrusionDistance, long flags);

    /** 
    Internal method for retrieving bone matrix information. **/
    public org.ogre4j.IMatrix4 _getBoneMatrices();

    /** 
    Internal method for retrieving bone matrix information. **/
    public int _getNumBoneMatrices();

    /** 
    Returns whether or not this entity is skeletally animated. **/
    public boolean hasSkeleton();

    /** 
    Get this Entity's personal skeleton instance. **/
    public org.ogre4j.ISkeletonInstance getSkeleton();

    /** 
    Returns whether or not hardware animation is enabled. **/
    public boolean isHardwareAnimationEnabled();

    /** 
    Overridden from **/
    public void _notifyAttached(org.ogre4j.INode parent, boolean isTagPoint);

    /** 
    Returns the number of requests that have been made for software animation **/
    public int getSoftwareAnimationRequests();

    /** 
    Returns the number of requests that have been made for software animation of normals **/
    public int getSoftwareAnimationNormalsRequests();

    /** 
    Add a request for software animation **/
    public void addSoftwareAnimationRequest(boolean normalsAlso);

    /** 
    Removes a request for software animation **/
    public void removeSoftwareAnimationRequest(boolean normalsAlso);

    /** 
    Shares the  with the supplied entity. Note that in order for this to work, both entities must have the same . **/
    public void shareSkeletonInstanceWith(org.ogre4j.IEntity entity);

    /** 
    Returns whether or not this entity is either morph or pose animated. **/
    public boolean hasVertexAnimation();

    /** 
    Stops sharing the  with other entities. **/
    public void stopSharingSkeletonInstance();

    /** 
    Returns whether this entity shares it's SkeltonInstance with other entity instances. **/
    public boolean sharesSkeletonInstance();

    /** 
    Returns a pointer to the set of entities which share a . If this instance does not share it's  with other instances NULL will be returned **/
    public org.ogre4j.IEntity.IEntitySet getSkeletonInstanceSharingSet();

    /** 
    Updates the internal animation state set to include the latest available animations from the attached skeleton. **/
    public void refreshAvailableAnimationState();

    /** 
    Advanced method to perform all the updates required for an animated entity. **/
    public void _updateAnimation();

    /** 
    Tests if any animation applied to this entity. **/
    public boolean _isAnimated();

    /** 
    Tests if skeleton was animated. **/
    public boolean _isSkeletonAnimated();

    /** 
    Advanced method to get the temporarily blended skeletal vertex information for entities which are software skinned. **/
    public org.ogre4j.IVertexData _getSkelAnimVertexData();

    /** 
    Advanced method to get the temporarily blended software vertex animation information **/
    public org.ogre4j.IVertexData _getSoftwareVertexAnimVertexData();

    /** 
    Advanced method to get the hardware morph vertex information **/
    public org.ogre4j.IVertexData _getHardwareVertexAnimVertexData();

    /** 
    Advanced method to get the temp buffer information for software skeletal animation. **/
    public org.ogre4j.ITempBlendedBufferInfo _getSkelAnimTempBufferInfo();

    /** 
    Advanced method to get the temp buffer information for software morph animation. **/
    public org.ogre4j.ITempBlendedBufferInfo _getVertexAnimTempBufferInfo();

    /** **/
    public long getTypeFlags();

    /** **/
    public org.ogre4j.IVertexData getVertexDataForBinding();

    /** **/
    public org.ogre4j.Entity.VertexDataBindChoice chooseVertexDataForBinding(boolean hasVertexAnim);

    /** 
    Are buffers already marked as vertex animated? **/
    public boolean _getBuffersMarkedForAnimation();

    /** 
    Mark just this vertex data as animated. **/
    public void _markBuffersUsedForAnimation();

    /** 
    Has this  been initialised yet? **/
    public boolean isInitialised();

    /** 
    Try to initialise the  from the underlying resources. **/
    public void _initialise(boolean forceReinitialise);

    /** 
    Tear down the internal structures of this , rendering it uninitialised. **/
    public void _deinitialise();

    /** 
     hook to notify  that a delay-loaded  is complete. **/
    public void backgroundLoadingComplete(org.ogre4j.IResource res);

    /** **/
    public void visitRenderables(org.ogre4j.IRenderable.IVisitor visitor, boolean debugRenderables);

}
