/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class TangentSpaceCalc extends org.xbig.base.NativeObject implements org.ogre4j.ITangentSpaceCalc {
static { System.loadLibrary("ogre4j");}
public static class IndexRemap extends org.xbig.base.NativeObject implements org.ogre4j.ITangentSpaceCalc.IIndexRemap {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public IndexRemap(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected IndexRemap(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public IndexRemap(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public IndexRemap(int i, int f, org.ogre4j.ITangentSpaceCalc.IVertexSplit s) {
         super( new org.xbig.base.InstancePointer(__createIndexRemap__ivivVertexSplitR( i,  f,  s.getInstancePointer().pointer)), false);
    }

    private native static long __createIndexRemap__ivivVertexSplitR(int i, int f, long s);

    /** **/
    public int getindexSet() {
         return _getindexSet(this.object.pointer);
    }

    private native int _getindexSet(long _pointer_);

    /** **/
    public void setindexSet(int _jni_value_) {
        _setindexSet(this.object.pointer, _jni_value_);
    }

    private native void _setindexSet(long _pointer_, int _jni_value_);

    /** **/
    public int getfaceIndex() {
         return _getfaceIndex(this.object.pointer);
    }

    private native int _getfaceIndex(long _pointer_);

    /** **/
    public void setfaceIndex(int _jni_value_) {
        _setfaceIndex(this.object.pointer, _jni_value_);
    }

    private native void _setfaceIndex(long _pointer_, int _jni_value_);

    /** **/
    public void getsplitVertex(org.ogre4j.ITangentSpaceCalc.IVertexSplit returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getsplitVertex(this.object.pointer)), false);
    }

    private native long _getsplitVertex(long _pointer_);

    /** **/
    public void setsplitVertex(org.ogre4j.ITangentSpaceCalc.IVertexSplit _jni_value_) {
        _setsplitVertex(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setsplitVertex(long _pointer_, long _jni_value_);

}
public static class Result extends org.xbig.base.NativeObject implements org.ogre4j.ITangentSpaceCalc.IResult {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public Result(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected Result(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public Result(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public Result() {
         super( new org.xbig.base.InstancePointer(__createResult()), false);
    }

    private native static long __createResult();

    /** **/
    public void getvertexSplits(org.ogre4j.ITangentSpaceCalc.IVertexSplits returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getvertexSplits(this.object.pointer)), false);
    }

    private native long _getvertexSplits(long _pointer_);

    /** **/
    public void setvertexSplits(org.ogre4j.ITangentSpaceCalc.IVertexSplits _jni_value_) {
        _setvertexSplits(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setvertexSplits(long _pointer_, long _jni_value_);

    /** **/
    public void getindexesRemapped(org.ogre4j.ITangentSpaceCalc.IIndexRemapList returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getindexesRemapped(this.object.pointer)), false);
    }

    private native long _getindexesRemapped(long _pointer_);

    /** **/
    public void setindexesRemapped(org.ogre4j.ITangentSpaceCalc.IIndexRemapList _jni_value_) {
        _setindexesRemapped(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setindexesRemapped(long _pointer_, long _jni_value_);

}
protected static class VertexInfo extends org.xbig.base.NativeObject implements org.ogre4j.ITangentSpaceCalc.IVertexInfo {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public VertexInfo(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected VertexInfo(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public VertexInfo(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public VertexInfo() {
         super( new org.xbig.base.InstancePointer(__createVertexInfo()), false);
    }

    private native static long __createVertexInfo();

    /** **/
    public void getpos(org.ogre4j.IVector3 returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getpos(this.object.pointer)), false);
    }

    private native long _getpos(long _pointer_);

    /** **/
    public void setpos(org.ogre4j.IVector3 _jni_value_) {
        _setpos(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setpos(long _pointer_, long _jni_value_);

    /** **/
    public void getnorm(org.ogre4j.IVector3 returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getnorm(this.object.pointer)), false);
    }

    private native long _getnorm(long _pointer_);

    /** **/
    public void setnorm(org.ogre4j.IVector3 _jni_value_) {
        _setnorm(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setnorm(long _pointer_, long _jni_value_);

    /** **/
    public void getuv(org.ogre4j.IVector2 returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getuv(this.object.pointer)), false);
    }

    private native long _getuv(long _pointer_);

    /** **/
    public void setuv(org.ogre4j.IVector2 _jni_value_) {
        _setuv(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setuv(long _pointer_, long _jni_value_);

    /** **/
    public void gettangent(org.ogre4j.IVector3 returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_gettangent(this.object.pointer)), false);
    }

    private native long _gettangent(long _pointer_);

    /** **/
    public void settangent(org.ogre4j.IVector3 _jni_value_) {
        _settangent(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _settangent(long _pointer_, long _jni_value_);

    /** **/
    public void getbinormal(org.ogre4j.IVector3 returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getbinormal(this.object.pointer)), false);
    }

    private native long _getbinormal(long _pointer_);

    /** **/
    public void setbinormal(org.ogre4j.IVector3 _jni_value_) {
        _setbinormal(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setbinormal(long _pointer_, long _jni_value_);

    /** **/
    public int getparity() {
         return _getparity(this.object.pointer);
    }

    private native int _getparity(long _pointer_);

    /** **/
    public void setparity(int _jni_value_) {
        _setparity(this.object.pointer, _jni_value_);
    }

    private native void _setparity(long _pointer_, int _jni_value_);

    /** **/
    public int getoppositeParityIndex() {
         return _getoppositeParityIndex(this.object.pointer);
    }

    private native int _getoppositeParityIndex(long _pointer_);

    /** **/
    public void setoppositeParityIndex(int _jni_value_) {
        _setoppositeParityIndex(this.object.pointer, _jni_value_);
    }

    private native void _setoppositeParityIndex(long _pointer_, int _jni_value_);

}
public static class VertexSplit extends org.xbig.base.NativeObject implements org.ogre4j.ITangentSpaceCalc.IVertexSplit {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public VertexSplit(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected VertexSplit(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public VertexSplit(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public int getfirst() {
         return _getfirst(this.object.pointer);
    }

    private native int _getfirst(long _pointer_);

    /** **/
    public void setfirst(int _jni_value_) {
        _setfirst(this.object.pointer, _jni_value_);
    }

    private native void _setfirst(long _pointer_, int _jni_value_);

    /** **/
    public int getsecond() {
         return _getsecond(this.object.pointer);
    }

    private native int _getsecond(long _pointer_);

    /** **/
    public void setsecond(int _jni_value_) {
        _setsecond(this.object.pointer, _jni_value_);
    }

    private native void _setsecond(long _pointer_, int _jni_value_);

}
public static class IndexRemapList extends org.xbig.base.NativeObject implements org.ogre4j.ITangentSpaceCalc.IIndexRemapList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public IndexRemapList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected IndexRemapList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public IndexRemapList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public IndexRemapList() {
         super( new org.xbig.base.InstancePointer(__createIndexRemapList()), false);
    }

    private native static long __createIndexRemapList();

    /** **/
    public void assign(int num, org.ogre4j.ITangentSpaceCalc.IIndexRemap val) {
        _assign__ivOgre_TangentSpaceCalc_IndexRemapR(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_TangentSpaceCalc_IndexRemapR(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.ITangentSpaceCalc.IIndexRemap back() {
         return new org.ogre4j.TangentSpaceCalc.IndexRemap(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public org.ogre4j.ITangentSpaceCalc.IIndexRemap front() {
         return new org.ogre4j.TangentSpaceCalc.IndexRemap(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void pop_front() {
        _pop_front(this.object.pointer);
    }

    private native void _pop_front(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.ITangentSpaceCalc.IIndexRemap val) {
        _push_back__Ogre_TangentSpaceCalc_IndexRemapR(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_TangentSpaceCalc_IndexRemapR(long _pointer_, long val);

    /** **/
    public void push_front(org.ogre4j.ITangentSpaceCalc.IIndexRemap val) {
        _push_front__Ogre_TangentSpaceCalc_IndexRemapR(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_front__Ogre_TangentSpaceCalc_IndexRemapR(long _pointer_, long val);





    /** **/
    public void reverse() {
        _reverse(this.object.pointer);
    }

    private native void _reverse(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);





}
public static class VertexSplits extends org.xbig.base.NativeObject implements org.ogre4j.ITangentSpaceCalc.IVertexSplits {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public VertexSplits(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected VertexSplits(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public VertexSplits(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public VertexSplits() {
         super( new org.xbig.base.InstancePointer(__createVertexSplits()), false);
    }

    private native static long __createVertexSplits();

    /** **/
    public void assign(int num, org.ogre4j.ITangentSpaceCalc.IVertexSplit val) {
        _assign__ivOgre_TangentSpaceCalc_VertexSplitR(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_TangentSpaceCalc_VertexSplitR(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.ITangentSpaceCalc.IVertexSplit back() {
         return new org.ogre4j.TangentSpaceCalc.VertexSplit(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public org.ogre4j.ITangentSpaceCalc.IVertexSplit front() {
         return new org.ogre4j.TangentSpaceCalc.VertexSplit(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void pop_front() {
        _pop_front(this.object.pointer);
    }

    private native void _pop_front(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.ITangentSpaceCalc.IVertexSplit val) {
        _push_back__Ogre_TangentSpaceCalc_VertexSplitR(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_TangentSpaceCalc_VertexSplitR(long _pointer_, long val);

    /** **/
    public void push_front(org.ogre4j.ITangentSpaceCalc.IVertexSplit val) {
        _push_front__Ogre_TangentSpaceCalc_VertexSplitR(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_front__Ogre_TangentSpaceCalc_VertexSplitR(long _pointer_, long val);

    /** **/
    public void remove(org.ogre4j.ITangentSpaceCalc.IVertexSplit val) {
        _remove__Ogre_TangentSpaceCalc_VertexSplitR(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _remove__Ogre_TangentSpaceCalc_VertexSplitR(long _pointer_, long val);

    /** **/
    public void reverse() {
        _reverse(this.object.pointer);
    }

    private native void _reverse(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public void unique() {
        _unique(this.object.pointer);
    }

    private native void _unique(long _pointer_);

}
protected static class IndexDataList extends org.xbig.base.NativeObject implements org.ogre4j.ITangentSpaceCalc.IIndexDataList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public IndexDataList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected IndexDataList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public IndexDataList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public IndexDataList() {
         super( new org.xbig.base.InstancePointer(__createIndexDataList()), false);
    }

    private native static long __createIndexDataList();

    /** **/
    public void assign(int num, org.ogre4j.IIndexData val) {
        _assign__ivOgre_IndexDataP(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_IndexDataP(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.IIndexData at(int loc) {
         return new org.ogre4j.IndexData(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.IIndexData back() {
         return new org.ogre4j.IndexData(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.IIndexData front() {
         return new org.ogre4j.IndexData(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.IIndexData val) {
        _push_back__Ogre_IndexDataP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_IndexDataP(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
protected static class OpTypeList extends org.xbig.base.NativeObject implements org.ogre4j.ITangentSpaceCalc.IOpTypeList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public OpTypeList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected OpTypeList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public OpTypeList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public OpTypeList() {
         super( new org.xbig.base.InstancePointer(__createOpTypeList()), false);
    }

    private native static long __createOpTypeList();

    /** **/
    public void assign(int num, org.ogre4j.RenderOperation.OperationType val) {
        _assign__ivOgre_RenderOperation_OperationTypeR(this.object.pointer, num,  val.getValue());
    }

    private native void _assign__ivOgre_RenderOperation_OperationTypeR(long _pointer_, int num, int val);

    /** **/
    public org.ogre4j.RenderOperation.OperationType at(int loc) {
         return org.ogre4j.RenderOperation.OperationType.toEnum(_at__iv(this.object.pointer, loc));
    }

    private native int _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.RenderOperation.OperationType back() {
         return org.ogre4j.RenderOperation.OperationType.toEnum(_back(this.object.pointer));
    }

    private native int _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.RenderOperation.OperationType front() {
         return org.ogre4j.RenderOperation.OperationType.toEnum(_front(this.object.pointer));
    }

    private native int _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.RenderOperation.OperationType val) {
        _push_back__Ogre_RenderOperation_OperationTypeR(this.object.pointer, val.getValue());
    }

    private native void _push_back__Ogre_RenderOperation_OperationTypeR(long _pointer_, int val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
protected static class VertexInfoArray extends org.xbig.base.NativeObject implements org.ogre4j.ITangentSpaceCalc.IVertexInfoArray {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public VertexInfoArray(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected VertexInfoArray(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public VertexInfoArray(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public VertexInfoArray() {
         super( new org.xbig.base.InstancePointer(__createVertexInfoArray()), false);
    }

    private native static long __createVertexInfoArray();

    /** **/
    public void assign(int num, org.ogre4j.ITangentSpaceCalc.IVertexInfo val) {
        _assign__ivOgre_TangentSpaceCalc_VertexInfoR(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_TangentSpaceCalc_VertexInfoR(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.ITangentSpaceCalc.IVertexInfo at(int loc) {
         return new org.ogre4j.TangentSpaceCalc.VertexInfo(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.ITangentSpaceCalc.IVertexInfo back() {
         return new org.ogre4j.TangentSpaceCalc.VertexInfo(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.ITangentSpaceCalc.IVertexInfo front() {
         return new org.ogre4j.TangentSpaceCalc.VertexInfo(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.ITangentSpaceCalc.IVertexInfo val) {
        _push_back__Ogre_TangentSpaceCalc_VertexInfoR(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_TangentSpaceCalc_VertexInfoR(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public TangentSpaceCalc(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected TangentSpaceCalc(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public TangentSpaceCalc(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public TangentSpaceCalc() {
         super( new org.xbig.base.InstancePointer(__createTangentSpaceCalc()), false);
    }

    private native static long __createTangentSpaceCalc();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** 
    Set the incoming vertex data (which will be modified) **/
    public void setVertexData(org.ogre4j.IVertexData v_in) {
        _setVertexData__VertexDatap(this.object.pointer, v_in.getInstancePointer().pointer);
    }

    private native void _setVertexData__VertexDatap(long _pointer_, long v_in);

    /** 
    Add a set of index data that references the vertex data. This might be modified if there are vertex splits. **/
    public void addIndexData(org.ogre4j.IIndexData i_in, org.ogre4j.RenderOperation.OperationType opType) {
        _addIndexData__IndexDatapRenderOperation_OperationTypev(this.object.pointer, i_in.getInstancePointer().pointer,  opType.getValue());
    }

    private native void _addIndexData__IndexDatapRenderOperation_OperationTypev(long _pointer_, long i_in, int opType);

    /** 
    Sets whether to store tangent space parity in the W of a 4-component tangent or not. **/
    public void setStoreParityInW(boolean enabled) {
        _setStoreParityInW__bv(this.object.pointer, enabled);
    }

    private native void _setStoreParityInW__bv(long _pointer_, boolean enabled);

    /** 
    Gets whether to store tangent space parity in the W of a 4-component tangent or not. **/
    public boolean getStoreParityInW() {
         return _getStoreParityInW_const(this.object.pointer);
    }

    private native boolean _getStoreParityInW_const(long _pointer_);

    /** 
    Sets whether or not to split vertices when a mirrored tangent space transition is detected (matrix parity differs). **/
    public void setSplitMirrored(boolean split) {
        _setSplitMirrored__bv(this.object.pointer, split);
    }

    private native void _setSplitMirrored__bv(long _pointer_, boolean split);

    /** 
    Gets whether or not to split vertices when a mirrored tangent space transition is detected. **/
    public boolean getSplitMirrored() {
         return _getSplitMirrored_const(this.object.pointer);
    }

    private native boolean _getSplitMirrored_const(long _pointer_);

    /** 
    Sets whether or not to split vertices when tangent space rotates more than 90 degrees around a vertex. **/
    public void setSplitRotated(boolean split) {
        _setSplitRotated__bv(this.object.pointer, split);
    }

    private native void _setSplitRotated__bv(long _pointer_, boolean split);

    /** 
    Sets whether or not to split vertices when tangent space rotates more than 90 degrees around a vertex. **/
    public boolean getSplitRotated() {
         return _getSplitRotated_const(this.object.pointer);
    }

    private native boolean _getSplitRotated_const(long _pointer_);

    /** 
    Build a tangent space basis from the provided data. **/
    public void build(org.ogre4j.ITangentSpaceCalc.IResult returnValue, org.ogre4j.VertexElementSemantic targetSemantic, int sourceTexCoordSet, int index) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_build__VertexElementSemanticvHvHv(this.object.pointer, targetSemantic.getValue(),  sourceTexCoordSet,  index)), false);
    }

    private native long _build__VertexElementSemanticvHvHv(long _pointer_, int targetSemantic, int sourceTexCoordSet, int index);

}
