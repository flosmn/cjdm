/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class Root extends org.xbig.base.NativeObject implements org.ogre4j.IRoot {
static { System.loadLibrary("ogre4j");}
protected enum FrameEventTimeType implements INativeEnum < FrameEventTimeType > {
    FETT_ANY(FrameEventTimeTypeHelper.ENUM_VALUES[0]),
    FETT_STARTED(FrameEventTimeTypeHelper.ENUM_VALUES[1]),
    FETT_QUEUED(FrameEventTimeTypeHelper.ENUM_VALUES[2]),
    FETT_ENDED(FrameEventTimeTypeHelper.ENUM_VALUES[3]),
    FETT_COUNT(FrameEventTimeTypeHelper.ENUM_VALUES[4]);

    private int value;

    FrameEventTimeType(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public FrameEventTimeType getEnum(int val) {
        return toEnum(val);
    }

    public static final FrameEventTimeType toEnum(int retval) {
    if (retval ==FETT_ANY.value)
        return FrameEventTimeType.FETT_ANY;
    else if (retval ==FETT_STARTED.value)
        return FrameEventTimeType.FETT_STARTED;
    else if (retval ==FETT_QUEUED.value)
        return FrameEventTimeType.FETT_QUEUED;
    else if (retval ==FETT_ENDED.value)
        return FrameEventTimeType.FETT_ENDED;
    else if (retval ==FETT_COUNT.value)
        return FrameEventTimeType.FETT_COUNT;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class FrameEventTimeTypeHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

protected static class MovableObjectFactoryMap extends org.xbig.base.NativeObject implements org.ogre4j.IRoot.IMovableObjectFactoryMap {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public MovableObjectFactoryMap(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected MovableObjectFactoryMap(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public MovableObjectFactoryMap(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public MovableObjectFactoryMap() {
         super( new org.xbig.base.InstancePointer(__createMovableObjectFactoryMap()), false);
    }

    private native static long __createMovableObjectFactoryMap();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.IMovableObjectFactory get(String key) {
         return new org.ogre4j.MovableObjectFactory(new InstancePointer(_get__sR(this.object.pointer, key)));
    }

    private native long _get__sR(long _pointer_, String key);

    /** **/
    public void insert(String key, org.ogre4j.IMovableObjectFactory value) {
        _insert__sROgre_MovableObjectFactoryp(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__sROgre_MovableObjectFactoryp(long _pointer_, String key, long value);

}
protected static class RenderQueueInvocationSequenceMap extends org.xbig.base.NativeObject implements org.ogre4j.IRoot.IRenderQueueInvocationSequenceMap {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public RenderQueueInvocationSequenceMap(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected RenderQueueInvocationSequenceMap(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public RenderQueueInvocationSequenceMap(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public RenderQueueInvocationSequenceMap() {
         super( new org.xbig.base.InstancePointer(__createRenderQueueInvocationSequenceMap()), false);
    }

    private native static long __createRenderQueueInvocationSequenceMap();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.IRenderQueueInvocationSequence get(String key) {
         return new org.ogre4j.RenderQueueInvocationSequence(new InstancePointer(_get__sR(this.object.pointer, key)));
    }

    private native long _get__sR(long _pointer_, String key);

    /** **/
    public void insert(String key, org.ogre4j.IRenderQueueInvocationSequence value) {
        _insert__sROgre_RenderQueueInvocationSequencep(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__sROgre_RenderQueueInvocationSequencep(long _pointer_, String key, long value);

}
public static class PluginLibList extends org.xbig.base.NativeObject implements org.ogre4j.IRoot.IPluginLibList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public PluginLibList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected PluginLibList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public PluginLibList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public PluginLibList() {
         super( new org.xbig.base.InstancePointer(__createPluginLibList()), false);
    }

    private native static long __createPluginLibList();

    /** **/
    public void assign(int num, org.ogre4j.IDynLib val) {
        _assign__ivOgre_DynLibP(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_DynLibP(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.IDynLib at(int loc) {
         return new org.ogre4j.DynLib(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.IDynLib back() {
         return new org.ogre4j.DynLib(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.IDynLib front() {
         return new org.ogre4j.DynLib(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.IDynLib val) {
        _push_back__Ogre_DynLibP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_DynLibP(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
public static class PluginInstanceList extends org.xbig.base.NativeObject implements org.ogre4j.IRoot.IPluginInstanceList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public PluginInstanceList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected PluginInstanceList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public PluginInstanceList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public PluginInstanceList() {
         super( new org.xbig.base.InstancePointer(__createPluginInstanceList()), false);
    }

    private native static long __createPluginInstanceList();

    /** **/
    public void assign(int num, org.ogre4j.IPlugin val) {
        _assign__ivOgre_PluginP(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_PluginP(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.IPlugin at(int loc) {
         return new org.ogre4j.Plugin(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.IPlugin back() {
         return new org.ogre4j.Plugin(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.IPlugin front() {
         return new org.ogre4j.Plugin(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.IPlugin val) {
        _push_back__Ogre_PluginP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_PluginP(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
public static class MovableObjectFactoryIterator extends org.xbig.base.NativeObject implements org.ogre4j.IRoot.IMovableObjectFactoryIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public MovableObjectFactoryIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected MovableObjectFactoryIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public MovableObjectFactoryIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public org.ogre4j.IMovableObjectFactory getNext() {
         return new org.ogre4j.MovableObjectFactory(new InstancePointer(_getNext(this.object.pointer)));
    }

    private native long _getNext(long _pointer_);

    /** **/
    public org.ogre4j.IMovableObjectFactory peekNextValue() {
         return new org.ogre4j.MovableObjectFactory(new InstancePointer(_peekNextValue_const(this.object.pointer)));
    }

    private native long _peekNextValue_const(long _pointer_);

    /** **/
    public String peekNextKey() {
         return _peekNextKey_const(this.object.pointer);
    }

    private native String _peekNextKey_const(long _pointer_);

    /** **/
    public org.ogre4j.IRoot.IMovableObjectFactoryIterator operatorAssignment(org.ogre4j.IRoot.IMovableObjectFactoryIterator rhs) {
         return new org.ogre4j.Root.MovableObjectFactoryIterator(new InstancePointer(_operatorAssignment___Ogre_Root_MovableObjectFactoryIteratorr(this.object.pointer, rhs.getInstancePointer().pointer)));
    }

    private native long _operatorAssignment___Ogre_Root_MovableObjectFactoryIteratorr(long _pointer_, long rhs);

    /** **/
    public NativeObjectPointer<org.ogre4j.IMovableObjectFactory> peekNextValuePtr() {
         return new NativeObjectPointer<org.ogre4j.IMovableObjectFactory>(new InstancePointer(_peekNextValuePtr_const(this.object.pointer)));
    }

    private native long _peekNextValuePtr_const(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext_const(this.object.pointer);
    }

    private native void _moveNext_const(long _pointer_);

}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public Root(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected Root(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public Root(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** 
    Constructor **/
    public Root(String pluginFileName, String configFileName, String logFileName) {
         super( new org.xbig.base.InstancePointer(__createRoot__StringRStringRStringR( pluginFileName,  configFileName,  logFileName)), false);
    }

    private native static long __createRoot__StringRStringRStringR(String pluginFileName, String configFileName, String logFileName);

    /** 
    Saves the details of the current configuration **/
    public void saveConfig() {
        _saveConfig(this.object.pointer);
    }

    private native void _saveConfig(long _pointer_);

    /** 
    Checks for saved video/sound/etc settings **/
    public boolean restoreConfig() {
         return _restoreConfig(this.object.pointer);
    }

    private native boolean _restoreConfig(long _pointer_);

    /** 
    Displays a dialog asking the user to choose system settings. **/
    public boolean showConfigDialog() {
         return _showConfigDialog(this.object.pointer);
    }

    private native boolean _showConfigDialog(long _pointer_);

    /** 
    Adds a new rendering subsystem to the list of available renderers. **/
    public void addRenderSystem(org.ogre4j.IRenderSystem newRend) {
        _addRenderSystem__RenderSystemp(this.object.pointer, newRend.getInstancePointer().pointer);
    }

    private native void _addRenderSystem__RenderSystemp(long _pointer_, long newRend);

    /** 
    Retrieve a list of the available render systems. **/
    public org.ogre4j.IRenderSystemList getAvailableRenderers() {
         return new org.ogre4j.RenderSystemList(new InstancePointer(_getAvailableRenderers(this.object.pointer)));
    }

    private native long _getAvailableRenderers(long _pointer_);

    /** 
    Retrieve a pointer to the render system by the given name **/
    public org.ogre4j.IRenderSystem getRenderSystemByName(String name) {
         return new org.ogre4j.RenderSystem(new InstancePointer(_getRenderSystemByName__StringR(this.object.pointer, name)));
    }

    private native long _getRenderSystemByName__StringR(long _pointer_, String name);

    /** 
    Sets the rendering subsystem to be used. **/
    public void setRenderSystem(org.ogre4j.IRenderSystem system) {
        _setRenderSystem__RenderSystemp(this.object.pointer, system.getInstancePointer().pointer);
    }

    private native void _setRenderSystem__RenderSystemp(long _pointer_, long system);

    /** 
    Retrieve a pointer to the currently selected render system. **/
    public org.ogre4j.IRenderSystem getRenderSystem() {
         return new org.ogre4j.RenderSystem(new InstancePointer(_getRenderSystem(this.object.pointer)));
    }

    private native long _getRenderSystem(long _pointer_);

    /** 
    Initialises the renderer. **/
    public org.ogre4j.IRenderWindow initialise(boolean autoCreateWindow, String windowTitle, String customCapabilitiesConfig) {
         return new org.ogre4j.RenderWindow(new InstancePointer(_initialise__bvStringRStringR(this.object.pointer, autoCreateWindow,  windowTitle,  customCapabilitiesConfig)));
    }

    private native long _initialise__bvStringRStringR(long _pointer_, boolean autoCreateWindow, String windowTitle, String customCapabilitiesConfig);

    /** 
    Returns whether the system is initialised or not. **/
    public boolean isInitialised() {
         return _isInitialised_const(this.object.pointer);
    }

    private native boolean _isInitialised_const(long _pointer_);

    /** 
    Requests active  to use custom **/
    public void useCustomRenderSystemCapabilities(org.ogre4j.IRenderSystemCapabilities capabilities) {
        _useCustomRenderSystemCapabilities__RenderSystemCapabilitiesp(this.object.pointer, capabilities.getInstancePointer().pointer);
    }

    private native void _useCustomRenderSystemCapabilities__RenderSystemCapabilitiesp(long _pointer_, long capabilities);

    /** 
    Register a new , a factory object for creating instances of specific SceneManagers. **/
    public void addSceneManagerFactory(org.ogre4j.ISceneManagerFactory fact) {
        _addSceneManagerFactory__SceneManagerFactoryp(this.object.pointer, fact.getInstancePointer().pointer);
    }

    private native void _addSceneManagerFactory__SceneManagerFactoryp(long _pointer_, long fact);

    /** 
    Unregister a . **/
    public void removeSceneManagerFactory(org.ogre4j.ISceneManagerFactory fact) {
        _removeSceneManagerFactory__SceneManagerFactoryp(this.object.pointer, fact.getInstancePointer().pointer);
    }

    private native void _removeSceneManagerFactory__SceneManagerFactoryp(long _pointer_, long fact);

    /** 
    Get more information about a given type of . **/
    public org.ogre4j.ISceneManagerMetaData getSceneManagerMetaData(String typeName) {
         return new org.ogre4j.SceneManagerMetaData(new InstancePointer(_getSceneManagerMetaData__StringR_const(this.object.pointer, typeName)));
    }

    private native long _getSceneManagerMetaData__StringR_const(long _pointer_, String typeName);

    /** 
    Iterate over all types of  available for construction, providing some information about each one. **/
    public void getSceneManagerMetaDataIterator(org.ogre4j.ISceneManagerEnumerator.IMetaDataIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getSceneManagerMetaDataIterator_const(this.object.pointer)), false);
    }

    private native long _getSceneManagerMetaDataIterator_const(long _pointer_);

    /** 
    Create a  instance of a given type. **/
    public org.ogre4j.ISceneManager createSceneManager(String typeName, String instanceName) {
         return new org.ogre4j.SceneManager(new InstancePointer(_createSceneManager__StringRStringR(this.object.pointer, typeName,  instanceName)));
    }

    private native long _createSceneManager__StringRStringR(long _pointer_, String typeName, String instanceName);

    /** 
    Create a  instance based on scene type support. **/
    public org.ogre4j.ISceneManager createSceneManager(int typeMask, String instanceName) {
         return new org.ogre4j.SceneManager(new InstancePointer(_createSceneManager__SceneTypeMaskvStringR(this.object.pointer, typeMask,  instanceName)));
    }

    private native long _createSceneManager__SceneTypeMaskvStringR(long _pointer_, int typeMask, String instanceName);

    /** 
    Destroy an instance of a . **/
    public void destroySceneManager(org.ogre4j.ISceneManager sm) {
        _destroySceneManager__SceneManagerp(this.object.pointer, sm.getInstancePointer().pointer);
    }

    private native void _destroySceneManager__SceneManagerp(long _pointer_, long sm);

    /** 
    Get an existing  instance that has already been created, identified by the instance name. **/
    public org.ogre4j.ISceneManager getSceneManager(String instanceName) {
         return new org.ogre4j.SceneManager(new InstancePointer(_getSceneManager__StringR_const(this.object.pointer, instanceName)));
    }

    private native long _getSceneManager__StringR_const(long _pointer_, String instanceName);

    /** 
    Get an iterator over all the existing  instances. **/
    public void getSceneManagerIterator(org.ogre4j.ISceneManagerEnumerator.ISceneManagerIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getSceneManagerIterator(this.object.pointer)), false);
    }

    private native long _getSceneManagerIterator(long _pointer_);

    /** 
    Retrieves a reference to the current . **/
    public org.ogre4j.ITextureManager getTextureManager() {
         return new org.ogre4j.TextureManager(new InstancePointer(_getTextureManager(this.object.pointer)));
    }

    private native long _getTextureManager(long _pointer_);

    /** 
    Retrieves a reference to the current . **/
    public org.ogre4j.IMeshManager getMeshManager() {
         return new org.ogre4j.MeshManager(new InstancePointer(_getMeshManager(this.object.pointer)));
    }

    private native long _getMeshManager(long _pointer_);

    /** 
    Utility function for getting a better description of an error code. **/
    public String getErrorDescription(long errorNumber) {
         return _getErrorDescription__lv(this.object.pointer, errorNumber);
    }

    private native String _getErrorDescription__lv(long _pointer_, long errorNumber);

    /** 
    Registers a  which will be called back every frame. **/
    public void addFrameListener(org.ogre4j.IFrameListener newListener) {
        _addFrameListener__FrameListenerp(this.object.pointer, newListener.getInstancePointer().pointer);
    }

    private native void _addFrameListener__FrameListenerp(long _pointer_, long newListener);

    /** 
    Removes a  from the list of listening classes. **/
    public void removeFrameListener(org.ogre4j.IFrameListener oldListener) {
        _removeFrameListener__FrameListenerp(this.object.pointer, oldListener.getInstancePointer().pointer);
    }

    private native void _removeFrameListener__FrameListenerp(long _pointer_, long oldListener);

    /** 
    Queues the end of rendering. **/
    public void queueEndRendering() {
        _queueEndRendering(this.object.pointer);
    }

    private native void _queueEndRendering(long _pointer_);

    /** 
    Starts / restarts the automatic rendering cycle. **/
    public void startRendering() {
        _startRendering(this.object.pointer);
    }

    private native void _startRendering(long _pointer_);

    /** 
    Render one frame. **/
    public boolean renderOneFrame() {
         return _renderOneFrame(this.object.pointer);
    }

    private native boolean _renderOneFrame(long _pointer_);

    /** 
    Shuts down the system manually. **/
    public void shutdown() {
        _shutdown(this.object.pointer);
    }

    private native void _shutdown(long _pointer_);

    /** 
    Adds a location to the list of searchable locations for a  type. **/
    public void addResourceLocation(String name, String locType, String groupName, boolean recursive) {
        _addResourceLocation__StringRStringRStringRbv(this.object.pointer, name,  locType,  groupName,  recursive);
    }

    private native void _addResourceLocation__StringRStringRStringRbv(long _pointer_, String name, String locType, String groupName, boolean recursive);

    /** 
    Removes a resource location from the list. **/
    public void removeResourceLocation(String name, String groupName) {
        _removeResourceLocation__StringRStringR(this.object.pointer, name,  groupName);
    }

    private native void _removeResourceLocation__StringRStringR(long _pointer_, String name, String groupName);

    /** 
    Generates a packed data version of the passed in  suitable for use with the current . **/
    public void convertColourValue(org.ogre4j.IColourValue colour, LongPointer pDest) {
        _convertColourValue__ColourValueRuint32p(this.object.pointer, colour.getInstancePointer().pointer,  pDest.object.pointer);
    }

    private native void _convertColourValue__ColourValueRuint32p(long _pointer_, long colour, long pDest);

    /** 
    Retrieves a pointer to the window that was created automatically **/
    public org.ogre4j.IRenderWindow getAutoCreatedWindow() {
         return new org.ogre4j.RenderWindow(new InstancePointer(_getAutoCreatedWindow(this.object.pointer)));
    }

    private native long _getAutoCreatedWindow(long _pointer_);

    /** 
    **/
    public org.ogre4j.IRenderWindow createRenderWindow(String name, long width, long height, boolean fullScreen, org.ogre4j.INameValuePairList miscParams) {
         return new org.ogre4j.RenderWindow(new InstancePointer(_createRenderWindow__StringRIvIvbvNameValuePairListP(this.object.pointer, name,  width,  height,  fullScreen,  miscParams.getInstancePointer().pointer)));
    }

    private native long _createRenderWindow__StringRIvIvbvNameValuePairListP(long _pointer_, String name, long width, long height, boolean fullScreen, long miscParams);

    /** 
    Destroys a rendering window. **/
    public void detachRenderTarget(org.ogre4j.IRenderTarget pWin) {
        _detachRenderTarget__RenderTargetp(this.object.pointer, pWin.getInstancePointer().pointer);
    }

    private native void _detachRenderTarget__RenderTargetp(long _pointer_, long pWin);

    /** 
    Destroys a named rendering window. **/
    public void detachRenderTarget(String name) {
        _detachRenderTarget__StringR(this.object.pointer, name);
    }

    private native void _detachRenderTarget__StringR(long _pointer_, String name);

    /** 
    Retrieves a pointer to the a named render window. **/
    public org.ogre4j.IRenderTarget getRenderTarget(String name) {
         return new org.ogre4j.RenderTarget(new InstancePointer(_getRenderTarget__StringR(this.object.pointer, name)));
    }

    private native long _getRenderTarget__StringR(long _pointer_, String name);

    /** 
    Manually load a  contained in a DLL / DSO. **/
    public void loadPlugin(String pluginName) {
        _loadPlugin__StringR(this.object.pointer, pluginName);
    }

    private native void _loadPlugin__StringR(long _pointer_, String pluginName);

    /** 
    Manually unloads a  contained in a DLL / DSO. **/
    public void unloadPlugin(String pluginName) {
        _unloadPlugin__StringR(this.object.pointer, pluginName);
    }

    private native void _unloadPlugin__StringR(long _pointer_, String pluginName);

    /** 
    Install a new plugin. **/
    public void installPlugin(org.ogre4j.IPlugin plugin) {
        _installPlugin__Pluginp(this.object.pointer, plugin.getInstancePointer().pointer);
    }

    private native void _installPlugin__Pluginp(long _pointer_, long plugin);

    /** 
    Uninstall an existing plugin. **/
    public void uninstallPlugin(org.ogre4j.IPlugin plugin) {
        _uninstallPlugin__Pluginp(this.object.pointer, plugin.getInstancePointer().pointer);
    }

    private native void _uninstallPlugin__Pluginp(long _pointer_, long plugin);

    /** 
    Gets a read-only list of the currently installed plugins. **/
    public org.ogre4j.IRoot.IPluginInstanceList getInstalledPlugins() {
         return new org.ogre4j.Root.PluginInstanceList(new InstancePointer(_getInstalledPlugins_const(this.object.pointer)));
    }

    private native long _getInstalledPlugins_const(long _pointer_);

    /** 
    Gets a pointer to the central timer used for all OGRE timings **/
    public org.ogre4j.ITimer getTimer() {
         return new org.ogre4j.Timer(new InstancePointer(_getTimer(this.object.pointer)));
    }

    private native long _getTimer(long _pointer_);

    /** 
    Method for raising frame started events. **/
    public boolean _fireFrameStarted(org.ogre4j.IFrameEvent evt) {
         return __fireFrameStarted__FrameEventr(this.object.pointer, evt.getInstancePointer().pointer);
    }

    private native boolean __fireFrameStarted__FrameEventr(long _pointer_, long evt);

    /** 
    Method for raising frame rendering queued events. **/
    public boolean _fireFrameRenderingQueued(org.ogre4j.IFrameEvent evt) {
         return __fireFrameRenderingQueued__FrameEventr(this.object.pointer, evt.getInstancePointer().pointer);
    }

    private native boolean __fireFrameRenderingQueued__FrameEventr(long _pointer_, long evt);

    /** 
    Method for raising frame ended events. **/
    public boolean _fireFrameEnded(org.ogre4j.IFrameEvent evt) {
         return __fireFrameEnded__FrameEventr(this.object.pointer, evt.getInstancePointer().pointer);
    }

    private native boolean __fireFrameEnded__FrameEventr(long _pointer_, long evt);

    /** 
    Method for raising frame started events. **/
    public boolean _fireFrameStarted() {
         return __fireFrameStarted(this.object.pointer);
    }

    private native boolean __fireFrameStarted(long _pointer_);

    /** 
    Method for raising frame rendering queued events. **/
    public boolean _fireFrameRenderingQueued() {
         return __fireFrameRenderingQueued(this.object.pointer);
    }

    private native boolean __fireFrameRenderingQueued(long _pointer_);

    /** 
    Method for raising frame ended events. **/
    public boolean _fireFrameEnded() {
         return __fireFrameEnded(this.object.pointer);
    }

    private native boolean __fireFrameEnded(long _pointer_);

    /** 
    Gets the number of the next frame to be rendered. **/
    public long getNextFrameNumber() {
         return _getNextFrameNumber_const(this.object.pointer);
    }

    private native long _getNextFrameNumber_const(long _pointer_);

    /** 
    Returns the scene manager currently being used to render a frame. **/
    public org.ogre4j.ISceneManager _getCurrentSceneManager() {
         return new org.ogre4j.SceneManager(new InstancePointer(__getCurrentSceneManager_const(this.object.pointer)));
    }

    private native long __getCurrentSceneManager_const(long _pointer_);

    /** 
    Sets the scene manager currently being used to render a frame. **/
    public void _setCurrentSceneManager(org.ogre4j.ISceneManager sm) {
        __setCurrentSceneManager__SceneManagerp(this.object.pointer, sm.getInstancePointer().pointer);
    }

    private native void __setCurrentSceneManager__SceneManagerp(long _pointer_, long sm);

    /** 
    Internal method used for updating all  objects (windows, renderable textures etc) which are set to auto-update. **/
    public boolean _updateAllRenderTargets() {
         return __updateAllRenderTargets(this.object.pointer);
    }

    private native boolean __updateAllRenderTargets(long _pointer_);

    /** 
    Create a new , useful for linking to  instances to perform custom rendering. **/
    public org.ogre4j.IRenderQueueInvocationSequence createRenderQueueInvocationSequence(String name) {
         return new org.ogre4j.RenderQueueInvocationSequence(new InstancePointer(_createRenderQueueInvocationSequence__StringR(this.object.pointer, name)));
    }

    private native long _createRenderQueueInvocationSequence__StringR(long _pointer_, String name);

    /** 
    Get a . **/
    public org.ogre4j.IRenderQueueInvocationSequence getRenderQueueInvocationSequence(String name) {
         return new org.ogre4j.RenderQueueInvocationSequence(new InstancePointer(_getRenderQueueInvocationSequence__StringR(this.object.pointer, name)));
    }

    private native long _getRenderQueueInvocationSequence__StringR(long _pointer_, String name);

    /** 
    Destroy a . **/
    public void destroyRenderQueueInvocationSequence(String name) {
        _destroyRenderQueueInvocationSequence__StringR(this.object.pointer, name);
    }

    private native void _destroyRenderQueueInvocationSequence__StringR(long _pointer_, String name);

    /** 
    Destroy all RenderQueueInvocationSequences. **/
    public void destroyAllRenderQueueInvocationSequences() {
        _destroyAllRenderQueueInvocationSequences(this.object.pointer);
    }

    private native void _destroyAllRenderQueueInvocationSequences(long _pointer_);

    /** 
    Clears the history of all event times. **/
    public void clearEventTimes() {
        _clearEventTimes(this.object.pointer);
    }

    private native void _clearEventTimes(long _pointer_);

    /** 
    Sets the period over which OGRE smooths out fluctuations in frame times. **/
    public void setFrameSmoothingPeriod(float period) {
        _setFrameSmoothingPeriod__Realv(this.object.pointer, period);
    }

    private native void _setFrameSmoothingPeriod__Realv(long _pointer_, float period);

    /** 
    Gets the period over which OGRE smooths out fluctuations in frame times. **/
    public float getFrameSmoothingPeriod() {
         return _getFrameSmoothingPeriod_const(this.object.pointer);
    }

    private native float _getFrameSmoothingPeriod_const(long _pointer_);

    /** 
    Register a new  which will create new  instances of a particular type, as identified by the getType() method. **/
    public void addMovableObjectFactory(org.ogre4j.IMovableObjectFactory fact, boolean overrideExisting) {
        _addMovableObjectFactory__MovableObjectFactorypbv(this.object.pointer, fact.getInstancePointer().pointer,  overrideExisting);
    }

    private native void _addMovableObjectFactory__MovableObjectFactorypbv(long _pointer_, long fact, boolean overrideExisting);

    /** 
    Removes a previously registered . **/
    public void removeMovableObjectFactory(org.ogre4j.IMovableObjectFactory fact) {
        _removeMovableObjectFactory__MovableObjectFactoryp(this.object.pointer, fact.getInstancePointer().pointer);
    }

    private native void _removeMovableObjectFactory__MovableObjectFactoryp(long _pointer_, long fact);

    /** **/
    public boolean hasMovableObjectFactory(String typeName) {
         return _hasMovableObjectFactory__StringR_const(this.object.pointer, typeName);
    }

    private native boolean _hasMovableObjectFactory__StringR_const(long _pointer_, String typeName);

    /** **/
    public org.ogre4j.IMovableObjectFactory getMovableObjectFactory(String typeName) {
         return new org.ogre4j.MovableObjectFactory(new InstancePointer(_getMovableObjectFactory__StringR(this.object.pointer, typeName)));
    }

    private native long _getMovableObjectFactory__StringR(long _pointer_, String typeName);

    /** 
    Allocate the next  type flag. **/
    public long _allocateNextMovableObjectTypeFlag() {
         return __allocateNextMovableObjectTypeFlag(this.object.pointer);
    }

    private native long __allocateNextMovableObjectTypeFlag(long _pointer_);

    /** 
    Return an iterator over all the  instances currently registered. **/
    public void getMovableObjectFactoryIterator(org.ogre4j.IRoot.IMovableObjectFactoryIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getMovableObjectFactoryIterator_const(this.object.pointer)), false);
    }

    private native long _getMovableObjectFactoryIterator_const(long _pointer_);

    /** 
    Override standard  retrieval. **/
    public static org.ogre4j.IRoot getSingleton() {
         return new org.ogre4j.Root(new InstancePointer(_getSingleton()));
    }

    private native static long _getSingleton();

    /** 
    Override standard  retrieval. **/
    public static org.ogre4j.IRoot getSingletonPtr() {
         return new org.ogre4j.Root(new InstancePointer(_getSingletonPtr()));
    }

    private native static long _getSingletonPtr();

}
