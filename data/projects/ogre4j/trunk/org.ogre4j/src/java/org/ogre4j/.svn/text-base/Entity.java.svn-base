/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class Entity extends org.xbig.base.NativeObject implements org.ogre4j.IEntity {
static { System.loadLibrary("ogre4j");}
protected static class EntityShadowRenderable extends org.xbig.base.NativeObject implements org.ogre4j.IEntity.IEntityShadowRenderable {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public EntityShadowRenderable(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected EntityShadowRenderable(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public EntityShadowRenderable(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public EntityShadowRenderable(org.ogre4j.IEntity parent, org.ogre4j.IHardwareIndexBufferSharedPtr indexBuffer, org.ogre4j.IVertexData vertexData, boolean createSeparateLightCap, org.ogre4j.ISubEntity subent, boolean isLightCap) {
         super( new org.xbig.base.InstancePointer(__createEntityShadowRenderable__EntitypHardwareIndexBufferSharedPtrpVertexDataPbvSubEntitypbv( parent.getInstancePointer().pointer,  indexBuffer.getInstancePointer().pointer,  vertexData.getInstancePointer().pointer,  createSeparateLightCap,  subent.getInstancePointer().pointer,  isLightCap)), false);
    }

    private native static long __createEntityShadowRenderable__EntitypHardwareIndexBufferSharedPtrpVertexDataPbvSubEntitypbv(long parent, long indexBuffer, long vertexData, boolean createSeparateLightCap, long subent, boolean isLightCap);

    /** **/
    public void getWorldTransforms(org.ogre4j.IMatrix4 xform) {
        _getWorldTransforms__Matrix4p_const(this.object.pointer, xform.getInstancePointer().pointer);
    }

    private native void _getWorldTransforms__Matrix4p_const(long _pointer_, long xform);

    /** **/
    public void getPositionBuffer(org.ogre4j.IHardwareVertexBufferSharedPtr returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getPositionBuffer(this.object.pointer)), false);
    }

    private native long _getPositionBuffer(long _pointer_);

    /** **/
    public void getWBuffer(org.ogre4j.IHardwareVertexBufferSharedPtr returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getWBuffer(this.object.pointer)), false);
    }

    private native long _getWBuffer(long _pointer_);

    /** **/
    public void rebindPositionBuffer(org.ogre4j.IVertexData vertexData, boolean force) {
        _rebindPositionBuffer__VertexDataPbv(this.object.pointer, vertexData.getInstancePointer().pointer,  force);
    }

    private native void _rebindPositionBuffer__VertexDataPbv(long _pointer_, long vertexData, boolean force);

    /** **/
    public boolean isVisible() {
         return _isVisible_const(this.object.pointer);
    }

    private native boolean _isVisible_const(long _pointer_);

    /** 
    Set the material to be used by the shadow, should be set by the caller before adding to a render queue **/
    public void setMaterial(org.ogre4j.IMaterialPtr mat) {
        _setMaterial__MaterialPtrR(this.object.pointer, mat.getInstancePointer().pointer);
    }

    private native void _setMaterial__MaterialPtrR(long _pointer_, long mat);

    /** **/
    public org.ogre4j.IMaterialPtr getMaterial() {
         return new org.ogre4j.MaterialPtr(new InstancePointer(_getMaterial_const(this.object.pointer)));
    }

    private native long _getMaterial_const(long _pointer_);

    /** **/
    public void getRenderOperation(org.ogre4j.IRenderOperation op) {
        _getRenderOperation__RenderOperationr(this.object.pointer, op.getInstancePointer().pointer);
    }

    private native void _getRenderOperation__RenderOperationr(long _pointer_, long op);

    /** **/
    public org.ogre4j.IRenderOperation getRenderOperationForUpdate() {
         return new org.ogre4j.RenderOperation(new InstancePointer(_getRenderOperationForUpdate(this.object.pointer)));
    }

    private native long _getRenderOperationForUpdate(long _pointer_);

    /** **/
    public float getSquaredViewDepth(org.ogre4j.ICamera a1) {
         return _getSquaredViewDepth__CameraP_const(this.object.pointer, a1.getInstancePointer().pointer);
    }

    private native float _getSquaredViewDepth__CameraP_const(long _pointer_, long a1);

    /** **/
    public org.ogre4j.ILightList getLights() {
         return new org.ogre4j.LightList(new InstancePointer(_getLights_const(this.object.pointer)));
    }

    private native long _getLights_const(long _pointer_);

    /** 
    Does this renderable require a separate light cap? **/
    public boolean isLightCapSeparate() {
         return _isLightCapSeparate_const(this.object.pointer);
    }

    private native boolean _isLightCapSeparate_const(long _pointer_);

    /** **/
    public org.ogre4j.IShadowRenderable getLightCapRenderable() {
         return new org.ogre4j.ShadowRenderable(new InstancePointer(_getLightCapRenderable(this.object.pointer)));
    }

    private native long _getLightCapRenderable(long _pointer_);

    /** 
    Retrieves a pointer to the  this renderable object uses. **/
    public org.ogre4j.ITechnique getTechnique() {
         return new org.ogre4j.Technique(new InstancePointer(_getTechnique_const(this.object.pointer)));
    }

    private native long _getTechnique_const(long _pointer_);

    /** 
    Called just prior to the  being rendered. **/
    public boolean preRender(org.ogre4j.ISceneManager sm, org.ogre4j.IRenderSystem rsys) {
         return _preRender__SceneManagerpRenderSystemp(this.object.pointer, sm.getInstancePointer().pointer,  rsys.getInstancePointer().pointer);
    }

    private native boolean _preRender__SceneManagerpRenderSystemp(long _pointer_, long sm, long rsys);

    /** 
    Called immediately after the  has been rendered. **/
    public void postRender(org.ogre4j.ISceneManager sm, org.ogre4j.IRenderSystem rsys) {
        _postRender__SceneManagerpRenderSystemp(this.object.pointer, sm.getInstancePointer().pointer,  rsys.getInstancePointer().pointer);
    }

    private native void _postRender__SceneManagerpRenderSystemp(long _pointer_, long sm, long rsys);

    /** 
    Returns the number of world transform matrices this renderable requires. **/
    public int getNumWorldTransforms() {
         return _getNumWorldTransforms_const(this.object.pointer);
    }

    private native int _getNumWorldTransforms_const(long _pointer_);

    /** 
    Sets whether or not to use an 'identity' projection. **/
    public void setUseIdentityProjection(boolean useIdentityProjection) {
        _setUseIdentityProjection__bv(this.object.pointer, useIdentityProjection);
    }

    private native void _setUseIdentityProjection__bv(long _pointer_, boolean useIdentityProjection);

    /** 
    Returns whether or not to use an 'identity' projection. **/
    public boolean getUseIdentityProjection() {
         return _getUseIdentityProjection_const(this.object.pointer);
    }

    private native boolean _getUseIdentityProjection_const(long _pointer_);

    /** 
    Sets whether or not to use an 'identity' view. **/
    public void setUseIdentityView(boolean useIdentityView) {
        _setUseIdentityView__bv(this.object.pointer, useIdentityView);
    }

    private native void _setUseIdentityView__bv(long _pointer_, boolean useIdentityView);

    /** 
    Returns whether or not to use an 'identity' view. **/
    public boolean getUseIdentityView() {
         return _getUseIdentityView_const(this.object.pointer);
    }

    private native boolean _getUseIdentityView_const(long _pointer_);

    /** 
    Method which reports whether this renderable would normally cast a shadow. **/
    public boolean getCastsShadows() {
         return _getCastsShadows_const(this.object.pointer);
    }

    private native boolean _getCastsShadows_const(long _pointer_);

    /** 
    Sets a custom parameter for this , which may be used to drive calculations for this specific , like GPU program parameters. **/
    public void setCustomParameter(int index, org.ogre4j.IVector4 value) {
        _setCustomParameter__ivVector4R(this.object.pointer, index,  value.getInstancePointer().pointer);
    }

    private native void _setCustomParameter__ivVector4R(long _pointer_, int index, long value);

    /** 
    Gets the custom value associated with this  at the given index. **/
    public org.ogre4j.IVector4 getCustomParameter(int index) {
         return new org.ogre4j.Vector4(new InstancePointer(_getCustomParameter__iv_const(this.object.pointer, index)));
    }

    private native long _getCustomParameter__iv_const(long _pointer_, int index);

    /** 
    Update a custom  constant which is derived from information only this  knows. **/
    public void _updateCustomGpuParameter(org.ogre4j.IGpuProgramParameters.IAutoConstantEntry constantEntry, org.ogre4j.IGpuProgramParameters params) {
        __updateCustomGpuParameter__GpuProgramParameters_AutoConstantEntryRGpuProgramParametersp_const(this.object.pointer, constantEntry.getInstancePointer().pointer,  params.getInstancePointer().pointer);
    }

    private native void __updateCustomGpuParameter__GpuProgramParameters_AutoConstantEntryRGpuProgramParametersp_const(long _pointer_, long constantEntry, long params);

    /** 
    Sets whether this renderable's chosen detail level can be overridden (downgraded) by the camera setting. **/
    public void setPolygonModeOverrideable(boolean override) {
        _setPolygonModeOverrideable__bv(this.object.pointer, override);
    }

    private native void _setPolygonModeOverrideable__bv(long _pointer_, boolean override);

    /** 
    Gets whether this renderable's chosen detail level can be overridden (downgraded) by the camera setting. **/
    public boolean getPolygonModeOverrideable() {
         return _getPolygonModeOverrideable_const(this.object.pointer);
    }

    private native boolean _getPolygonModeOverrideable_const(long _pointer_);

    /** 
    Sets any kind of user value on this object. **/
    public void setUserAny(org.ogre4j.IAny anything) {
        _setUserAny__AnyR(this.object.pointer, anything.getInstancePointer().pointer);
    }

    private native void _setUserAny__AnyR(long _pointer_, long anything);

    /** 
    Retrieves the custom user value associated with this object. **/
    public org.ogre4j.IAny getUserAny() {
         return new org.ogre4j.Any(new InstancePointer(_getUserAny_const(this.object.pointer)));
    }

    private native long _getUserAny_const(long _pointer_);

    /** 
    Sets render system private data **/
    public org.ogre4j.IRenderable.IRenderSystemData getRenderSystemData() {
         return new org.ogre4j.Renderable.RenderSystemData(new InstancePointer(_getRenderSystemData_const(this.object.pointer)));
    }

    private native long _getRenderSystemData_const(long _pointer_);

    /** 
    gets render system private data **/
    public void setRenderSystemData(org.ogre4j.IRenderable.IRenderSystemData val) {
        _setRenderSystemData__RenderSystemDatap_const(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _setRenderSystemData__RenderSystemDatap_const(long _pointer_, long val);

}
public enum VertexDataBindChoice implements INativeEnum < VertexDataBindChoice > {
    BIND_ORIGINAL(VertexDataBindChoiceHelper.ENUM_VALUES[0]),
    BIND_SOFTWARE_SKELETAL(VertexDataBindChoiceHelper.ENUM_VALUES[1]),
    BIND_SOFTWARE_MORPH(VertexDataBindChoiceHelper.ENUM_VALUES[2]),
    BIND_HARDWARE_MORPH(VertexDataBindChoiceHelper.ENUM_VALUES[3]);

    private int value;

    VertexDataBindChoice(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public VertexDataBindChoice getEnum(int val) {
        return toEnum(val);
    }

    public static final VertexDataBindChoice toEnum(int retval) {
    if (retval ==BIND_ORIGINAL.value)
        return VertexDataBindChoice.BIND_ORIGINAL;
    else if (retval ==BIND_SOFTWARE_SKELETAL.value)
        return VertexDataBindChoice.BIND_SOFTWARE_SKELETAL;
    else if (retval ==BIND_SOFTWARE_MORPH.value)
        return VertexDataBindChoice.BIND_SOFTWARE_MORPH;
    else if (retval ==BIND_HARDWARE_MORPH.value)
        return VertexDataBindChoice.BIND_HARDWARE_MORPH;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class VertexDataBindChoiceHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

public static class EntitySet extends org.xbig.base.NativeObject implements org.ogre4j.IEntity.IEntitySet {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public EntitySet(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected EntitySet(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public EntitySet(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public EntitySet() {
         super( new org.xbig.base.InstancePointer(__createEntitySet()), false);
    }

    private native static long __createEntitySet();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(org.ogre4j.IEntity key) {
         return _count__Ogre_EntityP(this.object.pointer, key.getInstancePointer().pointer);
    }

    private native int _count__Ogre_EntityP(long _pointer_, long key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(org.ogre4j.IEntity key) {
         return _erase__Ogre_EntityP(this.object.pointer, key.getInstancePointer().pointer);
    }

    private native int _erase__Ogre_EntityP(long _pointer_, long key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

}
public static class ChildObjectList extends org.xbig.base.NativeObject implements org.ogre4j.IEntity.IChildObjectList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public ChildObjectList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected ChildObjectList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public ChildObjectList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public ChildObjectList() {
         super( new org.xbig.base.InstancePointer(__createChildObjectList()), false);
    }

    private native static long __createChildObjectList();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.IMovableObject get(String key) {
         return new org.ogre4j.MovableObject(new InstancePointer(_get__sR(this.object.pointer, key)));
    }

    private native long _get__sR(long _pointer_, String key);

    /** **/
    public void insert(String key, org.ogre4j.IMovableObject value) {
        _insert__sROgre_MovableObjectp(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__sROgre_MovableObjectp(long _pointer_, String key, long value);

}
public static class ChildObjectListIterator extends org.xbig.base.NativeObject implements org.ogre4j.IEntity.IChildObjectListIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public ChildObjectListIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected ChildObjectListIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public ChildObjectListIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public ChildObjectListIterator(org.ogre4j.IEntity.IChildObjectList c) {
         super( new org.xbig.base.InstancePointer(__createChildObjectListIterator__Ogre_Entity_ChildObjectListr( c.getInstancePointer().pointer)), false);
    }

    private native static long __createChildObjectListIterator__Ogre_Entity_ChildObjectListr(long c);

    /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public org.ogre4j.IMovableObject getNext() {
         return new org.ogre4j.MovableObject(new InstancePointer(_getNext(this.object.pointer)));
    }

    private native long _getNext(long _pointer_);

    /** **/
    public org.ogre4j.IMovableObject peekNextValue() {
         return new org.ogre4j.MovableObject(new InstancePointer(_peekNextValue(this.object.pointer)));
    }

    private native long _peekNextValue(long _pointer_);

    /** **/
    public String peekNextKey() {
         return _peekNextKey(this.object.pointer);
    }

    private native String _peekNextKey(long _pointer_);

    /** **/
    public org.ogre4j.IEntity.IChildObjectListIterator operatorAssignment(org.ogre4j.IEntity.IChildObjectListIterator rhs) {
         return new org.ogre4j.Entity.ChildObjectListIterator(new InstancePointer(_operatorAssignment___Ogre_Entity_ChildObjectListIteratorr(this.object.pointer, rhs.getInstancePointer().pointer)));
    }

    private native long _operatorAssignment___Ogre_Entity_ChildObjectListIteratorr(long _pointer_, long rhs);

    /** **/
    public NativeObjectPointer<org.ogre4j.IMovableObject> peekNextValuePtr() {
         return new NativeObjectPointer<org.ogre4j.IMovableObject>(new InstancePointer(_peekNextValuePtr(this.object.pointer)));
    }

    private native long _peekNextValuePtr(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext(this.object.pointer);
    }

    private native void _moveNext(long _pointer_);

}
protected static class SubEntityList extends org.xbig.base.NativeObject implements org.ogre4j.IEntity.ISubEntityList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public SubEntityList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected SubEntityList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public SubEntityList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public SubEntityList() {
         super( new org.xbig.base.InstancePointer(__createSubEntityList()), false);
    }

    private native static long __createSubEntityList();

    /** **/
    public void assign(int num, org.ogre4j.ISubEntity val) {
        _assign__ivOgre_SubEntityP(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_SubEntityP(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.ISubEntity at(int loc) {
         return new org.ogre4j.SubEntity(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.ISubEntity back() {
         return new org.ogre4j.SubEntity(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.ISubEntity front() {
         return new org.ogre4j.SubEntity(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.ISubEntity val) {
        _push_back__Ogre_SubEntityP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_SubEntityP(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
protected static class LODEntityList extends org.xbig.base.NativeObject implements org.ogre4j.IEntity.ILODEntityList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public LODEntityList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected LODEntityList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public LODEntityList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public LODEntityList() {
         super( new org.xbig.base.InstancePointer(__createLODEntityList()), false);
    }

    private native static long __createLODEntityList();

    /** **/
    public void assign(int num, org.ogre4j.IEntity val) {
        _assign__ivOgre_EntityP(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_EntityP(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.IEntity at(int loc) {
         return new org.ogre4j.Entity(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.IEntity back() {
         return new org.ogre4j.Entity(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.IEntity front() {
         return new org.ogre4j.Entity(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.IEntity val) {
        _push_back__Ogre_EntityP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_EntityP(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public Entity(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected Entity(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public Entity(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** 
    Gets the  that this  is based on. **/
    public org.ogre4j.IMeshPtr getMesh() {
         return new org.ogre4j.MeshPtr(new InstancePointer(_getMesh_const(this.object.pointer)));
    }

    private native long _getMesh_const(long _pointer_);

    /** 
    Gets a pointer to a , ie a part of an . **/
    public org.ogre4j.ISubEntity getSubEntity(long index) {
         return new org.ogre4j.SubEntity(new InstancePointer(_getSubEntity__Iv_const(this.object.pointer, index)));
    }

    private native long _getSubEntity__Iv_const(long _pointer_, long index);

    /** 
    Gets a pointer to a  by name **/
    public org.ogre4j.ISubEntity getSubEntity(String name) {
         return new org.ogre4j.SubEntity(new InstancePointer(_getSubEntity__StringR_const(this.object.pointer, name)));
    }

    private native long _getSubEntity__StringR_const(long _pointer_, String name);

    /** 
    Retrieves the number of  objects making up this entity. **/
    public long getNumSubEntities() {
         return _getNumSubEntities_const(this.object.pointer);
    }

    private native long _getNumSubEntities_const(long _pointer_);

    /** 
    Clones this entity and returns a pointer to the clone. **/
    public org.ogre4j.IEntity clone(String newName) {
         return new org.ogre4j.Entity(new InstancePointer(_clone__StringR_const(this.object.pointer, newName)));
    }

    private native long _clone__StringR_const(long _pointer_, String newName);

    /** 
    Sets the material to use for the whole of this entity. **/
    public void setMaterialName(String name) {
        _setMaterialName__StringR(this.object.pointer, name);
    }

    private native void _setMaterialName__StringR(long _pointer_, String name);

    /** 
    Overridden - see . **/
    public void _notifyCurrentCamera(org.ogre4j.ICamera cam) {
        __notifyCurrentCamera__Camerap(this.object.pointer, cam.getInstancePointer().pointer);
    }

    private native void __notifyCurrentCamera__Camerap(long _pointer_, long cam);

    /** **/
    public void setRenderQueueGroup(short queueID) {
        _setRenderQueueGroup__uint8v(this.object.pointer, queueID);
    }

    private native void _setRenderQueueGroup__uint8v(long _pointer_, short queueID);

    /** 
    Overridden - see . **/
    public org.ogre4j.IAxisAlignedBox getBoundingBox() {
         return new org.ogre4j.AxisAlignedBox(new InstancePointer(_getBoundingBox_const(this.object.pointer)));
    }

    private native long _getBoundingBox_const(long _pointer_);

    /** **/
    public void getChildObjectsBoundingBox(org.ogre4j.IAxisAlignedBox returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getChildObjectsBoundingBox_const(this.object.pointer)), false);
    }

    private native long _getChildObjectsBoundingBox_const(long _pointer_);

    /** 
    Overridden - see . **/
    public void _updateRenderQueue(org.ogre4j.IRenderQueue queue) {
        __updateRenderQueue__RenderQueuep(this.object.pointer, queue.getInstancePointer().pointer);
    }

    private native void __updateRenderQueue__RenderQueuep(long _pointer_, long queue);

    /** 
    Overridden from **/
    public String getMovableType() {
         return _getMovableType_const(this.object.pointer);
    }

    private native String _getMovableType_const(long _pointer_);

    /** 
    For entities based on animated meshes, gets the  object for a single animation. **/
    public org.ogre4j.IAnimationState getAnimationState(String name) {
         return new org.ogre4j.AnimationState(new InstancePointer(_getAnimationState__StringR_const(this.object.pointer, name)));
    }

    private native long _getAnimationState__StringR_const(long _pointer_, String name);

    /** 
    For entities based on animated meshes, gets the  objects for all animations. **/
    public org.ogre4j.IAnimationStateSet getAllAnimationStates() {
         return new org.ogre4j.AnimationStateSet(new InstancePointer(_getAllAnimationStates_const(this.object.pointer)));
    }

    private native long _getAllAnimationStates_const(long _pointer_);

    /** 
    Tells the  whether or not it should display it's skeleton, if it has one. **/
    public void setDisplaySkeleton(boolean display) {
        _setDisplaySkeleton__bv(this.object.pointer, display);
    }

    private native void _setDisplaySkeleton__bv(long _pointer_, boolean display);

    /** 
    Returns whether or not the entity is currently displaying its skeleton. **/
    public boolean getDisplaySkeleton() {
         return _getDisplaySkeleton_const(this.object.pointer);
    }

    private native boolean _getDisplaySkeleton_const(long _pointer_);

    /** 
    Gets a pointer to the entity representing the numbered manual level of detail. **/
    public org.ogre4j.IEntity getManualLodLevel(int index) {
         return new org.ogre4j.Entity(new InstancePointer(_getManualLodLevel__iv_const(this.object.pointer, index)));
    }

    private native long _getManualLodLevel__iv_const(long _pointer_, int index);

    /** 
    Returns the number of manual levels of detail that this entity supports. **/
    public int getNumManualLodLevels() {
         return _getNumManualLodLevels_const(this.object.pointer);
    }

    private native int _getNumManualLodLevels_const(long _pointer_);

    /** 
    Returns the current LOD used to render **/
    public int getCurrentLodIndex() {
         return _getCurrentLodIndex(this.object.pointer);
    }

    private native int _getCurrentLodIndex(long _pointer_);

    /** 
    Sets a level-of-detail bias for the mesh detail of this entity. **/
    public void setMeshLodBias(float factor, int maxDetailIndex, int minDetailIndex) {
        _setMeshLodBias__Realvushortvushortv(this.object.pointer, factor,  maxDetailIndex,  minDetailIndex);
    }

    private native void _setMeshLodBias__Realvushortvushortv(long _pointer_, float factor, int maxDetailIndex, int minDetailIndex);

    /** 
    Sets a level-of-detail bias for the material detail of this entity. **/
    public void setMaterialLodBias(float factor, int maxDetailIndex, int minDetailIndex) {
        _setMaterialLodBias__Realvushortvushortv(this.object.pointer, factor,  maxDetailIndex,  minDetailIndex);
    }

    private native void _setMaterialLodBias__Realvushortvushortv(long _pointer_, float factor, int maxDetailIndex, int minDetailIndex);

    /** 
    Sets whether the polygon mode of this entire entity may be overridden by the camera detail settings. **/
    public void setPolygonModeOverrideable(boolean PolygonModeOverrideable) {
        _setPolygonModeOverrideable__bv(this.object.pointer, PolygonModeOverrideable);
    }

    private native void _setPolygonModeOverrideable__bv(long _pointer_, boolean PolygonModeOverrideable);

    /** 
    Attaches another object to a certain bone of the skeleton which this entity uses. **/
    public org.ogre4j.ITagPoint attachObjectToBone(String boneName, org.ogre4j.IMovableObject pMovable, org.ogre4j.IQuaternion offsetOrientation, org.ogre4j.IVector3 offsetPosition) {
         return new org.ogre4j.TagPoint(new InstancePointer(_attachObjectToBone__StringRMovableObjectpQuaternionRVector3R(this.object.pointer, boneName,  pMovable.getInstancePointer().pointer,  offsetOrientation.getInstancePointer().pointer,  offsetPosition.getInstancePointer().pointer)));
    }

    private native long _attachObjectToBone__StringRMovableObjectpQuaternionRVector3R(long _pointer_, String boneName, long pMovable, long offsetOrientation, long offsetPosition);

    /** 
    Detach a  previously attached using attachObjectToBone. If the movable object name is not found then an exception is raised. **/
    public org.ogre4j.IMovableObject detachObjectFromBone(String movableName) {
         return new org.ogre4j.MovableObject(new InstancePointer(_detachObjectFromBone__StringR(this.object.pointer, movableName)));
    }

    private native long _detachObjectFromBone__StringR(long _pointer_, String movableName);

    /** 
    Detaches an object by pointer. **/
    public void detachObjectFromBone(org.ogre4j.IMovableObject obj) {
        _detachObjectFromBone__MovableObjectp(this.object.pointer, obj.getInstancePointer().pointer);
    }

    private native void _detachObjectFromBone__MovableObjectp(long _pointer_, long obj);

    /** **/
    public void detachAllObjectsFromBone() {
        _detachAllObjectsFromBone(this.object.pointer);
    }

    private native void _detachAllObjectsFromBone(long _pointer_);

    /** 
    Gets an iterator to the list of objects attached to bones on this entity. **/
    public void getAttachedObjectIterator(org.ogre4j.IEntity.IChildObjectListIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getAttachedObjectIterator(this.object.pointer)), false);
    }

    private native long _getAttachedObjectIterator(long _pointer_);

    /** 
    **/
    public float getBoundingRadius() {
         return _getBoundingRadius_const(this.object.pointer);
    }

    private native float _getBoundingRadius_const(long _pointer_);

    /** 
    **/
    public org.ogre4j.IAxisAlignedBox getWorldBoundingBox(boolean derive) {
         return new org.ogre4j.AxisAlignedBox(new InstancePointer(_getWorldBoundingBox__bv_const(this.object.pointer, derive)));
    }

    private native long _getWorldBoundingBox__bv_const(long _pointer_, boolean derive);

    /** 
    **/
    public org.ogre4j.ISphere getWorldBoundingSphere(boolean derive) {
         return new org.ogre4j.Sphere(new InstancePointer(_getWorldBoundingSphere__bv_const(this.object.pointer, derive)));
    }

    private native long _getWorldBoundingSphere__bv_const(long _pointer_, boolean derive);

    /** 
    Overridden member from . **/
    public org.ogre4j.IEdgeData getEdgeList() {
         return new org.ogre4j.EdgeData(new InstancePointer(_getEdgeList(this.object.pointer)));
    }

    private native long _getEdgeList(long _pointer_);

    /** 
    Overridden member from . **/
    public boolean hasEdgeList() {
         return _hasEdgeList(this.object.pointer);
    }

    private native boolean _hasEdgeList(long _pointer_);

    /** 
    Overridden member from . **/
    public void getShadowVolumeRenderableIterator(org.ogre4j.IShadowCaster.IShadowRenderableListIterator returnValue, org.ogre4j.ShadowTechnique shadowTechnique, org.ogre4j.ILight light, org.ogre4j.IHardwareIndexBufferSharedPtr indexBuffer, boolean extrudeVertices, float extrusionDistance, long flags) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getShadowVolumeRenderableIterator__ShadowTechniquevLightPHardwareIndexBufferSharedPtrpbvRealvLv(this.object.pointer, shadowTechnique.getValue(),  light.getInstancePointer().pointer,  indexBuffer.getInstancePointer().pointer,  extrudeVertices,  extrusionDistance,  flags)), false);
    }

    private native long _getShadowVolumeRenderableIterator__ShadowTechniquevLightPHardwareIndexBufferSharedPtrpbvRealvLv(long _pointer_, int shadowTechnique, long light, long indexBuffer, boolean extrudeVertices, float extrusionDistance, long flags);

    /** 
    Internal method for retrieving bone matrix information. **/
    public org.ogre4j.IMatrix4 _getBoneMatrices() {
         return new org.ogre4j.Matrix4(new InstancePointer(__getBoneMatrices_const(this.object.pointer)));
    }

    private native long __getBoneMatrices_const(long _pointer_);

    /** 
    Internal method for retrieving bone matrix information. **/
    public int _getNumBoneMatrices() {
         return __getNumBoneMatrices_const(this.object.pointer);
    }

    private native int __getNumBoneMatrices_const(long _pointer_);

    /** 
    Returns whether or not this entity is skeletally animated. **/
    public boolean hasSkeleton() {
         return _hasSkeleton_const(this.object.pointer);
    }

    private native boolean _hasSkeleton_const(long _pointer_);

    /** 
    Get this Entity's personal skeleton instance. **/
    public org.ogre4j.ISkeletonInstance getSkeleton() {
         return new org.ogre4j.SkeletonInstance(new InstancePointer(_getSkeleton_const(this.object.pointer)));
    }

    private native long _getSkeleton_const(long _pointer_);

    /** 
    Returns whether or not hardware animation is enabled. **/
    public boolean isHardwareAnimationEnabled() {
         return _isHardwareAnimationEnabled_const(this.object.pointer);
    }

    private native boolean _isHardwareAnimationEnabled_const(long _pointer_);

    /** 
    Overridden from **/
    public void _notifyAttached(org.ogre4j.INode parent, boolean isTagPoint) {
        __notifyAttached__Nodepbv(this.object.pointer, parent.getInstancePointer().pointer,  isTagPoint);
    }

    private native void __notifyAttached__Nodepbv(long _pointer_, long parent, boolean isTagPoint);

    /** 
    Returns the number of requests that have been made for software animation **/
    public int getSoftwareAnimationRequests() {
         return _getSoftwareAnimationRequests_const(this.object.pointer);
    }

    private native int _getSoftwareAnimationRequests_const(long _pointer_);

    /** 
    Returns the number of requests that have been made for software animation of normals **/
    public int getSoftwareAnimationNormalsRequests() {
         return _getSoftwareAnimationNormalsRequests_const(this.object.pointer);
    }

    private native int _getSoftwareAnimationNormalsRequests_const(long _pointer_);

    /** 
    Add a request for software animation **/
    public void addSoftwareAnimationRequest(boolean normalsAlso) {
        _addSoftwareAnimationRequest__bv(this.object.pointer, normalsAlso);
    }

    private native void _addSoftwareAnimationRequest__bv(long _pointer_, boolean normalsAlso);

    /** 
    Removes a request for software animation **/
    public void removeSoftwareAnimationRequest(boolean normalsAlso) {
        _removeSoftwareAnimationRequest__bv(this.object.pointer, normalsAlso);
    }

    private native void _removeSoftwareAnimationRequest__bv(long _pointer_, boolean normalsAlso);

    /** 
    Shares the  with the supplied entity. Note that in order for this to work, both entities must have the same . **/
    public void shareSkeletonInstanceWith(org.ogre4j.IEntity entity) {
        _shareSkeletonInstanceWith__Entityp(this.object.pointer, entity.getInstancePointer().pointer);
    }

    private native void _shareSkeletonInstanceWith__Entityp(long _pointer_, long entity);

    /** 
    Returns whether or not this entity is either morph or pose animated. **/
    public boolean hasVertexAnimation() {
         return _hasVertexAnimation_const(this.object.pointer);
    }

    private native boolean _hasVertexAnimation_const(long _pointer_);

    /** 
    Stops sharing the  with other entities. **/
    public void stopSharingSkeletonInstance() {
        _stopSharingSkeletonInstance(this.object.pointer);
    }

    private native void _stopSharingSkeletonInstance(long _pointer_);

    /** 
    Returns whether this entity shares it's SkeltonInstance with other entity instances. **/
    public boolean sharesSkeletonInstance() {
         return _sharesSkeletonInstance_const(this.object.pointer);
    }

    private native boolean _sharesSkeletonInstance_const(long _pointer_);

    /** 
    Returns a pointer to the set of entities which share a . If this instance does not share it's  with other instances NULL will be returned **/
    public org.ogre4j.IEntity.IEntitySet getSkeletonInstanceSharingSet() {
         return new org.ogre4j.Entity.EntitySet(new InstancePointer(_getSkeletonInstanceSharingSet_const(this.object.pointer)));
    }

    private native long _getSkeletonInstanceSharingSet_const(long _pointer_);

    /** 
    Updates the internal animation state set to include the latest available animations from the attached skeleton. **/
    public void refreshAvailableAnimationState() {
        _refreshAvailableAnimationState(this.object.pointer);
    }

    private native void _refreshAvailableAnimationState(long _pointer_);

    /** 
    Advanced method to perform all the updates required for an animated entity. **/
    public void _updateAnimation() {
        __updateAnimation(this.object.pointer);
    }

    private native void __updateAnimation(long _pointer_);

    /** 
    Tests if any animation applied to this entity. **/
    public boolean _isAnimated() {
         return __isAnimated_const(this.object.pointer);
    }

    private native boolean __isAnimated_const(long _pointer_);

    /** 
    Tests if skeleton was animated. **/
    public boolean _isSkeletonAnimated() {
         return __isSkeletonAnimated_const(this.object.pointer);
    }

    private native boolean __isSkeletonAnimated_const(long _pointer_);

    /** 
    Advanced method to get the temporarily blended skeletal vertex information for entities which are software skinned. **/
    public org.ogre4j.IVertexData _getSkelAnimVertexData() {
         return new org.ogre4j.VertexData(new InstancePointer(__getSkelAnimVertexData_const(this.object.pointer)));
    }

    private native long __getSkelAnimVertexData_const(long _pointer_);

    /** 
    Advanced method to get the temporarily blended software vertex animation information **/
    public org.ogre4j.IVertexData _getSoftwareVertexAnimVertexData() {
         return new org.ogre4j.VertexData(new InstancePointer(__getSoftwareVertexAnimVertexData_const(this.object.pointer)));
    }

    private native long __getSoftwareVertexAnimVertexData_const(long _pointer_);

    /** 
    Advanced method to get the hardware morph vertex information **/
    public org.ogre4j.IVertexData _getHardwareVertexAnimVertexData() {
         return new org.ogre4j.VertexData(new InstancePointer(__getHardwareVertexAnimVertexData_const(this.object.pointer)));
    }

    private native long __getHardwareVertexAnimVertexData_const(long _pointer_);

    /** 
    Advanced method to get the temp buffer information for software skeletal animation. **/
    public org.ogre4j.ITempBlendedBufferInfo _getSkelAnimTempBufferInfo() {
         return new org.ogre4j.TempBlendedBufferInfo(new InstancePointer(__getSkelAnimTempBufferInfo(this.object.pointer)));
    }

    private native long __getSkelAnimTempBufferInfo(long _pointer_);

    /** 
    Advanced method to get the temp buffer information for software morph animation. **/
    public org.ogre4j.ITempBlendedBufferInfo _getVertexAnimTempBufferInfo() {
         return new org.ogre4j.TempBlendedBufferInfo(new InstancePointer(__getVertexAnimTempBufferInfo(this.object.pointer)));
    }

    private native long __getVertexAnimTempBufferInfo(long _pointer_);

    /** **/
    public long getTypeFlags() {
         return _getTypeFlags_const(this.object.pointer);
    }

    private native long _getTypeFlags_const(long _pointer_);

    /** **/
    public org.ogre4j.IVertexData getVertexDataForBinding() {
         return new org.ogre4j.VertexData(new InstancePointer(_getVertexDataForBinding(this.object.pointer)));
    }

    private native long _getVertexDataForBinding(long _pointer_);

    /** **/
    public org.ogre4j.Entity.VertexDataBindChoice chooseVertexDataForBinding(boolean hasVertexAnim) {
         return org.ogre4j.Entity.VertexDataBindChoice.toEnum(_chooseVertexDataForBinding__bv_const(this.object.pointer, hasVertexAnim));
    }

    private native int _chooseVertexDataForBinding__bv_const(long _pointer_, boolean hasVertexAnim);

    /** 
    Are buffers already marked as vertex animated? **/
    public boolean _getBuffersMarkedForAnimation() {
         return __getBuffersMarkedForAnimation_const(this.object.pointer);
    }

    private native boolean __getBuffersMarkedForAnimation_const(long _pointer_);

    /** 
    Mark just this vertex data as animated. **/
    public void _markBuffersUsedForAnimation() {
        __markBuffersUsedForAnimation(this.object.pointer);
    }

    private native void __markBuffersUsedForAnimation(long _pointer_);

    /** 
    Has this  been initialised yet? **/
    public boolean isInitialised() {
         return _isInitialised_const(this.object.pointer);
    }

    private native boolean _isInitialised_const(long _pointer_);

    /** 
    Try to initialise the  from the underlying resources. **/
    public void _initialise(boolean forceReinitialise) {
        __initialise__bv(this.object.pointer, forceReinitialise);
    }

    private native void __initialise__bv(long _pointer_, boolean forceReinitialise);

    /** 
    Tear down the internal structures of this , rendering it uninitialised. **/
    public void _deinitialise() {
        __deinitialise(this.object.pointer);
    }

    private native void __deinitialise(long _pointer_);

    /** 
     hook to notify  that a delay-loaded  is complete. **/
    public void backgroundLoadingComplete(org.ogre4j.IResource res) {
        _backgroundLoadingComplete__Resourcep(this.object.pointer, res.getInstancePointer().pointer);
    }

    private native void _backgroundLoadingComplete__Resourcep(long _pointer_, long res);

    /** **/
    public void visitRenderables(org.ogre4j.IRenderable.IVisitor visitor, boolean debugRenderables) {
        _visitRenderables__Renderable_Visitorpbv(this.object.pointer, visitor.getInstancePointer().pointer,  debugRenderables);
    }

    private native void _visitRenderables__Renderable_Visitorpbv(long _pointer_, long visitor, boolean debugRenderables);

    /** 
    Notify the object of it's creator (internal use only) **/
    public void _notifyCreator(org.ogre4j.IMovableObjectFactory fact) {
        __notifyCreator__MovableObjectFactoryp(this.object.pointer, fact.getInstancePointer().pointer);
    }

    private native void __notifyCreator__MovableObjectFactoryp(long _pointer_, long fact);

    /** 
    Get the creator of this object, if any (internal use only) **/
    public org.ogre4j.IMovableObjectFactory _getCreator() {
         return new org.ogre4j.MovableObjectFactory(new InstancePointer(__getCreator_const(this.object.pointer)));
    }

    private native long __getCreator_const(long _pointer_);

    /** 
    Notify the object of it's manager (internal use only) **/
    public void _notifyManager(org.ogre4j.ISceneManager man) {
        __notifyManager__SceneManagerp(this.object.pointer, man.getInstancePointer().pointer);
    }

    private native void __notifyManager__SceneManagerp(long _pointer_, long man);

    /** 
    Get the manager of this object, if any (internal use only) **/
    public org.ogre4j.ISceneManager _getManager() {
         return new org.ogre4j.SceneManager(new InstancePointer(__getManager_const(this.object.pointer)));
    }

    private native long __getManager_const(long _pointer_);

    /** 
    Returns the name of this object. **/
    public String getName() {
         return _getName_const(this.object.pointer);
    }

    private native String _getName_const(long _pointer_);

    /** 
    Returns the node to which this object is attached. **/
    public org.ogre4j.INode getParentNode() {
         return new org.ogre4j.Node(new InstancePointer(_getParentNode_const(this.object.pointer)));
    }

    private native long _getParentNode_const(long _pointer_);

    /** 
    Returns the scene node to which this object is attached. **/
    public org.ogre4j.ISceneNode getParentSceneNode() {
         return new org.ogre4j.SceneNode(new InstancePointer(_getParentSceneNode_const(this.object.pointer)));
    }

    private native long _getParentSceneNode_const(long _pointer_);

    /** 
    Returns true if this object is attached to a  or . **/
    public boolean isAttached() {
         return _isAttached_const(this.object.pointer);
    }

    private native boolean _isAttached_const(long _pointer_);

    /** 
    Detaches an object from a parent  or , if attached. **/
    public void detatchFromParent() {
        _detatchFromParent(this.object.pointer);
    }

    private native void _detatchFromParent(long _pointer_);

    /** 
    Returns true if this object is attached to a  or , and this  /  is currently in an active part of the scene graph. **/
    public boolean isInScene() {
         return _isInScene_const(this.object.pointer);
    }

    private native boolean _isInScene_const(long _pointer_);

    /** 
    Internal method called to notify the object that it has been moved. **/
    public void _notifyMoved() {
        __notifyMoved(this.object.pointer);
    }

    private native void __notifyMoved(long _pointer_);

    /** 
    Tells this object whether to be visible or not, if it has a renderable component. **/
    public void setVisible(boolean visible) {
        _setVisible__bv(this.object.pointer, visible);
    }

    private native void _setVisible__bv(long _pointer_, boolean visible);

    /** 
    Gets this object whether to be visible or not, if it has a renderable component. **/
    public boolean getVisible() {
         return _getVisible_const(this.object.pointer);
    }

    private native boolean _getVisible_const(long _pointer_);

    /** 
    Returns whether or not this object is supposed to be visible or not. **/
    public boolean isVisible() {
         return _isVisible_const(this.object.pointer);
    }

    private native boolean _isVisible_const(long _pointer_);

    /** 
    Sets the distance at which the object is no longer rendered. **/
    public void setRenderingDistance(float dist) {
        _setRenderingDistance__Realv(this.object.pointer, dist);
    }

    private native void _setRenderingDistance__Realv(long _pointer_, float dist);

    /** 
    Gets the distance at which batches are no longer rendered. **/
    public float getRenderingDistance() {
         return _getRenderingDistance_const(this.object.pointer);
    }

    private native float _getRenderingDistance_const(long _pointer_);

    /** 
    Call this to associate your own custom user object instance with this . **/
    public void setUserObject(org.ogre4j.IUserDefinedObject obj) {
        _setUserObject__UserDefinedObjectp(this.object.pointer, obj.getInstancePointer().pointer);
    }

    private native void _setUserObject__UserDefinedObjectp(long _pointer_, long obj);

    /** 
    Retrieves a pointer to a custom application object associated with this movable by an earlier call to setUserObject. **/
    public org.ogre4j.IUserDefinedObject getUserObject() {
         return new org.ogre4j.UserDefinedObject(new InstancePointer(_getUserObject(this.object.pointer)));
    }

    private native long _getUserObject(long _pointer_);

    /** 
    Sets any kind of user value on this object. **/
    public void setUserAny(org.ogre4j.IAny anything) {
        _setUserAny__AnyR(this.object.pointer, anything.getInstancePointer().pointer);
    }

    private native void _setUserAny__AnyR(long _pointer_, long anything);

    /** 
    Retrieves the custom user value associated with this object. **/
    public org.ogre4j.IAny getUserAny() {
         return new org.ogre4j.Any(new InstancePointer(_getUserAny_const(this.object.pointer)));
    }

    private native long _getUserAny_const(long _pointer_);

    /** 
    Gets the queue group for this entity, see setRenderQueueGroup for full details. **/
    public short getRenderQueueGroup() {
         return _getRenderQueueGroup_const(this.object.pointer);
    }

    private native short _getRenderQueueGroup_const(long _pointer_);

    /** **/
    public org.ogre4j.IMatrix4 _getParentNodeFullTransform() {
         return new org.ogre4j.Matrix4(new InstancePointer(__getParentNodeFullTransform_const(this.object.pointer)));
    }

    private native long __getParentNodeFullTransform_const(long _pointer_);

    /** 
    Sets the query flags for this object. **/
    public void setQueryFlags(long flags) {
        _setQueryFlags__uint32v(this.object.pointer, flags);
    }

    private native void _setQueryFlags__uint32v(long _pointer_, long flags);

    /** 
    As setQueryFlags, except the flags passed as parameters are appended to the existing flags on this object. **/
    public void addQueryFlags(long flags) {
        _addQueryFlags__uint32v(this.object.pointer, flags);
    }

    private native void _addQueryFlags__uint32v(long _pointer_, long flags);

    /** 
    As setQueryFlags, except the flags passed as parameters are removed from the existing flags on this object. **/
    public void removeQueryFlags(long flags) {
        _removeQueryFlags__Lv(this.object.pointer, flags);
    }

    private native void _removeQueryFlags__Lv(long _pointer_, long flags);

    /** **/
    public long getQueryFlags() {
         return _getQueryFlags_const(this.object.pointer);
    }

    private native long _getQueryFlags_const(long _pointer_);

    /** 
    Sets the visiblity flags for this object. **/
    public void setVisibilityFlags(long flags) {
        _setVisibilityFlags__uint32v(this.object.pointer, flags);
    }

    private native void _setVisibilityFlags__uint32v(long _pointer_, long flags);

    /** 
    As setVisibilityFlags, except the flags passed as parameters are appended to the existing flags on this object. **/
    public void addVisibilityFlags(long flags) {
        _addVisibilityFlags__uint32v(this.object.pointer, flags);
    }

    private native void _addVisibilityFlags__uint32v(long _pointer_, long flags);

    /** 
    As setVisibilityFlags, except the flags passed as parameters are removed from the existing flags on this object. **/
    public void removeVisibilityFlags(long flags) {
        _removeVisibilityFlags__uint32v(this.object.pointer, flags);
    }

    private native void _removeVisibilityFlags__uint32v(long _pointer_, long flags);

    /** **/
    public long getVisibilityFlags() {
         return _getVisibilityFlags_const(this.object.pointer);
    }

    private native long _getVisibilityFlags_const(long _pointer_);

    /** 
    Sets a listener for this object. **/
    public void setListener(org.ogre4j.IMovableObject.IListener listener) {
        _setListener__Listenerp(this.object.pointer, listener.getInstancePointer().pointer);
    }

    private native void _setListener__Listenerp(long _pointer_, long listener);

    /** 
    Gets the current listener for this object. **/
    public org.ogre4j.IMovableObject.IListener getListener() {
         return new org.ogre4j.MovableObject.Listener(new InstancePointer(_getListener_const(this.object.pointer)));
    }

    private native long _getListener_const(long _pointer_);

    /** 
    Gets a list of lights, ordered relative to how close they are to this movable object. **/
    public org.ogre4j.ILightList queryLights() {
         return new org.ogre4j.LightList(new InstancePointer(_queryLights_const(this.object.pointer)));
    }

    private native long _queryLights_const(long _pointer_);

    /** 
    Returns a pointer to the current list of lights for this object. **/
    public org.ogre4j.ILightList _getLightList() {
         return new org.ogre4j.LightList(new InstancePointer(__getLightList(this.object.pointer)));
    }

    private native long __getLightList(long _pointer_);

    /** 
    Overridden member from . **/
    public org.ogre4j.IAxisAlignedBox getLightCapBounds() {
         return new org.ogre4j.AxisAlignedBox(new InstancePointer(_getLightCapBounds_const(this.object.pointer)));
    }

    private native long _getLightCapBounds_const(long _pointer_);

    /** 
    Overridden member from . **/
    public org.ogre4j.IAxisAlignedBox getDarkCapBounds(org.ogre4j.ILight light, float dirLightExtrusionDist) {
         return new org.ogre4j.AxisAlignedBox(new InstancePointer(_getDarkCapBounds__LightRRealv_const(this.object.pointer, light.getInstancePointer().pointer,  dirLightExtrusionDist)));
    }

    private native long _getDarkCapBounds__LightRRealv_const(long _pointer_, long light, float dirLightExtrusionDist);

    /** 
    Sets whether or not this object will cast shadows. **/
    public void setCastShadows(boolean enabled) {
        _setCastShadows__bv(this.object.pointer, enabled);
    }

    private native void _setCastShadows__bv(long _pointer_, boolean enabled);

    /** 
    Returns whether shadow casting is enabled for this object. **/
    public boolean getCastShadows() {
         return _getCastShadows_const(this.object.pointer);
    }

    private native boolean _getCastShadows_const(long _pointer_);

    /** 
    Get the distance to extrude for a point/spot light **/
    public float getPointExtrusionDistance(org.ogre4j.ILight l) {
         return _getPointExtrusionDistance__LightP_const(this.object.pointer, l.getInstancePointer().pointer);
    }

    private native float _getPointExtrusionDistance__LightP_const(long _pointer_, long l);

    /** 
    Sets whether or not the debug display of this object is enabled. **/
    public void setDebugDisplayEnabled(boolean enabled) {
        _setDebugDisplayEnabled__bv(this.object.pointer, enabled);
    }

    private native void _setDebugDisplayEnabled__bv(long _pointer_, boolean enabled);

    /** **/
    public boolean isDebugDisplayEnabled() {
         return _isDebugDisplayEnabled_const(this.object.pointer);
    }

    private native boolean _isDebugDisplayEnabled_const(long _pointer_);

    /** 
    Set the default query flags for all future  instances. **/
    public static void setDefaultQueryFlags(long flags) {
        _setDefaultQueryFlags__uint32v( flags);
    }

    private native static void _setDefaultQueryFlags__uint32v(long flags);

    /** 
    Get the default query flags for all future  instances. **/
    public static long getDefaultQueryFlags() {
         return _getDefaultQueryFlags();
    }

    private native static long _getDefaultQueryFlags();

    /** 
    Set the default visibility flags for all future  instances. **/
    public static void setDefaultVisibilityFlags(long flags) {
        _setDefaultVisibilityFlags__uint32v( flags);
    }

    private native static void _setDefaultVisibilityFlags__uint32v(long flags);

    /** 
    Get the default visibility flags for all future  instances. **/
    public static long getDefaultVisibilityFlags() {
         return _getDefaultVisibilityFlags();
    }

    private native static long _getDefaultVisibilityFlags();

    /** 
    Utility method for extruding vertices based on a light. **/
    public static void extrudeVertices(org.ogre4j.IHardwareVertexBufferSharedPtr vertexBuffer, int originalVertexCount, org.ogre4j.IVector4 lightPos, float extrudeDist) {
        _extrudeVertices__HardwareVertexBufferSharedPtrRivVector4RRealv( vertexBuffer.getInstancePointer().pointer,  originalVertexCount,  lightPos.getInstancePointer().pointer,  extrudeDist);
    }

    private native static void _extrudeVertices__HardwareVertexBufferSharedPtrRivVector4RRealv(long vertexBuffer, int originalVertexCount, long lightPos, float extrudeDist);

    /** 
    Gets a list of animable value names for this object. **/
    public org.ogre4j.IStringVector getAnimableValueNames() {
         return new org.ogre4j.StringVector(new InstancePointer(_getAnimableValueNames_const(this.object.pointer)));
    }

    private native long _getAnimableValueNames_const(long _pointer_);

    /** 
    Create a reference-counted AnimableValuePtr for the named value. **/
    public void createAnimableValue(org.ogre4j.IAnimableValuePtr returnValue, String valueName) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_createAnimableValue__StringR(this.object.pointer, valueName)), false);
    }

    private native long _createAnimableValue__StringR(long _pointer_, String valueName);

    /** 
     is being destroyed **/
    public void objectDestroyed(org.ogre4j.IMovableObject a1) {
            throw new UnsupportedOperationException("This method is on ignore list!");
    }



    /** 
     has been attached to a node **/
    public void objectAttached(org.ogre4j.IMovableObject a1) {
            throw new UnsupportedOperationException("This method is on ignore list!");
    }



    /** 
     has been detached from a node **/
    public void objectDetached(org.ogre4j.IMovableObject a1) {
            throw new UnsupportedOperationException("This method is on ignore list!");
    }



    /** 
     has been moved **/
    public void objectMoved(org.ogre4j.IMovableObject a1) {
            throw new UnsupportedOperationException("This method is on ignore list!");
    }



    /** 
    Called when the movable object of the camera to be used for rendering. **/
    public boolean objectRendering(org.ogre4j.IMovableObject a1, org.ogre4j.ICamera a2) {
            throw new UnsupportedOperationException("This method is on ignore list!");
    }



    /** 
    Called when the movable object needs to query a light list. **/
    public org.ogre4j.ILightList objectQueryLights(org.ogre4j.IMovableObject a1) {
            throw new UnsupportedOperationException("This method is on ignore list!");
    }



}
