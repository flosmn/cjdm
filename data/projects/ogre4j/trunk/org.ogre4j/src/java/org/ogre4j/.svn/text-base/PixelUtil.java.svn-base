/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class PixelUtil extends org.xbig.base.NativeObject implements org.ogre4j.IPixelUtil {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public PixelUtil(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected PixelUtil(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public PixelUtil(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** 
    Returns the size in bytes of an element of the given pixel format. **/
    public static int getNumElemBytes(org.ogre4j.PixelFormat format) {
         return _getNumElemBytes__PixelFormatv( format.getValue());
    }

    private native static int _getNumElemBytes__PixelFormatv(int format);

    /** 
    Returns the size in bits of an element of the given pixel format. **/
    public static int getNumElemBits(org.ogre4j.PixelFormat format) {
         return _getNumElemBits__PixelFormatv( format.getValue());
    }

    private native static int _getNumElemBits__PixelFormatv(int format);

    /** 
    Returns the size in memory of a region with the given extents and pixel format with consecutive memory layout. **/
    public static int getMemorySize(int width, int height, int depth, org.ogre4j.PixelFormat format) {
         return _getMemorySize__ivivivPixelFormatv( width,  height,  depth,  format.getValue());
    }

    private native static int _getMemorySize__ivivivPixelFormatv(int width, int height, int depth, int format);

    /** 
    Returns the property flags for this pixel format **/
    public static long getFlags(org.ogre4j.PixelFormat format) {
         return _getFlags__PixelFormatv( format.getValue());
    }

    private native static long _getFlags__PixelFormatv(int format);

    /** 
    Shortcut method to determine if the format has an alpha component **/
    public static boolean hasAlpha(org.ogre4j.PixelFormat format) {
         return _hasAlpha__PixelFormatv( format.getValue());
    }

    private native static boolean _hasAlpha__PixelFormatv(int format);

    /** 
    Shortcut method to determine if the format is floating point **/
    public static boolean isFloatingPoint(org.ogre4j.PixelFormat format) {
         return _isFloatingPoint__PixelFormatv( format.getValue());
    }

    private native static boolean _isFloatingPoint__PixelFormatv(int format);

    /** 
    Shortcut method to determine if the format is compressed **/
    public static boolean isCompressed(org.ogre4j.PixelFormat format) {
         return _isCompressed__PixelFormatv( format.getValue());
    }

    private native static boolean _isCompressed__PixelFormatv(int format);

    /** 
    Shortcut method to determine if the format is a depth format. **/
    public static boolean isDepth(org.ogre4j.PixelFormat format) {
         return _isDepth__PixelFormatv( format.getValue());
    }

    private native static boolean _isDepth__PixelFormatv(int format);

    /** 
    Shortcut method to determine if the format is in native endian format. **/
    public static boolean isNativeEndian(org.ogre4j.PixelFormat format) {
         return _isNativeEndian__PixelFormatv( format.getValue());
    }

    private native static boolean _isNativeEndian__PixelFormatv(int format);

    /** 
    Shortcut method to determine if the format is a luminance format. **/
    public static boolean isLuminance(org.ogre4j.PixelFormat format) {
         return _isLuminance__PixelFormatv( format.getValue());
    }

    private native static boolean _isLuminance__PixelFormatv(int format);

    /** 
    Return wether a certain image extent is valid for this image format. **/
    public static boolean isValidExtent(int width, int height, int depth, org.ogre4j.PixelFormat format) {
         return _isValidExtent__ivivivPixelFormatv( width,  height,  depth,  format.getValue());
    }

    private native static boolean _isValidExtent__ivivivPixelFormatv(int width, int height, int depth, int format);









    /** 
    Gets the name of an image format **/
    public static String getFormatName(org.ogre4j.PixelFormat srcformat) {
         return _getFormatName__PixelFormatv( srcformat.getValue());
    }

    private native static String _getFormatName__PixelFormatv(int srcformat);

    /** 
    Returns wether the format can be packed or unpacked with the  and  functions. This is generally not true for compressed and depth formats as they are special. It can only be true for formats with a fixed element size. **/
    public static boolean isAccessible(org.ogre4j.PixelFormat srcformat) {
         return _isAccessible__PixelFormatv( srcformat.getValue());
    }

    private native static boolean _isAccessible__PixelFormatv(int srcformat);

    /** 
    Returns the component type for a certain pixel format. Returns PCT_BYTE in case there is no clear component type like with compressed formats. This is one of PCT_BYTE, PCT_SHORT, PCT_FLOAT16, PCT_FLOAT32. **/
    public static org.ogre4j.PixelComponentType getComponentType(org.ogre4j.PixelFormat fmt) {
         return org.ogre4j.PixelComponentType.toEnum(_getComponentType__PixelFormatv( fmt.getValue()));
    }

    private native static int _getComponentType__PixelFormatv(int fmt);

    /** 
    Returns the component count for a certain pixel format. Returns 3(no alpha) or 4 (has alpha) in case there is no clear component type like with compressed formats. **/
    public static int getComponentCount(org.ogre4j.PixelFormat fmt) {
         return _getComponentCount__PixelFormatv( fmt.getValue());
    }

    private native static int _getComponentCount__PixelFormatv(int fmt);

    /** 
    Gets the format from given name. **/
    public static org.ogre4j.PixelFormat getFormatFromName(String name, boolean accessibleOnly, boolean caseSensitive) {
         return org.ogre4j.PixelFormat.toEnum(_getFormatFromName__StringRbvbv( name,  accessibleOnly,  caseSensitive));
    }

    private native static int _getFormatFromName__StringRbvbv(String name, boolean accessibleOnly, boolean caseSensitive);

    /** 
    Gets the BNF expression of the pixel-formats. **/
    public static String getBNFExpressionOfPixelFormats(boolean accessibleOnly) {
         return _getBNFExpressionOfPixelFormats__bv( accessibleOnly);
    }

    private native static String _getBNFExpressionOfPixelFormats__bv(boolean accessibleOnly);

    /** 
    Returns the similar format but acoording with given bit depths. **/
    public static org.ogre4j.PixelFormat getFormatForBitDepths(org.ogre4j.PixelFormat fmt, int integerBits, int floatBits) {
         return org.ogre4j.PixelFormat.toEnum(_getFormatForBitDepths__PixelFormatvushortvushortv( fmt.getValue(),  integerBits,  floatBits));
    }

    private native static int _getFormatForBitDepths__PixelFormatvushortvushortv(int fmt, int integerBits, int floatBits);

    /** 
    Pack a colour value to memory **/
    public static void packColour(org.ogre4j.IColourValue colour, org.ogre4j.PixelFormat pf, VoidPointer dest) {
        _packColour__ColourValueRPixelFormatVvp( colour.getInstancePointer().pointer,  pf.getValue(),  dest.object.pointer);
    }

    private native static void _packColour__ColourValueRPixelFormatVvp(long colour, int pf, long dest);

    /** 
    Pack a colour value to memory **/
    public static void packColour(short r, short g, short b, short a, org.ogre4j.PixelFormat pf, VoidPointer dest) {
        _packColour__uint8Vuint8Vuint8Vuint8VPixelFormatVvp( r,  g,  b,  a,  pf.getValue(),  dest.object.pointer);
    }

    private native static void _packColour__uint8Vuint8Vuint8Vuint8VPixelFormatVvp(short r, short g, short b, short a, int pf, long dest);

    /** 
    Pack a colour value to memory **/
    public static void packColour(float r, float g, float b, float a, org.ogre4j.PixelFormat pf, VoidPointer dest) {
        _packColour__FVFVFVFVPixelFormatVvp( r,  g,  b,  a,  pf.getValue(),  dest.object.pointer);
    }

    private native static void _packColour__FVFVFVFVPixelFormatVvp(float r, float g, float b, float a, int pf, long dest);

    /** 
    Unpack a colour value from memory **/
    public static void unpackColour(org.ogre4j.IColourValue colour, org.ogre4j.PixelFormat pf, VoidPointer src) {
        _unpackColour__ColourValuepPixelFormatvvP( colour.getInstancePointer().pointer,  pf.getValue(),  src.object.pointer);
    }

    private native static void _unpackColour__ColourValuepPixelFormatvvP(long colour, int pf, long src);

    /** 
    Unpack a colour value from memory **/
    public static void unpackColour(ShortPointer r, ShortPointer g, ShortPointer b, ShortPointer a, org.ogre4j.PixelFormat pf, VoidPointer src) {
        _unpackColour__uint8puint8puint8puint8pPixelFormatvvP( r.object.pointer,  g.object.pointer,  b.object.pointer,  a.object.pointer,  pf.getValue(),  src.object.pointer);
    }

    private native static void _unpackColour__uint8puint8puint8puint8pPixelFormatvvP(long r, long g, long b, long a, int pf, long src);

    /** 
    Unpack a colour value from memory **/
    public static void unpackColour(FloatPointer r, FloatPointer g, FloatPointer b, FloatPointer a, org.ogre4j.PixelFormat pf, VoidPointer src) {
        _unpackColour__FpFpFpFpPixelFormatvvP( r.object.pointer,  g.object.pointer,  b.object.pointer,  a.object.pointer,  pf.getValue(),  src.object.pointer);
    }

    private native static void _unpackColour__FpFpFpFpPixelFormatvvP(long r, long g, long b, long a, int pf, long src);

    /** 
    Convert consecutive pixels from one format to another. No dithering or filtering is being done. Converting from RGB to luminance takes the R channel. In case the source and destination format match, just a copy is done. **/
    public static void bulkPixelConversion(VoidPointer src, org.ogre4j.PixelFormat srcFormat, VoidPointer dest, org.ogre4j.PixelFormat dstFormat, long count) {
        _bulkPixelConversion__vpPixelFormatvvpPixelFormatvIv( src.object.pointer,  srcFormat.getValue(),  dest.object.pointer,  dstFormat.getValue(),  count);
    }

    private native static void _bulkPixelConversion__vpPixelFormatvvpPixelFormatvIv(long src, int srcFormat, long dest, int dstFormat, long count);

    /** 
    Convert pixels from one format to another. No dithering or filtering is being done. Converting from RGB to luminance takes the R channel. **/
    public static void bulkPixelConversion(org.ogre4j.IPixelBox src, org.ogre4j.IPixelBox dst) {
        _bulkPixelConversion__PixelBoxRPixelBoxR( src.getInstancePointer().pointer,  dst.getInstancePointer().pointer);
    }

    private native static void _bulkPixelConversion__PixelBoxRPixelBoxR(long src, long dst);

    /** **/
    public PixelUtil() {
         super( new org.xbig.base.InstancePointer(__createPixelUtil()), false);
    }

    private native static long __createPixelUtil();

}
