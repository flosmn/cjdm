/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public interface IRenderSystemCapabilities extends INativeObject, org.ogre4j.IRenderSysAllocatedObject {

public interface IShaderProfiles extends INativeObject, org.std.Iset< String > {

    /** **/
    public void clear();

    /** **/
    public int count(String key);

    /** **/
    public boolean empty();

    /** **/
    public int erase(String key);

    /** **/
    public int max_size();

    /** **/
    public int size();

}
    /** **/
    public int calculateSize();

    /** 
    Set the driver version. **/
    public void setDriverVersion(org.ogre4j.IDriverVersion version);

    /** **/
    public void parseDriverVersionFromString(String versionString);

    /** **/
    public void getDriverVersion(org.ogre4j.IDriverVersion returnValue);

    /** **/
    public org.ogre4j.GPUVendor getVendor();

    /** **/
    public void setVendor(org.ogre4j.GPUVendor v);

    /** **/
    public void parseVendorFromString(String vendorString);

    /** **/
    public boolean isDriverOlderThanVersion(org.ogre4j.IDriverVersion v);

    /** **/
    public void setNumWorldMatrices(int num);

    /** **/
    public void setNumTextureUnits(int num);

    /** **/
    public void setStencilBufferBitDepth(int num);

    /** **/
    public void setNumVertexBlendMatrices(int num);

    /** **/
    public void setNumMultiRenderTargets(int num);

    /** **/
    public int getNumWorldMatrices();

    /** 
    Returns the number of texture units the current output hardware supports.
    For use in rendering, this determines how many texture units the are available for multitexturing (i.e. rendering multiple textures in a single pass). Where a  has multiple texture layers, it will try to use multitexturing where available, and where it is not available, will perform multipass rendering to achieve the same effect. This property only applies to the fixed-function pipeline, the number available to the programmable pipeline depends on the shader model in use. **/
    public int getNumTextureUnits();

    /** 
    Determines the bit depth of the hardware accelerated stencil buffer, if supported. **/
    public int getStencilBufferBitDepth();

    /** 
    Returns the number of matrices available to hardware vertex blending for this rendering system. **/
    public int getNumVertexBlendMatrices();

    /** **/
    public int getNumMultiRenderTargets();

    /** 
    Returns true if capability is render system specific **/
    public boolean isCapabilityRenderSystemSpecific(org.ogre4j.Capabilities c);

    /** 
    Adds a capability flag **/
    public void setCapability(org.ogre4j.Capabilities c);

    /** 
    Remove a capability flag **/
    public void unsetCapability(org.ogre4j.Capabilities c);

    /** 
    Checks for a capability **/
    public boolean hasCapability(org.ogre4j.Capabilities c);

    /** 
    Adds the profile to the list of supported profiles **/
    public void addShaderProfile(String profile);

    /** 
    Remove a given shader profile, if present. **/
    public void removeShaderProfile(String profile);

    /** 
    Returns true if profile is in the list of supported profiles **/
    public boolean isShaderProfileSupported(String profile);

    /** 
    Returns a set of all supported shader profiles **/
    public org.ogre4j.IRenderSystemCapabilities.IShaderProfiles getSupportedShaderProfiles();

    /** **/
    public int getVertexProgramConstantFloatCount();

    /** **/
    public int getVertexProgramConstantIntCount();

    /** **/
    public int getVertexProgramConstantBoolCount();

    /** **/
    public int getGeometryProgramConstantFloatCount();

    /** **/
    public int getGeometryProgramConstantIntCount();

    /** **/
    public int getGeometryProgramConstantBoolCount();

    /** **/
    public int getFragmentProgramConstantFloatCount();

    /** **/
    public int getFragmentProgramConstantIntCount();

    /** **/
    public int getFragmentProgramConstantBoolCount();

    /** **/
    public void setDeviceName(String name);

    /** **/
    public String getDeviceName();

    /** **/
    public void setVertexProgramConstantFloatCount(int c);

    /** **/
    public void setVertexProgramConstantIntCount(int c);

    /** **/
    public void setVertexProgramConstantBoolCount(int c);

    /** **/
    public void setGeometryProgramConstantFloatCount(int c);

    /** **/
    public void setGeometryProgramConstantIntCount(int c);

    /** **/
    public void setGeometryProgramConstantBoolCount(int c);

    /** **/
    public void setFragmentProgramConstantFloatCount(int c);

    /** **/
    public void setFragmentProgramConstantIntCount(int c);

    /** **/
    public void setFragmentProgramConstantBoolCount(int c);

    /** **/
    public void setMaxPointSize(float s);

    /** **/
    public float getMaxPointSize();

    /** **/
    public void setNonPOW2TexturesLimited(boolean l);

    /** 
    Are non-power of two textures limited in features? **/
    public boolean getNonPOW2TexturesLimited();

    /** **/
    public void setNumVertexTextureUnits(int n);

    /** **/
    public int getNumVertexTextureUnits();

    /** **/
    public void setVertexTextureUnitsShared(boolean shared);

    /** **/
    public boolean getVertexTextureUnitsShared();

    /** **/
    public void setGeometryProgramNumOutputVertices(int numOutputVertices);

    /** **/
    public int getGeometryProgramNumOutputVertices();

    /** **/
    public String getRenderSystemName();

    /** **/
    public void setRenderSystemName(String rs);

    /** **/
    public void setCategoryRelevant(org.ogre4j.CapabilitiesCategory cat, boolean relevant);

    /** **/
    public boolean isCategoryRelevant(org.ogre4j.CapabilitiesCategory cat);

    /** 
    Write the capabilities to the pass in **/
    public void log(org.ogre4j.ILog pLog);

}
