/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class VertexData extends org.xbig.base.NativeObject implements org.ogre4j.IVertexData {
static { System.loadLibrary("ogre4j");}
public static class HardwareAnimationData extends org.xbig.base.NativeObject implements org.ogre4j.IVertexData.IHardwareAnimationData {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public HardwareAnimationData(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected HardwareAnimationData(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public HardwareAnimationData(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public HardwareAnimationData() {
         super( new org.xbig.base.InstancePointer(__createHardwareAnimationData()), false);
    }

    private native static long __createHardwareAnimationData();

    /** **/
    public org.ogre4j.IVertexElement gettargetVertexElement() {
         return new org.ogre4j.VertexElement(new InstancePointer(_gettargetVertexElement(this.object.pointer)));
    }

    private native long _gettargetVertexElement(long _pointer_);

    /** **/
    public float getparametric() {
         return _getparametric(this.object.pointer);
    }

    private native float _getparametric(long _pointer_);

    /** **/
    public void setparametric(float _jni_value_) {
        _setparametric(this.object.pointer, _jni_value_);
    }

    private native void _setparametric(long _pointer_, float _jni_value_);

}
public static class HardwareAnimationDataList extends org.xbig.base.NativeObject implements org.ogre4j.IVertexData.IHardwareAnimationDataList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public HardwareAnimationDataList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected HardwareAnimationDataList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public HardwareAnimationDataList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public HardwareAnimationDataList() {
         super( new org.xbig.base.InstancePointer(__createHardwareAnimationDataList()), false);
    }

    private native static long __createHardwareAnimationDataList();

    /** **/
    public void assign(int num, org.ogre4j.IVertexData.IHardwareAnimationData val) {
        _assign__ivOgre_VertexData_HardwareAnimationDataR(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_VertexData_HardwareAnimationDataR(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.IVertexData.IHardwareAnimationData at(int loc) {
         return new org.ogre4j.VertexData.HardwareAnimationData(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.IVertexData.IHardwareAnimationData back() {
         return new org.ogre4j.VertexData.HardwareAnimationData(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.IVertexData.IHardwareAnimationData front() {
         return new org.ogre4j.VertexData.HardwareAnimationData(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.IVertexData.IHardwareAnimationData val) {
        _push_back__Ogre_VertexData_HardwareAnimationDataR(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_VertexData_HardwareAnimationDataR(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public VertexData(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected VertexData(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public VertexData(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public VertexData() {
         super( new org.xbig.base.InstancePointer(__createVertexData()), false);
    }

    private native static long __createVertexData();

    /** 
    Clones this vertex data, potentially including replicating any vertex buffers. **/
    public org.ogre4j.IVertexData clone(boolean copyData) {
         return new org.ogre4j.VertexData(new InstancePointer(_clone__bv_const(this.object.pointer, copyData)));
    }

    private native long _clone__bv_const(long _pointer_, boolean copyData);

    /** 
    Modifies the vertex data to be suitable for use for rendering shadow geometry. **/
    public void prepareForShadowVolume() {
        _prepareForShadowVolume(this.object.pointer);
    }

    private native void _prepareForShadowVolume(long _pointer_);

    /** 
    Reorganises the data in the vertex buffers according to the new vertex declaration passed in. Note that new vertex buffers are created and written to, so if the buffers being referenced by this vertex data object are also used by others, then the original buffers will not be damaged by this operation. Once this operation has completed, the new declaration passed in will overwrite the current one. **/
    public void reorganiseBuffers(org.ogre4j.IVertexDeclaration newDeclaration, org.ogre4j.IBufferUsageList bufferUsage) {
        _reorganiseBuffers__VertexDeclarationpBufferUsageListR(this.object.pointer, newDeclaration.getInstancePointer().pointer,  bufferUsage.getInstancePointer().pointer);
    }

    private native void _reorganiseBuffers__VertexDeclarationpBufferUsageListR(long _pointer_, long newDeclaration, long bufferUsage);

    /** 
    Reorganises the data in the vertex buffers according to the new vertex declaration passed in. Note that new vertex buffers are created and written to, so if the buffers being referenced by this vertex data object are also used by others, then the original buffers will not be damaged by this operation. Once this operation has completed, the new declaration passed in will overwrite the current one. This version of the method derives the buffer usages from the existing buffers, by using the 'most flexible' usage from the equivalent sources. **/
    public void reorganiseBuffers(org.ogre4j.IVertexDeclaration newDeclaration) {
        _reorganiseBuffers__VertexDeclarationp(this.object.pointer, newDeclaration.getInstancePointer().pointer);
    }

    private native void _reorganiseBuffers__VertexDeclarationp(long _pointer_, long newDeclaration);

    /** 
    Remove any gaps in the vertex buffer bindings. **/
    public void closeGapsInBindings() {
        _closeGapsInBindings(this.object.pointer);
    }

    private native void _closeGapsInBindings(long _pointer_);

    /** 
    Remove all vertex buffers that never used by the vertex declaration. **/
    public void removeUnusedBuffers() {
        _removeUnusedBuffers(this.object.pointer);
    }

    private native void _removeUnusedBuffers(long _pointer_);

    /** 
    Convert all packed colour values (VET_COLOUR_*) in buffers used to another type. **/
    public void convertPackedColour(org.ogre4j.VertexElementType srcType, org.ogre4j.VertexElementType destType) {
        _convertPackedColour__VertexElementTypevVertexElementTypev(this.object.pointer, srcType.getValue(),  destType.getValue());
    }

    private native void _convertPackedColour__VertexElementTypevVertexElementTypev(long _pointer_, int srcType, int destType);

    /** 
    Allocate elements to serve a holder of morph / pose target data for hardware morphing / pose blending. **/
    public void allocateHardwareAnimationElements(int count) {
        _allocateHardwareAnimationElements__ushortv(this.object.pointer, count);
    }

    private native void _allocateHardwareAnimationElements__ushortv(long _pointer_, int count);

    /** **/
    public org.ogre4j.IVertexDeclaration getvertexDeclaration() {
         return new org.ogre4j.VertexDeclaration(new InstancePointer(_getvertexDeclaration(this.object.pointer)));
    }

    private native long _getvertexDeclaration(long _pointer_);

    /** **/
    public void setvertexDeclaration(org.ogre4j.IVertexDeclaration _jni_value_) {
        _setvertexDeclaration(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setvertexDeclaration(long _pointer_, long _jni_value_);

    /** **/
    public org.ogre4j.IVertexBufferBinding getvertexBufferBinding() {
         return new org.ogre4j.VertexBufferBinding(new InstancePointer(_getvertexBufferBinding(this.object.pointer)));
    }

    private native long _getvertexBufferBinding(long _pointer_);

    /** **/
    public void setvertexBufferBinding(org.ogre4j.IVertexBufferBinding _jni_value_) {
        _setvertexBufferBinding(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setvertexBufferBinding(long _pointer_, long _jni_value_);

    /** **/
    public int getvertexStart() {
         return _getvertexStart(this.object.pointer);
    }

    private native int _getvertexStart(long _pointer_);

    /** **/
    public void setvertexStart(int _jni_value_) {
        _setvertexStart(this.object.pointer, _jni_value_);
    }

    private native void _setvertexStart(long _pointer_, int _jni_value_);

    /** **/
    public int getvertexCount() {
         return _getvertexCount(this.object.pointer);
    }

    private native int _getvertexCount(long _pointer_);

    /** **/
    public void setvertexCount(int _jni_value_) {
        _setvertexCount(this.object.pointer, _jni_value_);
    }

    private native void _setvertexCount(long _pointer_, int _jni_value_);

    /** **/
    public void gethwAnimationDataList(org.ogre4j.IVertexData.IHardwareAnimationDataList returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_gethwAnimationDataList(this.object.pointer)), false);
    }

    private native long _gethwAnimationDataList(long _pointer_);

    /** **/
    public void sethwAnimationDataList(org.ogre4j.IVertexData.IHardwareAnimationDataList _jni_value_) {
        _sethwAnimationDataList(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _sethwAnimationDataList(long _pointer_, long _jni_value_);

    /** **/
    public int gethwAnimDataItemsUsed() {
         return _gethwAnimDataItemsUsed(this.object.pointer);
    }

    private native int _gethwAnimDataItemsUsed(long _pointer_);

    /** **/
    public void sethwAnimDataItemsUsed(int _jni_value_) {
        _sethwAnimDataItemsUsed(this.object.pointer, _jni_value_);
    }

    private native void _sethwAnimDataItemsUsed(long _pointer_, int _jni_value_);

    /** **/
    public void gethardwareShadowVolWBuffer(org.ogre4j.IHardwareVertexBufferSharedPtr returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_gethardwareShadowVolWBuffer(this.object.pointer)), false);
    }

    private native long _gethardwareShadowVolWBuffer(long _pointer_);

    /** **/
    public void sethardwareShadowVolWBuffer(org.ogre4j.IHardwareVertexBufferSharedPtr _jni_value_) {
        _sethardwareShadowVolWBuffer(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _sethardwareShadowVolWBuffer(long _pointer_, long _jni_value_);

}
