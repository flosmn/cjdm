/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class RenderSystem extends org.xbig.base.NativeObject implements org.ogre4j.IRenderSystem {
static { System.loadLibrary("ogre4j");}
public static class Listener extends org.xbig.base.NativeObject implements org.ogre4j.IRenderSystem.IListener {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public Listener(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected Listener(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public Listener(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** 
    A rendersystem-specific event occurred. **/
    public void eventOccurred(String eventName, org.ogre4j.INameValuePairList parameters) {
        _eventOccurred__StringRNameValuePairListP(this.object.pointer, eventName,  parameters.getInstancePointer().pointer);
    }

    private native void _eventOccurred__StringRNameValuePairListP(long _pointer_, String eventName, long parameters);

}
public static class RenderTargetIterator extends org.xbig.base.NativeObject implements org.ogre4j.IRenderSystem.IRenderTargetIterator {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public RenderTargetIterator(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected RenderTargetIterator(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public RenderTargetIterator(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public RenderTargetIterator(org.ogre4j.IRenderTargetMap c) {
         super( new org.xbig.base.InstancePointer(__createRenderTargetIterator__Ogre_RenderTargetMapr( c.getInstancePointer().pointer)), false);
    }

    private native static long __createRenderTargetIterator__Ogre_RenderTargetMapr(long c);

    /** **/
    public boolean hasMoreElements() {
         return _hasMoreElements_const(this.object.pointer);
    }

    private native boolean _hasMoreElements_const(long _pointer_);

    /** **/
    public org.ogre4j.IRenderTarget getNext() {
         return new org.ogre4j.RenderTarget(new InstancePointer(_getNext(this.object.pointer)));
    }

    private native long _getNext(long _pointer_);

    /** **/
    public org.ogre4j.IRenderTarget peekNextValue() {
         return new org.ogre4j.RenderTarget(new InstancePointer(_peekNextValue(this.object.pointer)));
    }

    private native long _peekNextValue(long _pointer_);

    /** **/
    public String peekNextKey() {
         return _peekNextKey(this.object.pointer);
    }

    private native String _peekNextKey(long _pointer_);

    /** **/
    public org.ogre4j.IRenderSystem.IRenderTargetIterator operatorAssignment(org.ogre4j.IRenderSystem.IRenderTargetIterator rhs) {
         return new org.ogre4j.RenderSystem.RenderTargetIterator(new InstancePointer(_operatorAssignment___Ogre_RenderSystem_RenderTargetIteratorr(this.object.pointer, rhs.getInstancePointer().pointer)));
    }

    private native long _operatorAssignment___Ogre_RenderSystem_RenderTargetIteratorr(long _pointer_, long rhs);

    /** **/
    public NativeObjectPointer<org.ogre4j.IRenderTarget> peekNextValuePtr() {
         return new NativeObjectPointer<org.ogre4j.IRenderTarget>(new InstancePointer(_peekNextValuePtr(this.object.pointer)));
    }

    private native long _peekNextValuePtr(long _pointer_);

    /** **/
    public void moveNext() {
        _moveNext(this.object.pointer);
    }

    private native void _moveNext(long _pointer_);

}
protected static class ListenerList extends org.xbig.base.NativeObject implements org.ogre4j.IRenderSystem.IListenerList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public ListenerList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected ListenerList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public ListenerList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public ListenerList() {
         super( new org.xbig.base.InstancePointer(__createListenerList()), false);
    }

    private native static long __createListenerList();

    /** **/
    public void assign(int num, org.ogre4j.IRenderSystem.IListener val) {
        _assign__ivOgre_RenderSystem_ListenerP(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_RenderSystem_ListenerP(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.IRenderSystem.IListener back() {
         return new org.ogre4j.RenderSystem.Listener(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public org.ogre4j.IRenderSystem.IListener front() {
         return new org.ogre4j.RenderSystem.Listener(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void pop_front() {
        _pop_front(this.object.pointer);
    }

    private native void _pop_front(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.IRenderSystem.IListener val) {
        _push_back__Ogre_RenderSystem_ListenerP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_RenderSystem_ListenerP(long _pointer_, long val);

    /** **/
    public void push_front(org.ogre4j.IRenderSystem.IListener val) {
        _push_front__Ogre_RenderSystem_ListenerP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_front__Ogre_RenderSystem_ListenerP(long _pointer_, long val);

    /** **/
    public void remove(org.ogre4j.IRenderSystem.IListener val) {
        _remove__Ogre_RenderSystem_ListenerP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _remove__Ogre_RenderSystem_ListenerP(long _pointer_, long val);

    /** **/
    public void reverse() {
        _reverse(this.object.pointer);
    }

    private native void _reverse(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public void unique() {
        _unique(this.object.pointer);
    }

    private native void _unique(long _pointer_);

}
protected static class HardwareOcclusionQueryList extends org.xbig.base.NativeObject implements org.ogre4j.IRenderSystem.IHardwareOcclusionQueryList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public HardwareOcclusionQueryList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected HardwareOcclusionQueryList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public HardwareOcclusionQueryList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public HardwareOcclusionQueryList() {
         super( new org.xbig.base.InstancePointer(__createHardwareOcclusionQueryList()), false);
    }

    private native static long __createHardwareOcclusionQueryList();

    /** **/
    public void assign(int num, org.ogre4j.IHardwareOcclusionQuery val) {
        _assign__ivOgre_HardwareOcclusionQueryP(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_HardwareOcclusionQueryP(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.IHardwareOcclusionQuery back() {
         return new org.ogre4j.HardwareOcclusionQuery(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public org.ogre4j.IHardwareOcclusionQuery front() {
         return new org.ogre4j.HardwareOcclusionQuery(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void pop_front() {
        _pop_front(this.object.pointer);
    }

    private native void _pop_front(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.IHardwareOcclusionQuery val) {
        _push_back__Ogre_HardwareOcclusionQueryP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_HardwareOcclusionQueryP(long _pointer_, long val);

    /** **/
    public void push_front(org.ogre4j.IHardwareOcclusionQuery val) {
        _push_front__Ogre_HardwareOcclusionQueryP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_front__Ogre_HardwareOcclusionQueryP(long _pointer_, long val);

    /** **/
    public void remove(org.ogre4j.IHardwareOcclusionQuery val) {
        _remove__Ogre_HardwareOcclusionQueryP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _remove__Ogre_HardwareOcclusionQueryP(long _pointer_, long val);

    /** **/
    public void reverse() {
        _reverse(this.object.pointer);
    }

    private native void _reverse(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public void unique() {
        _unique(this.object.pointer);
    }

    private native void _unique(long _pointer_);

}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public RenderSystem(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected RenderSystem(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public RenderSystem(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** 
    Returns the name of the rendering system. **/
    public String getName() {
         return _getName_const(this.object.pointer);
    }

    private native String _getName_const(long _pointer_);

    /** 
    Returns the details of this API's configuration options **/
    public org.ogre4j.IConfigOptionMap getConfigOptions() {
         return new org.ogre4j.ConfigOptionMap(new InstancePointer(_getConfigOptions(this.object.pointer)));
    }

    private native long _getConfigOptions(long _pointer_);

    /** 
    Sets an option for this API **/
    public void setConfigOption(String name, String value) {
        _setConfigOption__StringRStringR(this.object.pointer, name,  value);
    }

    private native void _setConfigOption__StringRStringR(long _pointer_, String name, String value);

    /** 
    Create an object for performing hardware occlusion queries. **/
    public org.ogre4j.IHardwareOcclusionQuery createHardwareOcclusionQuery() {
         return new org.ogre4j.HardwareOcclusionQuery(new InstancePointer(_createHardwareOcclusionQuery(this.object.pointer)));
    }

    private native long _createHardwareOcclusionQuery(long _pointer_);

    /** 
    Destroy a hardware occlusion query object. **/
    public void destroyHardwareOcclusionQuery(org.ogre4j.IHardwareOcclusionQuery hq) {
        _destroyHardwareOcclusionQuery__HardwareOcclusionQueryp(this.object.pointer, hq.getInstancePointer().pointer);
    }

    private native void _destroyHardwareOcclusionQuery__HardwareOcclusionQueryp(long _pointer_, long hq);

    /** 
    Validates the options set for the rendering system, returning a message if there are problems. **/
    public String validateConfigOptions() {
         return _validateConfigOptions(this.object.pointer);
    }

    private native String _validateConfigOptions(long _pointer_);

    /** 
    Start up the renderer using the settings selected (Or the defaults if none have been selected). **/
    public org.ogre4j.IRenderWindow _initialise(boolean autoCreateWindow, String windowTitle) {
         return new org.ogre4j.RenderWindow(new InstancePointer(__initialise__bvStringR(this.object.pointer, autoCreateWindow,  windowTitle)));
    }

    private native long __initialise__bvStringR(long _pointer_, boolean autoCreateWindow, String windowTitle);

    /** 
    Query the real capabilities of the GPU and driver in the **/
    public org.ogre4j.IRenderSystemCapabilities createRenderSystemCapabilities() {
         return new org.ogre4j.RenderSystemCapabilities(new InstancePointer(_createRenderSystemCapabilities_const(this.object.pointer)));
    }

    private native long _createRenderSystemCapabilities_const(long _pointer_);

    /** 
    Force the render system to use the special capabilities. Can only be called before the render system has been fully initializer (before createWindow is called) **/
    public void useCustomRenderSystemCapabilities(org.ogre4j.IRenderSystemCapabilities capabilities) {
        _useCustomRenderSystemCapabilities__RenderSystemCapabilitiesp(this.object.pointer, capabilities.getInstancePointer().pointer);
    }

    private native void _useCustomRenderSystemCapabilities__RenderSystemCapabilitiesp(long _pointer_, long capabilities);

    /** 
    Restart the renderer (normally following a change in settings). **/
    public void reinitialise() {
        _reinitialise(this.object.pointer);
    }

    private native void _reinitialise(long _pointer_);

    /** 
    Shutdown the renderer and cleanup resources. **/
    public void shutdown() {
        _shutdown(this.object.pointer);
    }

    private native void _shutdown(long _pointer_);

    /** 
    Sets the colour & strength of the ambient (global directionless) light in the world. **/
    public void setAmbientLight(float r, float g, float b) {
        _setAmbientLight__FvFvFv(this.object.pointer, r,  g,  b);
    }

    private native void _setAmbientLight__FvFvFv(long _pointer_, float r, float g, float b);

    /** 
    Sets the type of light shading required (default = Gouraud). **/
    public void setShadingType(org.ogre4j.ShadeOptions so) {
        _setShadingType__ShadeOptionsv(this.object.pointer, so.getValue());
    }

    private native void _setShadingType__ShadeOptionsv(long _pointer_, int so);

    /** 
    Sets whether or not dynamic lighting is enabled. **/
    public void setLightingEnabled(boolean enabled) {
        _setLightingEnabled__bv(this.object.pointer, enabled);
    }

    private native void _setLightingEnabled__bv(long _pointer_, boolean enabled);

    /** 
    Sets whether or not W-buffers are enabled if they are available for this renderer. **/
    public void setWBufferEnabled(boolean enabled) {
        _setWBufferEnabled__bv(this.object.pointer, enabled);
    }

    private native void _setWBufferEnabled__bv(long _pointer_, boolean enabled);

    /** 
    Returns true if the renderer will try to use W-buffers when avalible. **/
    public boolean getWBufferEnabled() {
         return _getWBufferEnabled_const(this.object.pointer);
    }

    private native boolean _getWBufferEnabled_const(long _pointer_);

    /** 
    Creates a new rendering window. 
Key: "title" Description: The title of the window that will appear in the title bar Values: string Default:  name
    Key: "colourDepth" Description: Colour depth of the resulting rendering window; only applies if fullScreen is set. Values: 16 or 32 Default: desktop depth Notes: [W32 specific]
    Key: "left" Description: screen x coordinate from left Values: positive integers Default: 'center window on screen' Notes: Ignored in case of full screen
    Key: "top" Description: screen y coordinate from top Values: positive integers Default: 'center window on screen' Notes: Ignored in case of full screen
    Key: "depthBuffer" [DX9 specific] Description: Use depth buffer Values: false or true Default: true
    Key: "externalWindowHandle" [API specific] Description: External window handle, for embedding the OGRE context Values: positive integer for W32 (HWND handle) poslong:posint:poslong (display*:screen:windowHandle) or poslong:posint:poslong:poslong (display*:screen:windowHandle:XVisualInfo*) for GLX Default: 0 (None)
    Key: "externalGLControl" [Win32 OpenGL specific] Description: Let the external window control OpenGL i.e. don't select a pixel format for the window, do not change v-sync and do not swap buffer. When set to true, the calling application is responsible of OpenGL initialization and buffer swapping. It should also create an OpenGL context for its own rendering,  will create one for its use. Then the calling application must also enable  OpenGL context before calling any  function and restore its OpenGL context after these calls. The  OpenGL context can be retrieved after  initialisation by calling wglGetCurrentDC() and wglGetCurrentContext(). It is only used when the externalWindowHandle parameter is used. Values: true, false Default: false
    Key: "externalGLContext" [Win32 OpenGL specific] Description: Use an externally created GL context Values: <Context as="" unsigned="" long>=""> Default: 0 (create own context)
    Key: "parentWindowHandle" [API specific] Description: Parent window handle, for embedding the OGRE context Values: positive integer for W32 (HWND handle) poslong:posint:poslong for GLX (display*:screen:windowHandle) Default: 0 (None)
    Key: "FSAA" Description: Full screen antialiasing factor Values: 0,2,4,6,... Default: 0
    Key: "displayFrequency" Description: Display frequency rate, for fullscreen mode Values: 60...? Default: Desktop vsync rate
    Key: "vsync" Description: Synchronize buffer swaps to vsync Values: true, false Default: 0
    Key: "border" Description: The type of window border (in windowed mode) Values: none, fixed, resize Default: resize
    Key: "outerDimensions" Description: Whether the width/height is expressed as the size of the outer window, rather than the content area Values: true, false Default: false
    Key: "useNVPerfHUD" [DX9 specific] Description: Enable the use of nVidia NVPerfHUD Values: true, false Default: false
    Key: "gamma" Description: Enable hardware conversion from linear colour space to gamma colour space on rendering to the window. Values: true, false Default: false **/
    public org.ogre4j.IRenderWindow _createRenderWindow(String name, long width, long height, boolean fullScreen, org.ogre4j.INameValuePairList miscParams) {
         return new org.ogre4j.RenderWindow(new InstancePointer(__createRenderWindow__StringRIvIvbvNameValuePairListP(this.object.pointer, name,  width,  height,  fullScreen,  miscParams.getInstancePointer().pointer)));
    }

    private native long __createRenderWindow__StringRIvIvbvNameValuePairListP(long _pointer_, String name, long width, long height, boolean fullScreen, long miscParams);

    /** 
    Create a , which is a render target that renders to multiple RenderTextures at once. Surfaces can be bound and unbound at will. This fails if mCapabilities->getNumMultiRenderTargets() is smaller than 2. **/
    public org.ogre4j.IMultiRenderTarget createMultiRenderTarget(String name) {
         return new org.ogre4j.MultiRenderTarget(new InstancePointer(_createMultiRenderTarget__StringR(this.object.pointer, name)));
    }

    private native long _createMultiRenderTarget__StringR(long _pointer_, String name);

    /** 
    Destroys a render window **/
    public void destroyRenderWindow(String name) {
        _destroyRenderWindow__StringR(this.object.pointer, name);
    }

    private native void _destroyRenderWindow__StringR(long _pointer_, String name);

    /** 
    Destroys a render texture **/
    public void destroyRenderTexture(String name) {
        _destroyRenderTexture__StringR(this.object.pointer, name);
    }

    private native void _destroyRenderTexture__StringR(long _pointer_, String name);

    /** 
    Destroys a render target of any sort **/
    public void destroyRenderTarget(String name) {
        _destroyRenderTarget__StringR(this.object.pointer, name);
    }

    private native void _destroyRenderTarget__StringR(long _pointer_, String name);

    /** 
    Attaches the passed render target to the render system. **/
    public void attachRenderTarget(org.ogre4j.IRenderTarget target) {
        _attachRenderTarget__RenderTargetr(this.object.pointer, target.getInstancePointer().pointer);
    }

    private native void _attachRenderTarget__RenderTargetr(long _pointer_, long target);

    /** 
    Returns a pointer to the render target with the passed name, or NULL if that render target cannot be found. **/
    public org.ogre4j.IRenderTarget getRenderTarget(String name) {
         return new org.ogre4j.RenderTarget(new InstancePointer(_getRenderTarget__StringR(this.object.pointer, name)));
    }

    private native long _getRenderTarget__StringR(long _pointer_, String name);

    /** 
    Detaches the render target with the passed name from the render system and returns a pointer to it. **/
    public org.ogre4j.IRenderTarget detachRenderTarget(String name) {
         return new org.ogre4j.RenderTarget(new InstancePointer(_detachRenderTarget__StringR(this.object.pointer, name)));
    }

    private native long _detachRenderTarget__StringR(long _pointer_, String name);

    /** 
    Returns a specialised  over all render targets attached to the . **/
    public void getRenderTargetIterator(org.ogre4j.IRenderSystem.IRenderTargetIterator returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getRenderTargetIterator(this.object.pointer)), false);
    }

    private native long _getRenderTargetIterator(long _pointer_);

    /** 
    Returns a description of an error code. **/
    public String getErrorDescription(long errorNumber) {
         return _getErrorDescription__lv_const(this.object.pointer, errorNumber);
    }

    private native String _getErrorDescription__lv_const(long _pointer_, long errorNumber);

    /** 
    Defines whether or now fullscreen render windows wait for the vertical blank before flipping buffers. **/
    public void setWaitForVerticalBlank(boolean enabled) {
        _setWaitForVerticalBlank__bv(this.object.pointer, enabled);
    }

    private native void _setWaitForVerticalBlank__bv(long _pointer_, boolean enabled);

    /** 
    Returns true if the system is synchronising frames with the monitor vertical blank. **/
    public boolean getWaitForVerticalBlank() {
         return _getWaitForVerticalBlank_const(this.object.pointer);
    }

    private native boolean _getWaitForVerticalBlank_const(long _pointer_);

    /** 
    Tells the rendersystem to use the attached set of lights (and no others) up to the number specified (this allows the same list to be used with different count limits) **/
    public void _useLights(org.ogre4j.ILightList lights, int limit) {
        __useLights__LightListRHv(this.object.pointer, lights.getInstancePointer().pointer,  limit);
    }

    private native void __useLights__LightListRHv(long _pointer_, long lights, int limit);

    /** 
    Sets the world transform matrix. **/
    public void _setWorldMatrix(org.ogre4j.IMatrix4 m) {
        __setWorldMatrix__Matrix4R(this.object.pointer, m.getInstancePointer().pointer);
    }

    private native void __setWorldMatrix__Matrix4R(long _pointer_, long m);

    /** 
    Sets multiple world matrices (vertex blending). **/
    public void _setWorldMatrices(org.ogre4j.IMatrix4 m, int count) {
        __setWorldMatrices__Matrix4PHv(this.object.pointer, m.getInstancePointer().pointer,  count);
    }

    private native void __setWorldMatrices__Matrix4PHv(long _pointer_, long m, int count);

    /** 
    Sets the view transform matrix **/
    public void _setViewMatrix(org.ogre4j.IMatrix4 m) {
        __setViewMatrix__Matrix4R(this.object.pointer, m.getInstancePointer().pointer);
    }

    private native void __setViewMatrix__Matrix4R(long _pointer_, long m);

    /** 
    Sets the projection transform matrix **/
    public void _setProjectionMatrix(org.ogre4j.IMatrix4 m) {
        __setProjectionMatrix__Matrix4R(this.object.pointer, m.getInstancePointer().pointer);
    }

    private native void __setProjectionMatrix__Matrix4R(long _pointer_, long m);

    /** 
    Utility function for setting all the properties of a texture unit at once. This method is also worth using over the individual texture unit settings because it only sets those settings which are different from the current settings for this unit, thus minimising render state changes. **/
    public void _setTextureUnitSettings(int texUnit, org.ogre4j.ITextureUnitState tl) {
        __setTextureUnitSettings__ivTextureUnitStater(this.object.pointer, texUnit,  tl.getInstancePointer().pointer);
    }

    private native void __setTextureUnitSettings__ivTextureUnitStater(long _pointer_, int texUnit, long tl);

    /** 
    Turns off a texture unit. **/
    public void _disableTextureUnit(int texUnit) {
        __disableTextureUnit__iv(this.object.pointer, texUnit);
    }

    private native void __disableTextureUnit__iv(long _pointer_, int texUnit);

    /** 
    Disables all texture units from the given unit upwards **/
    public void _disableTextureUnitsFrom(int texUnit) {
        __disableTextureUnitsFrom__iv(this.object.pointer, texUnit);
    }

    private native void __disableTextureUnitsFrom__iv(long _pointer_, int texUnit);

    /** 
    Sets the surface properties to be used for future rendering.
    This method sets the the properties of the surfaces of objects to be rendered after it. In this context these surface properties are the amount of each type of light the object reflects (determining it's colour under different types of light), whether it emits light itself, and how shiny it is. Textures are not dealt with here, see the _setTetxure method for details. This method is used by _setMaterial so does not need to be called direct if that method is being used.
    **/
    public void _setSurfaceParams(org.ogre4j.IColourValue ambient, org.ogre4j.IColourValue diffuse, org.ogre4j.IColourValue specular, org.ogre4j.IColourValue emissive, float shininess, int tracking) {
        __setSurfaceParams__ColourValueRColourValueRColourValueRColourValueRRealvTrackVertexColourTypev(this.object.pointer, ambient.getInstancePointer().pointer,  diffuse.getInstancePointer().pointer,  specular.getInstancePointer().pointer,  emissive.getInstancePointer().pointer,  shininess,  tracking);
    }

    private native void __setSurfaceParams__ColourValueRColourValueRColourValueRColourValueRRealvTrackVertexColourTypev(long _pointer_, long ambient, long diffuse, long specular, long emissive, float shininess, int tracking);

    /** 
    Sets whether or not rendering points using OT_POINT_LIST will render point sprites (textured quads) or plain points. **/
    public void _setPointSpritesEnabled(boolean enabled) {
        __setPointSpritesEnabled__bv(this.object.pointer, enabled);
    }

    private native void __setPointSpritesEnabled__bv(long _pointer_, boolean enabled);

    /** 
    Sets the size of points and how they are attenuated with distance. **/
    public void _setPointParameters(float size, boolean attenuationEnabled, float constant, float linear, float quadratic, float minSize, float maxSize) {
        __setPointParameters__RealvbvRealvRealvRealvRealvRealv(this.object.pointer, size,  attenuationEnabled,  constant,  linear,  quadratic,  minSize,  maxSize);
    }

    private native void __setPointParameters__RealvbvRealvRealvRealvRealvRealv(long _pointer_, float size, boolean attenuationEnabled, float constant, float linear, float quadratic, float minSize, float maxSize);

    /** 
    Sets the texture to bind to a given texture unit.
    User processes would not normally call this direct unless rendering primitives themselves.
    **/
    public void _setTexture(int unit, boolean enabled, org.ogre4j.ITexturePtr texPtr) {
        __setTexture__ivbvTexturePtrR(this.object.pointer, unit,  enabled,  texPtr.getInstancePointer().pointer);
    }

    private native void __setTexture__ivbvTexturePtrR(long _pointer_, int unit, boolean enabled, long texPtr);

    /** 
    Sets the texture to bind to a given texture unit.
    User processes would not normally call this direct unless rendering primitives themselves.
    **/
    public void _setTexture(int unit, boolean enabled, String texname) {
        __setTexture__ivbvStringR(this.object.pointer, unit,  enabled,  texname);
    }

    private native void __setTexture__ivbvStringR(long _pointer_, int unit, boolean enabled, String texname);

    /** 
    Binds a texture to a vertex sampler. **/
    public void _setVertexTexture(int unit, org.ogre4j.ITexturePtr tex) {
        __setVertexTexture__ivTexturePtrR(this.object.pointer, unit,  tex.getInstancePointer().pointer);
    }

    private native void __setVertexTexture__ivTexturePtrR(long _pointer_, int unit, long tex);

    /** 
    Sets the texture coordinate set to use for a texture unit.
    Meant for use internally - not generally used directly by apps - the  and  classes let you manage textures far more easily.
    **/
    public void _setTextureCoordSet(int unit, int index) {
        __setTextureCoordSet__iviv(this.object.pointer, unit,  index);
    }

    private native void __setTextureCoordSet__iviv(long _pointer_, int unit, int index);

    /** 
    Sets a method for automatically calculating texture coordinates for a stage. Should not be used by apps - for use by  only. **/
    public void _setTextureCoordCalculation(int unit, org.ogre4j.TexCoordCalcMethod m, org.ogre4j.IFrustum frustum) {
        __setTextureCoordCalculation__ivTexCoordCalcMethodvFrustumP(this.object.pointer, unit,  m.getValue(),  frustum.getInstancePointer().pointer);
    }

    private native void __setTextureCoordCalculation__ivTexCoordCalcMethodvFrustumP(long _pointer_, int unit, int m, long frustum);

    /** 
    Sets the texture blend modes from a  record. Meant for use internally only - apps should use the  and  classes. **/
    public void _setTextureBlendMode(int unit, org.ogre4j.ILayerBlendModeEx bm) {
        __setTextureBlendMode__ivLayerBlendModeExR(this.object.pointer, unit,  bm.getInstancePointer().pointer);
    }

    private native void __setTextureBlendMode__ivLayerBlendModeExR(long _pointer_, int unit, long bm);

    /** 
    Sets the filtering options for a given texture unit. **/
    public void _setTextureUnitFiltering(int unit, org.ogre4j.FilterOptions minFilter, org.ogre4j.FilterOptions magFilter, org.ogre4j.FilterOptions mipFilter) {
        __setTextureUnitFiltering__ivFilterOptionsvFilterOptionsvFilterOptionsv(this.object.pointer, unit,  minFilter.getValue(),  magFilter.getValue(),  mipFilter.getValue());
    }

    private native void __setTextureUnitFiltering__ivFilterOptionsvFilterOptionsvFilterOptionsv(long _pointer_, int unit, int minFilter, int magFilter, int mipFilter);

    /** 
    Sets a single filter for a given texture unit. **/
    public void _setTextureUnitFiltering(int unit, org.ogre4j.FilterType ftype, org.ogre4j.FilterOptions filter) {
        __setTextureUnitFiltering__ivFilterTypevFilterOptionsv(this.object.pointer, unit,  ftype.getValue(),  filter.getValue());
    }

    private native void __setTextureUnitFiltering__ivFilterTypevFilterOptionsv(long _pointer_, int unit, int ftype, int filter);

    /** 
    Sets the maximal anisotropy for the specified texture unit. **/
    public void _setTextureLayerAnisotropy(int unit, long maxAnisotropy) {
        __setTextureLayerAnisotropy__ivIv(this.object.pointer, unit,  maxAnisotropy);
    }

    private native void __setTextureLayerAnisotropy__ivIv(long _pointer_, int unit, long maxAnisotropy);

    /** 
    Sets the texture addressing mode for a texture unit. **/
    public void _setTextureAddressingMode(int unit, org.ogre4j.ITextureUnitState.IUVWAddressingMode uvw) {
        __setTextureAddressingMode__ivTextureUnitState_UVWAddressingModeR(this.object.pointer, unit,  uvw.getInstancePointer().pointer);
    }

    private native void __setTextureAddressingMode__ivTextureUnitState_UVWAddressingModeR(long _pointer_, int unit, long uvw);

    /** 
    Sets the texture border colour for a texture unit. **/
    public void _setTextureBorderColour(int unit, org.ogre4j.IColourValue colour) {
        __setTextureBorderColour__ivColourValueR(this.object.pointer, unit,  colour.getInstancePointer().pointer);
    }

    private native void __setTextureBorderColour__ivColourValueR(long _pointer_, int unit, long colour);

    /** 
    Sets the mipmap bias value for a given texture unit. **/
    public void _setTextureMipmapBias(int unit, float bias) {
        __setTextureMipmapBias__ivFv(this.object.pointer, unit,  bias);
    }

    private native void __setTextureMipmapBias__ivFv(long _pointer_, int unit, float bias);

    /** 
    Sets the texture coordinate transformation matrix for a texture unit. **/
    public void _setTextureMatrix(int unit, org.ogre4j.IMatrix4 xform) {
        __setTextureMatrix__ivMatrix4R(this.object.pointer, unit,  xform.getInstancePointer().pointer);
    }

    private native void __setTextureMatrix__ivMatrix4R(long _pointer_, int unit, long xform);

    /** 
    Sets the global blending factors for combining subsequent renders with the existing frame contents. The result of the blending operation is: 
    final = (texture * sourceFactor) + (pixel * destFactor) Each of the factors is specified as one of a number of options, as specified in the SceneBlendFactor enumerated type. **/
    public void _setSceneBlending(org.ogre4j.SceneBlendFactor sourceFactor, org.ogre4j.SceneBlendFactor destFactor) {
        __setSceneBlending__SceneBlendFactorvSceneBlendFactorv(this.object.pointer, sourceFactor.getValue(),  destFactor.getValue());
    }

    private native void __setSceneBlending__SceneBlendFactorvSceneBlendFactorv(long _pointer_, int sourceFactor, int destFactor);

    /** 
    Sets the global blending factors for combining subsequent renders with the existing frame contents. The result of the blending operation is: 
    final = (texture * sourceFactor) + (pixel * destFactor) Each of the factors is specified as one of a number of options, as specified in the SceneBlendFactor enumerated type. **/
    public void _setSeparateSceneBlending(org.ogre4j.SceneBlendFactor sourceFactor, org.ogre4j.SceneBlendFactor destFactor, org.ogre4j.SceneBlendFactor sourceFactorAlpha, org.ogre4j.SceneBlendFactor destFactorAlpha) {
        __setSeparateSceneBlending__SceneBlendFactorvSceneBlendFactorvSceneBlendFactorvSceneBlendFactorv(this.object.pointer, sourceFactor.getValue(),  destFactor.getValue(),  sourceFactorAlpha.getValue(),  destFactorAlpha.getValue());
    }

    private native void __setSeparateSceneBlending__SceneBlendFactorvSceneBlendFactorvSceneBlendFactorvSceneBlendFactorv(long _pointer_, int sourceFactor, int destFactor, int sourceFactorAlpha, int destFactorAlpha);

    /** 
    Sets the global alpha rejection approach for future renders. By default images are rendered regardless of texture alpha. This method lets you change that. **/
    public void _setAlphaRejectSettings(org.ogre4j.CompareFunction func, short value, boolean alphaToCoverage) {
        __setAlphaRejectSettings__CompareFunctionvBvbv(this.object.pointer, func.getValue(),  value,  alphaToCoverage);
    }

    private native void __setAlphaRejectSettings__CompareFunctionvBvbv(long _pointer_, int func, short value, boolean alphaToCoverage);

    /** 
    Notify the rendersystem that it should adjust texture projection to be relative to a different origin. **/
    public void _setTextureProjectionRelativeTo(boolean enabled, org.ogre4j.IVector3 pos) {
        __setTextureProjectionRelativeTo__bvVector3R(this.object.pointer, enabled,  pos.getInstancePointer().pointer);
    }

    private native void __setTextureProjectionRelativeTo__bvVector3R(long _pointer_, boolean enabled, long pos);

    /** 
    Signifies the beginning of a frame, i.e. the start of rendering on a single viewport. Will occur several times per complete frame if multiple viewports exist. **/
    public void _beginFrame() {
        __beginFrame(this.object.pointer);
    }

    private native void __beginFrame(long _pointer_);

    /** 
    Ends rendering of a frame to the current viewport. **/
    public void _endFrame() {
        __endFrame(this.object.pointer);
    }

    private native void __endFrame(long _pointer_);

    /** 
    Sets the provided viewport as the active one for future rendering operations. This viewport is aware of it's own camera and render target. Must be implemented by subclass.
    **/
    public void _setViewport(org.ogre4j.IViewport vp) {
        __setViewport__Viewportp(this.object.pointer, vp.getInstancePointer().pointer);
    }

    private native void __setViewport__Viewportp(long _pointer_, long vp);

    /** 
    Get the current active viewport for rendering. **/
    public org.ogre4j.IViewport _getViewport() {
         return new org.ogre4j.Viewport(new InstancePointer(__getViewport(this.object.pointer)));
    }

    private native long __getViewport(long _pointer_);

    /** 
    Sets the culling mode for the render system based on the 'vertex winding'. A typical way for the rendering engine to cull triangles is based on the 'vertex winding' of triangles. Vertex winding refers to the direction in which the vertices are passed or indexed to in the rendering operation as viewed from the camera, and will wither be clockwise or anticlockwise (that's 'counterclockwise' for you Americans out there ;) The default is CULL_CLOCKWISE i.e. that only triangles whose vertices are passed/indexed in anticlockwise order are rendered - this is a common approach and is used in 3D studio models for example. You can alter this culling mode if you wish but it is not advised unless you know what you are doing. You may wish to use the CULL_NONE option for mesh data that you cull yourself where the vertex winding is uncertain. **/
    public void _setCullingMode(org.ogre4j.CullingMode mode) {
        __setCullingMode__CullingModev(this.object.pointer, mode.getValue());
    }

    private native void __setCullingMode__CullingModev(long _pointer_, int mode);

    /** **/
    public org.ogre4j.CullingMode _getCullingMode() {
         return org.ogre4j.CullingMode.toEnum(__getCullingMode_const(this.object.pointer));
    }

    private native int __getCullingMode_const(long _pointer_);

    /** 
    Sets the mode of operation for depth buffer tests from this point onwards. Sometimes you may wish to alter the behaviour of the depth buffer to achieve special effects. Because it's unlikely that you'll set these options for an entire frame, but rather use them to tweak settings between rendering objects, this is an internal method (indicated by the '_' prefix) which will be used by a  implementation rather than directly from the client application. If this method is never called the settings are automatically the same as the default parameters. **/
    public void _setDepthBufferParams(boolean depthTest, boolean depthWrite, org.ogre4j.CompareFunction depthFunction) {
        __setDepthBufferParams__bvbvCompareFunctionv(this.object.pointer, depthTest,  depthWrite,  depthFunction.getValue());
    }

    private native void __setDepthBufferParams__bvbvCompareFunctionv(long _pointer_, boolean depthTest, boolean depthWrite, int depthFunction);

    /** 
    Sets whether or not the depth buffer check is performed before a pixel write. **/
    public void _setDepthBufferCheckEnabled(boolean enabled) {
        __setDepthBufferCheckEnabled__bv(this.object.pointer, enabled);
    }

    private native void __setDepthBufferCheckEnabled__bv(long _pointer_, boolean enabled);

    /** 
    Sets whether or not the depth buffer is updated after a pixel write. **/
    public void _setDepthBufferWriteEnabled(boolean enabled) {
        __setDepthBufferWriteEnabled__bv(this.object.pointer, enabled);
    }

    private native void __setDepthBufferWriteEnabled__bv(long _pointer_, boolean enabled);

    /** 
    Sets the comparison function for the depth buffer check. Advanced use only - allows you to choose the function applied to compare the depth values of new and existing pixels in the depth buffer. Only an issue if the deoth buffer check is enabled (see _setDepthBufferCheckEnabled) **/
    public void _setDepthBufferFunction(org.ogre4j.CompareFunction func) {
        __setDepthBufferFunction__CompareFunctionv(this.object.pointer, func.getValue());
    }

    private native void __setDepthBufferFunction__CompareFunctionv(long _pointer_, int func);

    /** 
    Sets whether or not colour buffer writing is enabled, and for which channels. **/
    public void _setColourBufferWriteEnabled(boolean red, boolean green, boolean blue, boolean alpha) {
        __setColourBufferWriteEnabled__bvbvbvbv(this.object.pointer, red,  green,  blue,  alpha);
    }

    private native void __setColourBufferWriteEnabled__bvbvbvbv(long _pointer_, boolean red, boolean green, boolean blue, boolean alpha);

    /** 
    Sets the depth bias, NB you should use the  version of this. **/
    public void _setDepthBias(float constantBias, float slopeScaleBias) {
        __setDepthBias__FvFv(this.object.pointer, constantBias,  slopeScaleBias);
    }

    private native void __setDepthBias__FvFv(long _pointer_, float constantBias, float slopeScaleBias);

    /** 
    Sets the fogging mode for future geometry. **/
    public void _setFog(org.ogre4j.FogMode mode, org.ogre4j.IColourValue colour, float expDensity, float linearStart, float linearEnd) {
        __setFog__FogModevColourValueRRealvRealvRealv(this.object.pointer, mode.getValue(),  colour.getInstancePointer().pointer,  expDensity,  linearStart,  linearEnd);
    }

    private native void __setFog__FogModevColourValueRRealvRealvRealv(long _pointer_, int mode, long colour, float expDensity, float linearStart, float linearEnd);

    /** 
    The  will keep a count of tris rendered, this resets the count. **/
    public void _beginGeometryCount() {
        __beginGeometryCount(this.object.pointer);
    }

    private native void __beginGeometryCount(long _pointer_);

    /** 
    Reports the number of tris rendered since the last _beginGeometryCount call. **/
    public long _getFaceCount() {
         return __getFaceCount_const(this.object.pointer);
    }

    private native long __getFaceCount_const(long _pointer_);

    /** 
    Reports the number of batches rendered since the last _beginGeometryCount call. **/
    public long _getBatchCount() {
         return __getBatchCount_const(this.object.pointer);
    }

    private native long __getBatchCount_const(long _pointer_);

    /** 
    Reports the number of vertices passed to the renderer since the last _beginGeometryCount call. **/
    public long _getVertexCount() {
         return __getVertexCount_const(this.object.pointer);
    }

    private native long __getVertexCount_const(long _pointer_);

    /** 
    Generates a packed data version of the passed in  suitable for use as with this . **/
    public void convertColourValue(org.ogre4j.IColourValue colour, LongPointer pDest) {
        _convertColourValue__ColourValueRuint32p(this.object.pointer, colour.getInstancePointer().pointer,  pDest.object.pointer);
    }

    private native void _convertColourValue__ColourValueRuint32p(long _pointer_, long colour, long pDest);

    /** 
    Get the native VertexElementType for a compact 32-bit colour value for this rendersystem. **/
    public org.ogre4j.VertexElementType getColourVertexElementType() {
         return org.ogre4j.VertexElementType.toEnum(_getColourVertexElementType_const(this.object.pointer));
    }

    private native int _getColourVertexElementType_const(long _pointer_);

    /** 
    Converts a uniform projection matrix to suitable for this render system. **/
    public void _convertProjectionMatrix(org.ogre4j.IMatrix4 matrix, org.ogre4j.IMatrix4 dest, boolean forGpuProgram) {
        __convertProjectionMatrix__Matrix4RMatrix4rbv(this.object.pointer, matrix.getInstancePointer().pointer,  dest.getInstancePointer().pointer,  forGpuProgram);
    }

    private native void __convertProjectionMatrix__Matrix4RMatrix4rbv(long _pointer_, long matrix, long dest, boolean forGpuProgram);

    /** 
    Builds a perspective projection matrix suitable for this render system. **/
    public void _makeProjectionMatrix(org.ogre4j.IRadian fovy, float aspect, float nearPlane, float farPlane, org.ogre4j.IMatrix4 dest, boolean forGpuProgram) {
        __makeProjectionMatrix__RadianRRealvRealvRealvMatrix4rbv(this.object.pointer, fovy.getInstancePointer().pointer,  aspect,  nearPlane,  farPlane,  dest.getInstancePointer().pointer,  forGpuProgram);
    }

    private native void __makeProjectionMatrix__RadianRRealvRealvRealvMatrix4rbv(long _pointer_, long fovy, float aspect, float nearPlane, float farPlane, long dest, boolean forGpuProgram);

    /** 
    Builds a perspective projection matrix for the case when frustum is not centered around camera. **/
    public void _makeProjectionMatrix(float left, float right, float bottom, float top, float nearPlane, float farPlane, org.ogre4j.IMatrix4 dest, boolean forGpuProgram) {
        __makeProjectionMatrix__RealvRealvRealvRealvRealvRealvMatrix4rbv(this.object.pointer, left,  right,  bottom,  top,  nearPlane,  farPlane,  dest.getInstancePointer().pointer,  forGpuProgram);
    }

    private native void __makeProjectionMatrix__RealvRealvRealvRealvRealvRealvMatrix4rbv(long _pointer_, float left, float right, float bottom, float top, float nearPlane, float farPlane, long dest, boolean forGpuProgram);

    /** 
    Builds an orthographic projection matrix suitable for this render system. **/
    public void _makeOrthoMatrix(org.ogre4j.IRadian fovy, float aspect, float nearPlane, float farPlane, org.ogre4j.IMatrix4 dest, boolean forGpuProgram) {
        __makeOrthoMatrix__RadianRRealvRealvRealvMatrix4rbv(this.object.pointer, fovy.getInstancePointer().pointer,  aspect,  nearPlane,  farPlane,  dest.getInstancePointer().pointer,  forGpuProgram);
    }

    private native void __makeOrthoMatrix__RadianRRealvRealvRealvMatrix4rbv(long _pointer_, long fovy, float aspect, float nearPlane, float farPlane, long dest, boolean forGpuProgram);

    /** 
    Update a perspective projection matrix to use 'oblique depth projection'. **/
    public void _applyObliqueDepthProjection(org.ogre4j.IMatrix4 matrix, org.ogre4j.IPlane plane, boolean forGpuProgram) {
        __applyObliqueDepthProjection__Matrix4rPlaneRbv(this.object.pointer, matrix.getInstancePointer().pointer,  plane.getInstancePointer().pointer,  forGpuProgram);
    }

    private native void __applyObliqueDepthProjection__Matrix4rPlaneRbv(long _pointer_, long matrix, long plane, boolean forGpuProgram);

    /** 
    Sets how to rasterise triangles, as points, wireframe or solid polys. **/
    public void _setPolygonMode(org.ogre4j.PolygonMode level) {
        __setPolygonMode__PolygonModev(this.object.pointer, level.getValue());
    }

    private native void __setPolygonMode__PolygonModev(long _pointer_, int level);

    /** 
    Turns stencil buffer checking on or off. **/
    public void setStencilCheckEnabled(boolean enabled) {
        _setStencilCheckEnabled__bv(this.object.pointer, enabled);
    }

    private native void _setStencilCheckEnabled__bv(long _pointer_, boolean enabled);

    /** 
    This method allows you to set all the stencil buffer parameters in one call. **/
    public void setStencilBufferParams(org.ogre4j.CompareFunction func, long refValue, long mask, org.ogre4j.StencilOperation stencilFailOp, org.ogre4j.StencilOperation depthFailOp, org.ogre4j.StencilOperation passOp, boolean twoSidedOperation) {
        _setStencilBufferParams__CompareFunctionvuint32vuint32vStencilOperationvStencilOperationvStencilOperationvbv(this.object.pointer, func.getValue(),  refValue,  mask,  stencilFailOp.getValue(),  depthFailOp.getValue(),  passOp.getValue(),  twoSidedOperation);
    }

    private native void _setStencilBufferParams__CompareFunctionvuint32vuint32vStencilOperationvStencilOperationvStencilOperationvbv(long _pointer_, int func, long refValue, long mask, int stencilFailOp, int depthFailOp, int passOp, boolean twoSidedOperation);

    /** 
    Sets the current vertex declaration, ie the source of vertex data. **/
    public void setVertexDeclaration(org.ogre4j.IVertexDeclaration decl) {
        _setVertexDeclaration__VertexDeclarationp(this.object.pointer, decl.getInstancePointer().pointer);
    }

    private native void _setVertexDeclaration__VertexDeclarationp(long _pointer_, long decl);

    /** 
    Sets the current vertex buffer binding state. **/
    public void setVertexBufferBinding(org.ogre4j.IVertexBufferBinding binding) {
        _setVertexBufferBinding__VertexBufferBindingp(this.object.pointer, binding.getInstancePointer().pointer);
    }

    private native void _setVertexBufferBinding__VertexBufferBindingp(long _pointer_, long binding);

    /** 
    Sets whether or not normals are to be automatically normalised. **/
    public void setNormaliseNormals(boolean normalise) {
        _setNormaliseNormals__bv(this.object.pointer, normalise);
    }

    private native void _setNormaliseNormals__bv(long _pointer_, boolean normalise);

    /** 
    Render something to the active viewport.
    Low-level rendering interface to perform rendering operations. Unlikely to be used directly by client applications, since the  and various support classes will be responsible for calling this method. Can only be called between _beginScene and _endScene
    **/
    public void _render(org.ogre4j.IRenderOperation op) {
        __render__RenderOperationR(this.object.pointer, op.getInstancePointer().pointer);
    }

    private native void __render__RenderOperationR(long _pointer_, long op);

    /** 
    Gets the capabilities of the render system. **/
    public org.ogre4j.IRenderSystemCapabilities getCapabilities() {
         return new org.ogre4j.RenderSystemCapabilities(new InstancePointer(_getCapabilities_const(this.object.pointer)));
    }

    private native long _getCapabilities_const(long _pointer_);

    /** 
    Returns the driver version. **/
    public org.ogre4j.IDriverVersion getDriverVersion() {
         return new org.ogre4j.DriverVersion(new InstancePointer(_getDriverVersion_const(this.object.pointer)));
    }

    private native long _getDriverVersion_const(long _pointer_);

    /** 
    Binds a given  (but not the parameters). **/
    public void bindGpuProgram(org.ogre4j.IGpuProgram prg) {
        _bindGpuProgram__GpuProgramp(this.object.pointer, prg.getInstancePointer().pointer);
    }

    private native void _bindGpuProgram__GpuProgramp(long _pointer_, long prg);

    /** 
    Bind Gpu program parameters. **/
    public void bindGpuProgramParameters(org.ogre4j.GpuProgramType gptype, org.ogre4j.IGpuProgramParametersSharedPtr params) {
        _bindGpuProgramParameters__GpuProgramTypevGpuProgramParametersSharedPtrv(this.object.pointer, gptype.getValue(),  params.getInstancePointer().pointer);
    }

    private native void _bindGpuProgramParameters__GpuProgramTypevGpuProgramParametersSharedPtrv(long _pointer_, int gptype, long params);

    /** 
    Only binds Gpu program parameters used for passes that have more than one iteration rendering **/
    public void bindGpuProgramPassIterationParameters(org.ogre4j.GpuProgramType gptype) {
        _bindGpuProgramPassIterationParameters__GpuProgramTypev(this.object.pointer, gptype.getValue());
    }

    private native void _bindGpuProgramPassIterationParameters__GpuProgramTypev(long _pointer_, int gptype);

    /** 
    Unbinds GpuPrograms of a given GpuProgramType. **/
    public void unbindGpuProgram(org.ogre4j.GpuProgramType gptype) {
        _unbindGpuProgram__GpuProgramTypev(this.object.pointer, gptype.getValue());
    }

    private native void _unbindGpuProgram__GpuProgramTypev(long _pointer_, int gptype);

    /** 
    Returns whether or not a Gpu program of the given type is currently bound. **/
    public boolean isGpuProgramBound(org.ogre4j.GpuProgramType gptype) {
         return _isGpuProgramBound__GpuProgramTypev(this.object.pointer, gptype.getValue());
    }

    private native boolean _isGpuProgramBound__GpuProgramTypev(long _pointer_, int gptype);

    /** 
    Sets the user clipping region. **/
    public void setClipPlanes(org.ogre4j.IPlaneList clipPlanes) {
        _setClipPlanes__PlaneListR(this.object.pointer, clipPlanes.getInstancePointer().pointer);
    }

    private native void _setClipPlanes__PlaneListR(long _pointer_, long clipPlanes);

    /** 
    Add a user clipping plane. **/
    public void addClipPlane(org.ogre4j.IPlane p) {
        _addClipPlane__PlaneR(this.object.pointer, p.getInstancePointer().pointer);
    }

    private native void _addClipPlane__PlaneR(long _pointer_, long p);

    /** 
    Add a user clipping plane. **/
    public void addClipPlane(float A, float B, float C, float D) {
        _addClipPlane__RealvRealvRealvRealv(this.object.pointer, A,  B,  C,  D);
    }

    private native void _addClipPlane__RealvRealvRealvRealv(long _pointer_, float A, float B, float C, float D);

    /** 
    Clears the user clipping region. **/
    public void resetClipPlanes() {
        _resetClipPlanes(this.object.pointer);
    }

    private native void _resetClipPlanes(long _pointer_);

    /** 
    Utility method for initialising all render targets attached to this rendering system. **/
    public void _initRenderTargets() {
        __initRenderTargets(this.object.pointer);
    }

    private native void __initRenderTargets(long _pointer_);

    /** 
    Utility method to notify all render targets that a camera has been removed, in case they were referring to it as their viewer. **/
    public void _notifyCameraRemoved(org.ogre4j.ICamera cam) {
        __notifyCameraRemoved__CameraP(this.object.pointer, cam.getInstancePointer().pointer);
    }

    private native void __notifyCameraRemoved__CameraP(long _pointer_, long cam);

    /** 
    Internal method for updating all render targets attached to this rendering system. **/
    public void _updateAllRenderTargets(boolean swapBuffers) {
        __updateAllRenderTargets__bv(this.object.pointer, swapBuffers);
    }

    private native void __updateAllRenderTargets__bv(long _pointer_, boolean swapBuffers);

    /** 
    Internal method for swapping all the buffers on all render targets, if _updateAllRenderTargets was called with a 'false' parameter. **/
    public void _swapAllRenderTargetBuffers(boolean waitForVsync) {
        __swapAllRenderTargetBuffers__bv(this.object.pointer, waitForVsync);
    }

    private native void __swapAllRenderTargetBuffers__bv(long _pointer_, boolean waitForVsync);

    /** 
    Sets whether or not vertex windings set should be inverted; this can be important for rendering reflections. **/
    public void setInvertVertexWinding(boolean invert) {
        _setInvertVertexWinding__bv(this.object.pointer, invert);
    }

    private native void _setInvertVertexWinding__bv(long _pointer_, boolean invert);

    /** 
    Sets the 'scissor region' ie the region of the target in which rendering can take place. **/
    public void setScissorTest(boolean enabled, int left, int top, int right, int bottom) {
        _setScissorTest__bviviviviv(this.object.pointer, enabled,  left,  top,  right,  bottom);
    }

    private native void _setScissorTest__bviviviviv(long _pointer_, boolean enabled, int left, int top, int right, int bottom);

    /** 
    Clears one or more frame buffers on the active render target. **/
    public void clearFrameBuffer(long buffers, org.ogre4j.IColourValue colour, float depth, int stencil) {
        _clearFrameBuffer__IvColourValueRRealvHv(this.object.pointer, buffers,  colour.getInstancePointer().pointer,  depth,  stencil);
    }

    private native void _clearFrameBuffer__IvColourValueRRealvHv(long _pointer_, long buffers, long colour, float depth, int stencil);

    /** 
    Returns the horizontal texel offset value required for mapping texel origins to pixel origins in this rendersystem. **/
    public float getHorizontalTexelOffset() {
         return _getHorizontalTexelOffset(this.object.pointer);
    }

    private native float _getHorizontalTexelOffset(long _pointer_);

    /** 
    Returns the vertical texel offset value required for mapping texel origins to pixel origins in this rendersystem. **/
    public float getVerticalTexelOffset() {
         return _getVerticalTexelOffset(this.object.pointer);
    }

    private native float _getVerticalTexelOffset(long _pointer_);

    /** 
    Gets the minimum (closest) depth value to be used when rendering using identity transforms. **/
    public float getMinimumDepthInputValue() {
         return _getMinimumDepthInputValue(this.object.pointer);
    }

    private native float _getMinimumDepthInputValue(long _pointer_);

    /** 
    Gets the maximum (farthest) depth value to be used when rendering using identity transforms. **/
    public float getMaximumDepthInputValue() {
         return _getMaximumDepthInputValue(this.object.pointer);
    }

    private native float _getMaximumDepthInputValue(long _pointer_);

    /** 
    set the current multi pass count value. This must be set prior to calling  if multiple renderings of the same pass state are required. **/
    public void setCurrentPassIterationCount(int count) {
        _setCurrentPassIterationCount__iV(this.object.pointer, count);
    }

    private native void _setCurrentPassIterationCount__iV(long _pointer_, int count);

    /** 
    Tell the render system whether to derive a depth bias on its own based on the values passed to it in setCurrentPassIterationCount. The depth bias set will be baseValue + iteration * multiplier **/
    public void setDeriveDepthBias(boolean derive, float baseValue, float multiplier, float slopeScale) {
        _setDeriveDepthBias__bvFvFvFv(this.object.pointer, derive,  baseValue,  multiplier,  slopeScale);
    }

    private native void _setDeriveDepthBias__bvFvFvFv(long _pointer_, boolean derive, float baseValue, float multiplier, float slopeScale);

    /** 
    Adds a listener to the custom events that this render system can raise. **/
    public void addListener(org.ogre4j.IRenderSystem.IListener l) {
        _addListener__Listenerp(this.object.pointer, l.getInstancePointer().pointer);
    }

    private native void _addListener__Listenerp(long _pointer_, long l);

    /** 
    Remove a listener to the custom events that this render system can raise. **/
    public void removeListener(org.ogre4j.IRenderSystem.IListener l) {
        _removeListener__Listenerp(this.object.pointer, l.getInstancePointer().pointer);
    }

    private native void _removeListener__Listenerp(long _pointer_, long l);

    /** 
    Gets a list of the rendersystem specific events that this rendersystem can raise. **/
    public org.ogre4j.IStringVector getRenderSystemEvents() {
         return new org.ogre4j.StringVector(new InstancePointer(_getRenderSystemEvents_const(this.object.pointer)));
    }

    private native long _getRenderSystemEvents_const(long _pointer_);

    /** 
    Tell the rendersystem to perform any prep tasks it needs to directly before other threads which might access the rendering API are registered. **/
    public void preExtraThreadsStarted() {
        _preExtraThreadsStarted(this.object.pointer);
    }

    private native void _preExtraThreadsStarted(long _pointer_);

    /** **/
    public void postExtraThreadsStarted() {
        _postExtraThreadsStarted(this.object.pointer);
    }

    private native void _postExtraThreadsStarted(long _pointer_);

    /** 
    Register the an additional thread which may make calls to rendersystem-related objects. **/
    public void registerThread() {
        _registerThread(this.object.pointer);
    }

    private native void _registerThread(long _pointer_);

    /** 
    Unregister an additional thread which may make calls to rendersystem-related objects. **/
    public void unregisterThread() {
        _unregisterThread(this.object.pointer);
    }

    private native void _unregisterThread(long _pointer_);

}
