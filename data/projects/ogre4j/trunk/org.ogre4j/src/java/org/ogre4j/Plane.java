/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class Plane extends org.xbig.base.NativeObject implements org.ogre4j.IPlane {
static { System.loadLibrary("ogre4j");}
public enum Side implements INativeEnum < Side > {
    NO_SIDE(SideHelper.ENUM_VALUES[0]),
    POSITIVE_SIDE(SideHelper.ENUM_VALUES[1]),
    NEGATIVE_SIDE(SideHelper.ENUM_VALUES[2]),
    BOTH_SIDE(SideHelper.ENUM_VALUES[3]);

    private int value;

    Side(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public Side getEnum(int val) {
        return toEnum(val);
    }

    public static final Side toEnum(int retval) {
    if (retval ==NO_SIDE.value)
        return Side.NO_SIDE;
    else if (retval ==POSITIVE_SIDE.value)
        return Side.POSITIVE_SIDE;
    else if (retval ==NEGATIVE_SIDE.value)
        return Side.NEGATIVE_SIDE;
    else if (retval ==BOTH_SIDE.value)
        return Side.BOTH_SIDE;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class SideHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public Plane(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected Plane(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public Plane(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** 
    Default constructor - sets everything to 0. **/
    public Plane() {
         super( new org.xbig.base.InstancePointer(__createPlane()), false);
    }

    private native static long __createPlane();

    /** **/
    public Plane(org.ogre4j.IPlane rhs) {
         super( new org.xbig.base.InstancePointer(__createPlane__PlaneR( rhs.getInstancePointer().pointer)), false);
    }

    private native static long __createPlane__PlaneR(long rhs);

    /** 
    Construct a plane through a normal, and a distance to move the plane along the normal. **/
    public Plane(org.ogre4j.IVector3 rkNormal, float fConstant) {
         super( new org.xbig.base.InstancePointer(__createPlane__Vector3RRealv( rkNormal.getInstancePointer().pointer,  fConstant)), false);
    }

    private native static long __createPlane__Vector3RRealv(long rkNormal, float fConstant);

    /** 
    Construct a plane using the 4 constants directly **/
    public Plane(float a, float b, float c, float d) {
         super( new org.xbig.base.InstancePointer(__createPlane__RealvRealvRealvRealv( a,  b,  c,  d)), false);
    }

    private native static long __createPlane__RealvRealvRealvRealv(float a, float b, float c, float d);

    /** **/
    public Plane(org.ogre4j.IVector3 rkNormal, org.ogre4j.IVector3 rkPoint) {
         super( new org.xbig.base.InstancePointer(__createPlane__Vector3RVector3R( rkNormal.getInstancePointer().pointer,  rkPoint.getInstancePointer().pointer)), false);
    }

    private native static long __createPlane__Vector3RVector3R(long rkNormal, long rkPoint);

    /** **/
    public Plane(org.ogre4j.IVector3 rkPoint0, org.ogre4j.IVector3 rkPoint1, org.ogre4j.IVector3 rkPoint2) {
         super( new org.xbig.base.InstancePointer(__createPlane__Vector3RVector3RVector3R( rkPoint0.getInstancePointer().pointer,  rkPoint1.getInstancePointer().pointer,  rkPoint2.getInstancePointer().pointer)), false);
    }

    private native static long __createPlane__Vector3RVector3RVector3R(long rkPoint0, long rkPoint1, long rkPoint2);

    /** **/
    public org.ogre4j.Plane.Side getSide(org.ogre4j.IVector3 rkPoint) {
         return org.ogre4j.Plane.Side.toEnum(_getSide__Vector3R_const(this.object.pointer, rkPoint.getInstancePointer().pointer));
    }

    private native int _getSide__Vector3R_const(long _pointer_, long rkPoint);

    /** 
    returns the side where the aligneBox is. the flag BOTH_SIDE indicates an intersecting box. one corner ON the plane is sufficient to consider the box and the plane intersecting. **/
    public org.ogre4j.Plane.Side getSide(org.ogre4j.IAxisAlignedBox rkBox) {
         return org.ogre4j.Plane.Side.toEnum(_getSide__AxisAlignedBoxR_const(this.object.pointer, rkBox.getInstancePointer().pointer));
    }

    private native int _getSide__AxisAlignedBoxR_const(long _pointer_, long rkBox);

    /** 
    Returns which side of the plane that the given box lies on. The box is defined as centre/half-size pairs for effectively. **/
    public org.ogre4j.Plane.Side getSide(org.ogre4j.IVector3 centre, org.ogre4j.IVector3 halfSize) {
         return org.ogre4j.Plane.Side.toEnum(_getSide__Vector3RVector3R_const(this.object.pointer, centre.getInstancePointer().pointer,  halfSize.getInstancePointer().pointer));
    }

    private native int _getSide__Vector3RVector3R_const(long _pointer_, long centre, long halfSize);

    /** 
    This is a pseudodistance. The sign of the return value is positive if the point is on the positive side of the plane, negative if the point is on the negative side, and zero if the point is on the plane. **/
    public float getDistance(org.ogre4j.IVector3 rkPoint) {
         return _getDistance__Vector3R_const(this.object.pointer, rkPoint.getInstancePointer().pointer);
    }

    private native float _getDistance__Vector3R_const(long _pointer_, long rkPoint);

    /** 
    Redefine this plane based on 3 points. **/
    public void redefine(org.ogre4j.IVector3 rkPoint0, org.ogre4j.IVector3 rkPoint1, org.ogre4j.IVector3 rkPoint2) {
        _redefine__Vector3RVector3RVector3R(this.object.pointer, rkPoint0.getInstancePointer().pointer,  rkPoint1.getInstancePointer().pointer,  rkPoint2.getInstancePointer().pointer);
    }

    private native void _redefine__Vector3RVector3RVector3R(long _pointer_, long rkPoint0, long rkPoint1, long rkPoint2);

    /** 
    Redefine this plane based on a normal and a point. **/
    public void redefine(org.ogre4j.IVector3 rkNormal, org.ogre4j.IVector3 rkPoint) {
        _redefine__Vector3RVector3R(this.object.pointer, rkNormal.getInstancePointer().pointer,  rkPoint.getInstancePointer().pointer);
    }

    private native void _redefine__Vector3RVector3R(long _pointer_, long rkNormal, long rkPoint);

    /** 
    Project a vector onto the plane. **/
    public void projectVector(org.ogre4j.IVector3 returnValue, org.ogre4j.IVector3 v) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_projectVector__Vector3R_const(this.object.pointer, v.getInstancePointer().pointer)), false);
    }

    private native long _projectVector__Vector3R_const(long _pointer_, long v);

    /** 
    Normalises the plane. **/
    public float normalise() {
         return _normalise(this.object.pointer);
    }

    private native float _normalise(long _pointer_);

    /** **/
    public boolean operatorEqual(org.ogre4j.IPlane rhs) {
         return _operatorEqual__PlaneR_const(this.object.pointer, rhs.getInstancePointer().pointer);
    }

    private native boolean _operatorEqual__PlaneR_const(long _pointer_, long rhs);

    /** **/
    public boolean operatorNotEqual(org.ogre4j.IPlane rhs) {
         return _operatorNotEqual__PlaneR_const(this.object.pointer, rhs.getInstancePointer().pointer);
    }

    private native boolean _operatorNotEqual__PlaneR_const(long _pointer_, long rhs);

    /** **/
    public void getnormal(org.ogre4j.IVector3 returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getnormal(this.object.pointer)), false);
    }

    private native long _getnormal(long _pointer_);

    /** **/
    public void setnormal(org.ogre4j.IVector3 _jni_value_) {
        _setnormal(this.object.pointer, _jni_value_.getInstancePointer().pointer);
    }

    private native void _setnormal(long _pointer_, long _jni_value_);

    /** **/
    public float getd() {
         return _getd(this.object.pointer);
    }

    private native float _getd(long _pointer_);

    /** **/
    public void setd(float _jni_value_) {
        _setd(this.object.pointer, _jni_value_);
    }

    private native void _setd(long _pointer_, float _jni_value_);

}
