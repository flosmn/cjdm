/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class RenderTarget extends org.xbig.base.NativeObject implements org.ogre4j.IRenderTarget {
static { System.loadLibrary("ogre4j");}
public static class Impl extends org.xbig.base.NativeObject implements org.ogre4j.IRenderTarget.IImpl {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public Impl(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected Impl(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public Impl(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public Impl() {
         super( new org.xbig.base.InstancePointer(__createImpl()), false);
    }

    private native static long __createImpl();

}
public static class FrameStats extends org.xbig.base.NativeObject implements org.ogre4j.IRenderTarget.IFrameStats {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public FrameStats(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected FrameStats(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public FrameStats(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public FrameStats() {
         super( new org.xbig.base.InstancePointer(__createFrameStats()), false);
    }

    private native static long __createFrameStats();

    /** **/
    public float getlastFPS() {
         return _getlastFPS(this.object.pointer);
    }

    private native float _getlastFPS(long _pointer_);

    /** **/
    public void setlastFPS(float _jni_value_) {
        _setlastFPS(this.object.pointer, _jni_value_);
    }

    private native void _setlastFPS(long _pointer_, float _jni_value_);

    /** **/
    public float getavgFPS() {
         return _getavgFPS(this.object.pointer);
    }

    private native float _getavgFPS(long _pointer_);

    /** **/
    public void setavgFPS(float _jni_value_) {
        _setavgFPS(this.object.pointer, _jni_value_);
    }

    private native void _setavgFPS(long _pointer_, float _jni_value_);

    /** **/
    public float getbestFPS() {
         return _getbestFPS(this.object.pointer);
    }

    private native float _getbestFPS(long _pointer_);

    /** **/
    public void setbestFPS(float _jni_value_) {
        _setbestFPS(this.object.pointer, _jni_value_);
    }

    private native void _setbestFPS(long _pointer_, float _jni_value_);

    /** **/
    public float getworstFPS() {
         return _getworstFPS(this.object.pointer);
    }

    private native float _getworstFPS(long _pointer_);

    /** **/
    public void setworstFPS(float _jni_value_) {
        _setworstFPS(this.object.pointer, _jni_value_);
    }

    private native void _setworstFPS(long _pointer_, float _jni_value_);

    /** **/
    public long getbestFrameTime() {
         return _getbestFrameTime(this.object.pointer);
    }

    private native long _getbestFrameTime(long _pointer_);

    /** **/
    public void setbestFrameTime(long _jni_value_) {
        _setbestFrameTime(this.object.pointer, _jni_value_);
    }

    private native void _setbestFrameTime(long _pointer_, long _jni_value_);

    /** **/
    public long getworstFrameTime() {
         return _getworstFrameTime(this.object.pointer);
    }

    private native long _getworstFrameTime(long _pointer_);

    /** **/
    public void setworstFrameTime(long _jni_value_) {
        _setworstFrameTime(this.object.pointer, _jni_value_);
    }

    private native void _setworstFrameTime(long _pointer_, long _jni_value_);

    /** **/
    public int gettriangleCount() {
         return _gettriangleCount(this.object.pointer);
    }

    private native int _gettriangleCount(long _pointer_);

    /** **/
    public void settriangleCount(int _jni_value_) {
        _settriangleCount(this.object.pointer, _jni_value_);
    }

    private native void _settriangleCount(long _pointer_, int _jni_value_);

    /** **/
    public int getbatchCount() {
         return _getbatchCount(this.object.pointer);
    }

    private native int _getbatchCount(long _pointer_);

    /** **/
    public void setbatchCount(int _jni_value_) {
        _setbatchCount(this.object.pointer, _jni_value_);
    }

    private native void _setbatchCount(long _pointer_, int _jni_value_);

}
public enum StatFlags implements INativeEnum < StatFlags > {
    SF_NONE(StatFlagsHelper.ENUM_VALUES[0]),
    SF_FPS(StatFlagsHelper.ENUM_VALUES[1]),
    SF_AVG_FPS(StatFlagsHelper.ENUM_VALUES[2]),
    SF_BEST_FPS(StatFlagsHelper.ENUM_VALUES[3]),
    SF_WORST_FPS(StatFlagsHelper.ENUM_VALUES[4]),
    SF_TRIANGLE_COUNT(StatFlagsHelper.ENUM_VALUES[5]),
    SF_ALL(StatFlagsHelper.ENUM_VALUES[6]);

    private int value;

    StatFlags(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public StatFlags getEnum(int val) {
        return toEnum(val);
    }

    public static final StatFlags toEnum(int retval) {
    if (retval ==SF_NONE.value)
        return StatFlags.SF_NONE;
    else if (retval ==SF_FPS.value)
        return StatFlags.SF_FPS;
    else if (retval ==SF_AVG_FPS.value)
        return StatFlags.SF_AVG_FPS;
    else if (retval ==SF_BEST_FPS.value)
        return StatFlags.SF_BEST_FPS;
    else if (retval ==SF_WORST_FPS.value)
        return StatFlags.SF_WORST_FPS;
    else if (retval ==SF_TRIANGLE_COUNT.value)
        return StatFlags.SF_TRIANGLE_COUNT;
    else if (retval ==SF_ALL.value)
        return StatFlags.SF_ALL;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class StatFlagsHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

public enum FrameBuffer implements INativeEnum < FrameBuffer > {
    FB_FRONT(FrameBufferHelper.ENUM_VALUES[0]),
    FB_BACK(FrameBufferHelper.ENUM_VALUES[1]),
    FB_AUTO(FrameBufferHelper.ENUM_VALUES[2]);

    private int value;

    FrameBuffer(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public FrameBuffer getEnum(int val) {
        return toEnum(val);
    }

    public static final FrameBuffer toEnum(int retval) {
    if (retval ==FB_FRONT.value)
        return FrameBuffer.FB_FRONT;
    else if (retval ==FB_BACK.value)
        return FrameBuffer.FB_BACK;
    else if (retval ==FB_AUTO.value)
        return FrameBuffer.FB_AUTO;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class FrameBufferHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

protected static class ViewportList extends org.xbig.base.NativeObject implements org.ogre4j.IRenderTarget.IViewportList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public ViewportList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected ViewportList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public ViewportList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public ViewportList() {
         super( new org.xbig.base.InstancePointer(__createViewportList()), false);
    }

    private native static long __createViewportList();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(int key) {
         return _count__iR(this.object.pointer, key);
    }

    private native int _count__iR(long _pointer_, int key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(int key) {
         return _erase__iR(this.object.pointer, key);
    }

    private native int _erase__iR(long _pointer_, int key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

    /** **/
    public org.ogre4j.IViewport get(int key) {
         return new org.ogre4j.Viewport(new InstancePointer(_get__iR(this.object.pointer, key)));
    }

    private native long _get__iR(long _pointer_, int key);

    /** **/
    public void insert(int key, org.ogre4j.IViewport value) {
        _insert__iROgre_Viewportp(this.object.pointer, key,  value.getInstancePointer().pointer);
    }

    private native void _insert__iROgre_Viewportp(long _pointer_, int key, long value);

}
protected static class RenderTargetListenerList extends org.xbig.base.NativeObject implements org.ogre4j.IRenderTarget.IRenderTargetListenerList {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public RenderTargetListenerList(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected RenderTargetListenerList(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public RenderTargetListenerList(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public RenderTargetListenerList() {
         super( new org.xbig.base.InstancePointer(__createRenderTargetListenerList()), false);
    }

    private native static long __createRenderTargetListenerList();

    /** **/
    public void assign(int num, org.ogre4j.IRenderTargetListener val) {
        _assign__ivOgre_RenderTargetListenerP(this.object.pointer, num,  val.getInstancePointer().pointer);
    }

    private native void _assign__ivOgre_RenderTargetListenerP(long _pointer_, int num, long val);

    /** **/
    public org.ogre4j.IRenderTargetListener at(int loc) {
         return new org.ogre4j.RenderTargetListener(new InstancePointer(_at__iv(this.object.pointer, loc)));
    }

    private native long _at__iv(long _pointer_, int loc);

    /** **/
    public org.ogre4j.IRenderTargetListener back() {
         return new org.ogre4j.RenderTargetListener(new InstancePointer(_back(this.object.pointer)));
    }

    private native long _back(long _pointer_);

    /** **/
    public int capacity() {
         return _capacity(this.object.pointer);
    }

    private native int _capacity(long _pointer_);

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public boolean empty() {
         return _empty(this.object.pointer);
    }

    private native boolean _empty(long _pointer_);

    /** **/
    public org.ogre4j.IRenderTargetListener front() {
         return new org.ogre4j.RenderTargetListener(new InstancePointer(_front(this.object.pointer)));
    }

    private native long _front(long _pointer_);

    /** **/
    public int max_size() {
         return _max_size(this.object.pointer);
    }

    private native int _max_size(long _pointer_);

    /** **/
    public void pop_back() {
        _pop_back(this.object.pointer);
    }

    private native void _pop_back(long _pointer_);

    /** **/
    public void push_back(org.ogre4j.IRenderTargetListener val) {
        _push_back__Ogre_RenderTargetListenerP(this.object.pointer, val.getInstancePointer().pointer);
    }

    private native void _push_back__Ogre_RenderTargetListenerP(long _pointer_, long val);

    /** **/
    public void reserve(int size) {
        _reserve__iV(this.object.pointer, size);
    }

    private native void _reserve__iV(long _pointer_, int size);

    /** **/
    public int size() {
         return _size(this.object.pointer);
    }

    private native int _size(long _pointer_);

}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public RenderTarget(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected RenderTarget(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public RenderTarget(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public String getName() {
         return _getName_const(this.object.pointer);
    }

    private native String _getName_const(long _pointer_);

    /** **/
    public void getMetrics(LongPointer width, LongPointer height, LongPointer colourDepth) {
        _getMetrics__IrIrIr(this.object.pointer, width.object.pointer,  height.object.pointer,  colourDepth.object.pointer);
    }

    private native void _getMetrics__IrIrIr(long _pointer_, long width, long height, long colourDepth);

    /** **/
    public long getWidth() {
         return _getWidth_const(this.object.pointer);
    }

    private native long _getWidth_const(long _pointer_);

    /** **/
    public long getHeight() {
         return _getHeight_const(this.object.pointer);
    }

    private native long _getHeight_const(long _pointer_);

    /** **/
    public long getColourDepth() {
         return _getColourDepth_const(this.object.pointer);
    }

    private native long _getColourDepth_const(long _pointer_);

    /** 
    Tells the target to update it's contents. **/
    public void update(boolean swapBuffers) {
        _update__bv(this.object.pointer, swapBuffers);
    }

    private native void _update__bv(long _pointer_, boolean swapBuffers);

    /** 
    Swaps the frame buffers to display the next frame. **/
    public void swapBuffers(boolean waitForVSync) {
        _swapBuffers__bv(this.object.pointer, waitForVSync);
    }

    private native void _swapBuffers__bv(long _pointer_, boolean waitForVSync);

    /** 
    Adds a viewport to the rendering target. **/
    public org.ogre4j.IViewport addViewport(org.ogre4j.ICamera cam, int ZOrder, float left, float top, float width, float height) {
         return new org.ogre4j.Viewport(new InstancePointer(_addViewport__CamerapivFvFvFvFv(this.object.pointer, cam.getInstancePointer().pointer,  ZOrder,  left,  top,  width,  height)));
    }

    private native long _addViewport__CamerapivFvFvFvFv(long _pointer_, long cam, int ZOrder, float left, float top, float width, float height);

    /** 
    Returns the number of viewports attached to this target. **/
    public int getNumViewports() {
         return _getNumViewports_const(this.object.pointer);
    }

    private native int _getNumViewports_const(long _pointer_);

    /** 
    Retrieves a pointer to the viewport with the given index. **/
    public org.ogre4j.IViewport getViewport(int index) {
         return new org.ogre4j.Viewport(new InstancePointer(_getViewport__Hv(this.object.pointer, index)));
    }

    private native long _getViewport__Hv(long _pointer_, int index);

    /** 
    Removes a viewport at a given ZOrder. **/
    public void removeViewport(int ZOrder) {
        _removeViewport__iv(this.object.pointer, ZOrder);
    }

    private native void _removeViewport__iv(long _pointer_, int ZOrder);

    /** 
    Removes all viewports on this target. **/
    public void removeAllViewports() {
        _removeAllViewports(this.object.pointer);
    }

    private native void _removeAllViewports(long _pointer_);

    /** 
    Retieves details of current rendering performance. **/
    public void getStatistics(FloatPointer lastFPS, FloatPointer avgFPS, FloatPointer bestFPS, FloatPointer worstFPS) {
        _getStatistics__FrFrFrFr_const(this.object.pointer, lastFPS.object.pointer,  avgFPS.object.pointer,  bestFPS.object.pointer,  worstFPS.object.pointer);
    }

    private native void _getStatistics__FrFrFrFr_const(long _pointer_, long lastFPS, long avgFPS, long bestFPS, long worstFPS);

    /** **/
    public org.ogre4j.IRenderTarget.IFrameStats getStatistics() {
         return new org.ogre4j.RenderTarget.FrameStats(new InstancePointer(_getStatistics_const(this.object.pointer)));
    }

    private native long _getStatistics_const(long _pointer_);

    /** 
    Individual stats access - gets the number of frames per second (FPS) based on the last frame rendered. **/
    public float getLastFPS() {
         return _getLastFPS_const(this.object.pointer);
    }

    private native float _getLastFPS_const(long _pointer_);

    /** 
    Individual stats access - gets the average frames per second (FPS) since call to . **/
    public float getAverageFPS() {
         return _getAverageFPS_const(this.object.pointer);
    }

    private native float _getAverageFPS_const(long _pointer_);

    /** 
    Individual stats access - gets the best frames per second (FPS) since call to . **/
    public float getBestFPS() {
         return _getBestFPS_const(this.object.pointer);
    }

    private native float _getBestFPS_const(long _pointer_);

    /** 
    Individual stats access - gets the worst frames per second (FPS) since call to . **/
    public float getWorstFPS() {
         return _getWorstFPS_const(this.object.pointer);
    }

    private native float _getWorstFPS_const(long _pointer_);

    /** 
    Individual stats access - gets the best frame time **/
    public float getBestFrameTime() {
         return _getBestFrameTime_const(this.object.pointer);
    }

    private native float _getBestFrameTime_const(long _pointer_);

    /** 
    Individual stats access - gets the worst frame time **/
    public float getWorstFrameTime() {
         return _getWorstFrameTime_const(this.object.pointer);
    }

    private native float _getWorstFrameTime_const(long _pointer_);

    /** 
    Resets saved frame-rate statistices. **/
    public void resetStatistics() {
        _resetStatistics(this.object.pointer);
    }

    private native void _resetStatistics(long _pointer_);

    /** 
    Gets a custom (maybe platform-specific) attribute. **/
    public void getCustomAttribute(String name, VoidPointer pData) {
        _getCustomAttribute__StringRvp(this.object.pointer, name,  pData.object.pointer);
    }

    private native void _getCustomAttribute__StringRvp(long _pointer_, String name, long pData);

    /** 
    Add a listener to this  which will be called back before & after rendering. **/
    public void addListener(org.ogre4j.IRenderTargetListener listener) {
        _addListener__RenderTargetListenerp(this.object.pointer, listener.getInstancePointer().pointer);
    }

    private native void _addListener__RenderTargetListenerp(long _pointer_, long listener);

    /** 
    Removes a  previously registered using addListener. **/
    public void removeListener(org.ogre4j.IRenderTargetListener listener) {
        _removeListener__RenderTargetListenerp(this.object.pointer, listener.getInstancePointer().pointer);
    }

    private native void _removeListener__RenderTargetListenerp(long _pointer_, long listener);

    /** 
    Removes all listeners from this instance. **/
    public void removeAllListeners() {
        _removeAllListeners(this.object.pointer);
    }

    private native void _removeAllListeners(long _pointer_);

    /** 
    Sets the priority of this render target in relation to the others. **/
    public void setPriority(short priority) {
        _setPriority__ucharv(this.object.pointer, priority);
    }

    private native void _setPriority__ucharv(long _pointer_, short priority);

    /** 
    Gets the priority of a render target. **/
    public short getPriority() {
         return _getPriority_const(this.object.pointer);
    }

    private native short _getPriority_const(long _pointer_);

    /** 
    Used to retrieve or set the active state of the render target. **/
    public boolean isActive() {
         return _isActive_const(this.object.pointer);
    }

    private native boolean _isActive_const(long _pointer_);

    /** 
    Used to set the active state of the render target. **/
    public void setActive(boolean state) {
        _setActive__bv(this.object.pointer, state);
    }

    private native void _setActive__bv(long _pointer_, boolean state);

    /** 
    Sets whether this target should be automatically updated if Ogre's rendering loop or  is being used. **/
    public void setAutoUpdated(boolean autoupdate) {
        _setAutoUpdated__bv(this.object.pointer, autoupdate);
    }

    private native void _setAutoUpdated__bv(long _pointer_, boolean autoupdate);

    /** 
    Gets whether this target is automatically updated if Ogre's rendering loop or  is being used. **/
    public boolean isAutoUpdated() {
         return _isAutoUpdated_const(this.object.pointer);
    }

    private native boolean _isAutoUpdated_const(long _pointer_);

    /** 
    Copies the current contents of the render target to a pixelbox. **/
    public void copyContentsToMemory(org.ogre4j.IPixelBox dst, org.ogre4j.RenderTarget.FrameBuffer buffer) {
        _copyContentsToMemory__PixelBoxRFrameBufferv(this.object.pointer, dst.getInstancePointer().pointer,  buffer.getValue());
    }

    private native void _copyContentsToMemory__PixelBoxRFrameBufferv(long _pointer_, long dst, int buffer);

    /** 
    Suggests a pixel format to use for extracting the data in this target, when calling copyContentsToMemory. **/
    public org.ogre4j.PixelFormat suggestPixelFormat() {
         return org.ogre4j.PixelFormat.toEnum(_suggestPixelFormat_const(this.object.pointer));
    }

    private native int _suggestPixelFormat_const(long _pointer_);

    /** 
    Writes the current contents of the render target to the named file. **/
    public void writeContentsToFile(String filename) {
        _writeContentsToFile__StringR(this.object.pointer, filename);
    }

    private native void _writeContentsToFile__StringR(long _pointer_, String filename);

    /** 
    Writes the current contents of the render target to the (PREFIX)(time-stamp)(SUFFIX) file. **/
    public String writeContentsToTimestampedFile(String filenamePrefix, String filenameSuffix) {
         return _writeContentsToTimestampedFile__StringRStringR(this.object.pointer, filenamePrefix,  filenameSuffix);
    }

    private native String _writeContentsToTimestampedFile__StringRStringR(long _pointer_, String filenamePrefix, String filenameSuffix);

    /** **/
    public boolean requiresTextureFlipping() {
         return _requiresTextureFlipping_const(this.object.pointer);
    }

    private native boolean _requiresTextureFlipping_const(long _pointer_);

    /** 
    Gets the number of triangles rendered in the last  call. **/
    public int getTriangleCount() {
         return _getTriangleCount_const(this.object.pointer);
    }

    private native int _getTriangleCount_const(long _pointer_);

    /** 
    Gets the number of batches rendered in the last  call. **/
    public int getBatchCount() {
         return _getBatchCount_const(this.object.pointer);
    }

    private native int _getBatchCount_const(long _pointer_);

    /** 
    Utility method to notify a render target that a camera has been removed, incase it was referring to it as a viewer. **/
    public void _notifyCameraRemoved(org.ogre4j.ICamera cam) {
        __notifyCameraRemoved__CameraP(this.object.pointer, cam.getInstancePointer().pointer);
    }

    private native void __notifyCameraRemoved__CameraP(long _pointer_, long cam);

    /** 
    Indicates whether this target is the primary window. The primary window is special in that it is destroyed when ogre is shut down, and cannot be destroyed directly. This is the case because it holds the context for vertex, index buffers and textures. **/
    public boolean isPrimary() {
         return _isPrimary_const(this.object.pointer);
    }

    private native boolean _isPrimary_const(long _pointer_);

    /** 
    Indicates whether on rendering, linear colour space is converted to sRGB gamma colour space. This is the exact opposite conversion of what is indicated by , and can only be enabled on creation of the render target. For render windows, it's enabled through the 'gamma' creation misc parameter. For textures, it is enabled through the hwGamma parameter to the create call. **/
    public boolean isHardwareGammaEnabled() {
         return _isHardwareGammaEnabled_const(this.object.pointer);
    }

    private native boolean _isHardwareGammaEnabled_const(long _pointer_);

    /** 
    Indicates whether multisampling is performed on rendering and at what level. **/
    public long getFSAA() {
         return _getFSAA_const(this.object.pointer);
    }

    private native long _getFSAA_const(long _pointer_);

    /** 
    Get rendersystem specific interface for this . This is used by the  to (un)bind this target, and to get specific information like surfaces and framebuffer objects. **/
    public org.ogre4j.IRenderTarget.IImpl _getImpl() {
         return new org.ogre4j.RenderTarget.Impl(new InstancePointer(__getImpl(this.object.pointer)));
    }

    private native long __getImpl(long _pointer_);

}
