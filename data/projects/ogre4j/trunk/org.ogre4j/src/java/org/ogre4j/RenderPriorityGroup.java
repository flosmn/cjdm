/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class RenderPriorityGroup extends org.xbig.base.NativeObject implements org.ogre4j.IRenderPriorityGroup {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public RenderPriorityGroup(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected RenderPriorityGroup(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public RenderPriorityGroup(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public RenderPriorityGroup(org.ogre4j.IRenderQueueGroup parent, boolean splitPassesByLightingType, boolean splitNoShadowPasses, boolean shadowCastersNotReceivers) {
         super( new org.xbig.base.InstancePointer(__createRenderPriorityGroup__RenderQueueGrouppbvbvbv( parent.getInstancePointer().pointer,  splitPassesByLightingType,  splitNoShadowPasses,  shadowCastersNotReceivers)), false);
    }

    private native static long __createRenderPriorityGroup__RenderQueueGrouppbvbvbv(long parent, boolean splitPassesByLightingType, boolean splitNoShadowPasses, boolean shadowCastersNotReceivers);

    /** 
    Get the collection of basic solids currently queued, this includes all solids when there are no shadows, or all solids which have shadow receiving enabled when using modulative shadows, or all ambient passes of solids which have shadow receive enabled for additive shadows. **/
    public org.ogre4j.IQueuedRenderableCollection getSolidsBasic() {
         return new org.ogre4j.QueuedRenderableCollection(new InstancePointer(_getSolidsBasic_const(this.object.pointer)));
    }

    private native long _getSolidsBasic_const(long _pointer_);

    /** 
    Get the collection of solids currently queued per light (only applicable in additive shadow modes). **/
    public org.ogre4j.IQueuedRenderableCollection getSolidsDiffuseSpecular() {
         return new org.ogre4j.QueuedRenderableCollection(new InstancePointer(_getSolidsDiffuseSpecular_const(this.object.pointer)));
    }

    private native long _getSolidsDiffuseSpecular_const(long _pointer_);

    /** 
    Get the collection of solids currently queued for decal passes (only applicable in additive shadow modes). **/
    public org.ogre4j.IQueuedRenderableCollection getSolidsDecal() {
         return new org.ogre4j.QueuedRenderableCollection(new InstancePointer(_getSolidsDecal_const(this.object.pointer)));
    }

    private native long _getSolidsDecal_const(long _pointer_);

    /** 
    Get the collection of solids for which shadow receipt is disabled (only applicable when shadows are enabled). **/
    public org.ogre4j.IQueuedRenderableCollection getSolidsNoShadowReceive() {
         return new org.ogre4j.QueuedRenderableCollection(new InstancePointer(_getSolidsNoShadowReceive_const(this.object.pointer)));
    }

    private native long _getSolidsNoShadowReceive_const(long _pointer_);

    /** 
    Get the collection of transparent objects currently queued **/
    public org.ogre4j.IQueuedRenderableCollection getTransparentsUnsorted() {
         return new org.ogre4j.QueuedRenderableCollection(new InstancePointer(_getTransparentsUnsorted_const(this.object.pointer)));
    }

    private native long _getTransparentsUnsorted_const(long _pointer_);

    /** 
    Get the collection of transparent objects currently queued **/
    public org.ogre4j.IQueuedRenderableCollection getTransparents() {
         return new org.ogre4j.QueuedRenderableCollection(new InstancePointer(_getTransparents_const(this.object.pointer)));
    }

    private native long _getTransparents_const(long _pointer_);

    /** 
    Reset the organisation modes required for the solids in this group. **/
    public void resetOrganisationModes() {
        _resetOrganisationModes(this.object.pointer);
    }

    private native void _resetOrganisationModes(long _pointer_);

    /** 
    Add a required sorting / grouping mode for the solids in this group. **/
    public void addOrganisationMode(org.ogre4j.QueuedRenderableCollection.OrganisationMode om) {
        _addOrganisationMode__QueuedRenderableCollection_OrganisationModev(this.object.pointer, om.getValue());
    }

    private native void _addOrganisationMode__QueuedRenderableCollection_OrganisationModev(long _pointer_, int om);

    /** 
    Set the sorting / grouping mode for the solids in this group to the default. **/
    public void defaultOrganisationMode() {
        _defaultOrganisationMode(this.object.pointer);
    }

    private native void _defaultOrganisationMode(long _pointer_);

    /** 
    Add a renderable to this group. **/
    public void addRenderable(org.ogre4j.IRenderable pRend, org.ogre4j.ITechnique pTech) {
        _addRenderable__RenderablepTechniquep(this.object.pointer, pRend.getInstancePointer().pointer,  pTech.getInstancePointer().pointer);
    }

    private native void _addRenderable__RenderablepTechniquep(long _pointer_, long pRend, long pTech);

    /** 
    Sorts the objects which have been added to the queue; transparent objects by their depth in relation to the passed in . **/
    public void sort(org.ogre4j.ICamera cam) {
        _sort__CameraP(this.object.pointer, cam.getInstancePointer().pointer);
    }

    private native void _sort__CameraP(long _pointer_, long cam);

    /** 
    Clears this group of renderables. **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** 
    Sets whether or not the queue will split passes by their lighting type, ie ambient, per-light and decal. **/
    public void setSplitPassesByLightingType(boolean split) {
        _setSplitPassesByLightingType__bv(this.object.pointer, split);
    }

    private native void _setSplitPassesByLightingType__bv(long _pointer_, boolean split);

    /** 
    Sets whether or not passes which have shadow receive disabled should be separated. **/
    public void setSplitNoShadowPasses(boolean split) {
        _setSplitNoShadowPasses__bv(this.object.pointer, split);
    }

    private native void _setSplitNoShadowPasses__bv(long _pointer_, boolean split);

    /** 
    Sets whether or not objects which cast shadows should be treated as never receiving shadows. **/
    public void setShadowCastersCannotBeReceivers(boolean ind) {
        _setShadowCastersCannotBeReceivers__bv(this.object.pointer, ind);
    }

    private native void _setShadowCastersCannotBeReceivers__bv(long _pointer_, boolean ind);

}
