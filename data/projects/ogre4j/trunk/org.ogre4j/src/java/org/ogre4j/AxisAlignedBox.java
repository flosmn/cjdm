/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class AxisAlignedBox extends org.xbig.base.NativeObject implements org.ogre4j.IAxisAlignedBox {
static { System.loadLibrary("ogre4j");}
public enum Extent implements INativeEnum < Extent > {
    EXTENT_NULL(ExtentHelper.ENUM_VALUES[0]),
    EXTENT_FINITE(ExtentHelper.ENUM_VALUES[1]),
    EXTENT_INFINITE(ExtentHelper.ENUM_VALUES[2]);

    private int value;

    Extent(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public Extent getEnum(int val) {
        return toEnum(val);
    }

    public static final Extent toEnum(int retval) {
    if (retval ==EXTENT_NULL.value)
        return Extent.EXTENT_NULL;
    else if (retval ==EXTENT_FINITE.value)
        return Extent.EXTENT_FINITE;
    else if (retval ==EXTENT_INFINITE.value)
        return Extent.EXTENT_INFINITE;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class ExtentHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

public enum CornerEnum implements INativeEnum < CornerEnum > {
    FAR_LEFT_BOTTOM(CornerEnumHelper.ENUM_VALUES[0]),
    FAR_LEFT_TOP(CornerEnumHelper.ENUM_VALUES[1]),
    FAR_RIGHT_TOP(CornerEnumHelper.ENUM_VALUES[2]),
    FAR_RIGHT_BOTTOM(CornerEnumHelper.ENUM_VALUES[3]),
    NEAR_RIGHT_BOTTOM(CornerEnumHelper.ENUM_VALUES[4]),
    NEAR_LEFT_BOTTOM(CornerEnumHelper.ENUM_VALUES[5]),
    NEAR_LEFT_TOP(CornerEnumHelper.ENUM_VALUES[6]),
    NEAR_RIGHT_TOP(CornerEnumHelper.ENUM_VALUES[7]);

    private int value;

    CornerEnum(int i) {
        this.value = i;
    }

    public int getValue() {
        return value;
    }

    public CornerEnum getEnum(int val) {
        return toEnum(val);
    }

    public static final CornerEnum toEnum(int retval) {
    if (retval ==FAR_LEFT_BOTTOM.value)
        return CornerEnum.FAR_LEFT_BOTTOM;
    else if (retval ==FAR_LEFT_TOP.value)
        return CornerEnum.FAR_LEFT_TOP;
    else if (retval ==FAR_RIGHT_TOP.value)
        return CornerEnum.FAR_RIGHT_TOP;
    else if (retval ==FAR_RIGHT_BOTTOM.value)
        return CornerEnum.FAR_RIGHT_BOTTOM;
    else if (retval ==NEAR_RIGHT_BOTTOM.value)
        return CornerEnum.NEAR_RIGHT_BOTTOM;
    else if (retval ==NEAR_LEFT_BOTTOM.value)
        return CornerEnum.NEAR_LEFT_BOTTOM;
    else if (retval ==NEAR_LEFT_TOP.value)
        return CornerEnum.NEAR_LEFT_TOP;
    else if (retval ==NEAR_RIGHT_TOP.value)
        return CornerEnum.NEAR_RIGHT_TOP;
    throw new RuntimeException("wrong number in jni call for an enum");
    }
}

static class CornerEnumHelper{

				public static final int[] ENUM_VALUES =
				getEnumValues();

			
				private static native int[] getEnumValues();

			
};

 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public AxisAlignedBox(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected AxisAlignedBox(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public AxisAlignedBox(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public AxisAlignedBox() {
         super( new org.xbig.base.InstancePointer(__createAxisAlignedBox()), false);
    }

    private native static long __createAxisAlignedBox();

    /** **/
    public AxisAlignedBox(org.ogre4j.AxisAlignedBox.Extent e) {
         super( new org.xbig.base.InstancePointer(__createAxisAlignedBox__Extentv( e.getValue())), false);
    }

    private native static long __createAxisAlignedBox__Extentv(int e);

    /** **/
    public AxisAlignedBox(org.ogre4j.IAxisAlignedBox rkBox) {
         super( new org.xbig.base.InstancePointer(__createAxisAlignedBox__AxisAlignedBoxR( rkBox.getInstancePointer().pointer)), false);
    }

    private native static long __createAxisAlignedBox__AxisAlignedBoxR(long rkBox);

    /** **/
    public AxisAlignedBox(org.ogre4j.IVector3 _min, org.ogre4j.IVector3 _max) {
         super( new org.xbig.base.InstancePointer(__createAxisAlignedBox__Vector3RVector3R( _min.getInstancePointer().pointer,  _max.getInstancePointer().pointer)), false);
    }

    private native static long __createAxisAlignedBox__Vector3RVector3R(long _min, long _max);

    /** **/
    public AxisAlignedBox(float mx, float my, float mz, float Mx, float My, float Mz) {
         super( new org.xbig.base.InstancePointer(__createAxisAlignedBox__RealvRealvRealvRealvRealvRealv( mx,  my,  mz,  Mx,  My,  Mz)), false);
    }

    private native static long __createAxisAlignedBox__RealvRealvRealvRealvRealvRealv(float mx, float my, float mz, float Mx, float My, float Mz);

    /** **/
    public org.ogre4j.IAxisAlignedBox operatorAssignment(org.ogre4j.IAxisAlignedBox rhs) {
         return new org.ogre4j.AxisAlignedBox(new InstancePointer(_operatorAssignment__AxisAlignedBoxR(this.object.pointer, rhs.getInstancePointer().pointer)));
    }

    private native long _operatorAssignment__AxisAlignedBoxR(long _pointer_, long rhs);

    /** **/
    public org.ogre4j.IVector3 getMinimum_const() {
         return new org.ogre4j.Vector3(new InstancePointer(_getMinimum_const_const(this.object.pointer)));
    }

    private native long _getMinimum_const_const(long _pointer_);

    /** 
    Gets a modifiable version of the minimum corner of the box. **/
    public org.ogre4j.IVector3 getMinimum() {
         return new org.ogre4j.Vector3(new InstancePointer(_getMinimum(this.object.pointer)));
    }

    private native long _getMinimum(long _pointer_);

    /** **/
    public org.ogre4j.IVector3 getMaximum_const() {
         return new org.ogre4j.Vector3(new InstancePointer(_getMaximum_const_const(this.object.pointer)));
    }

    private native long _getMaximum_const_const(long _pointer_);

    /** 
    Gets a modifiable version of the maximum corner of the box. **/
    public org.ogre4j.IVector3 getMaximum() {
         return new org.ogre4j.Vector3(new InstancePointer(_getMaximum(this.object.pointer)));
    }

    private native long _getMaximum(long _pointer_);

    /** 
    Sets the minimum corner of the box. **/
    public void setMinimum(org.ogre4j.IVector3 vec) {
        _setMinimum__Vector3R(this.object.pointer, vec.getInstancePointer().pointer);
    }

    private native void _setMinimum__Vector3R(long _pointer_, long vec);

    /** **/
    public void setMinimum(float x, float y, float z) {
        _setMinimum__RealvRealvRealv(this.object.pointer, x,  y,  z);
    }

    private native void _setMinimum__RealvRealvRealv(long _pointer_, float x, float y, float z);

    /** 
    Changes one of the components of the minimum corner of the box used to resize only one dimension of the box **/
    public void setMinimumX(float x) {
        _setMinimumX__Realv(this.object.pointer, x);
    }

    private native void _setMinimumX__Realv(long _pointer_, float x);

    /** **/
    public void setMinimumY(float y) {
        _setMinimumY__Realv(this.object.pointer, y);
    }

    private native void _setMinimumY__Realv(long _pointer_, float y);

    /** **/
    public void setMinimumZ(float z) {
        _setMinimumZ__Realv(this.object.pointer, z);
    }

    private native void _setMinimumZ__Realv(long _pointer_, float z);

    /** 
    Sets the maximum corner of the box. **/
    public void setMaximum(org.ogre4j.IVector3 vec) {
        _setMaximum__Vector3R(this.object.pointer, vec.getInstancePointer().pointer);
    }

    private native void _setMaximum__Vector3R(long _pointer_, long vec);

    /** **/
    public void setMaximum(float x, float y, float z) {
        _setMaximum__RealvRealvRealv(this.object.pointer, x,  y,  z);
    }

    private native void _setMaximum__RealvRealvRealv(long _pointer_, float x, float y, float z);

    /** 
    Changes one of the components of the maximum corner of the box used to resize only one dimension of the box **/
    public void setMaximumX(float x) {
        _setMaximumX__Realv(this.object.pointer, x);
    }

    private native void _setMaximumX__Realv(long _pointer_, float x);

    /** **/
    public void setMaximumY(float y) {
        _setMaximumY__Realv(this.object.pointer, y);
    }

    private native void _setMaximumY__Realv(long _pointer_, float y);

    /** **/
    public void setMaximumZ(float z) {
        _setMaximumZ__Realv(this.object.pointer, z);
    }

    private native void _setMaximumZ__Realv(long _pointer_, float z);

    /** 
    Sets both minimum and maximum extents at once. **/
    public void setExtents(org.ogre4j.IVector3 _min, org.ogre4j.IVector3 _max) {
        _setExtents__Vector3RVector3R(this.object.pointer, _min.getInstancePointer().pointer,  _max.getInstancePointer().pointer);
    }

    private native void _setExtents__Vector3RVector3R(long _pointer_, long _min, long _max);

    /** **/
    public void setExtents(float mx, float my, float mz, float Mx, float My, float Mz) {
        _setExtents__RealvRealvRealvRealvRealvRealv(this.object.pointer, mx,  my,  mz,  Mx,  My,  Mz);
    }

    private native void _setExtents__RealvRealvRealvRealvRealvRealv(long _pointer_, float mx, float my, float mz, float Mx, float My, float Mz);

    /** 
    Returns a pointer to an array of 8 corner points, useful for collision vs. non-aligned objects. **/
    public org.ogre4j.IVector3 getAllCorners() {
         return new org.ogre4j.Vector3(new InstancePointer(_getAllCorners_const(this.object.pointer)));
    }

    private native long _getAllCorners_const(long _pointer_);

    /** 
    gets the position of one of the corners **/
    public void getCorner(org.ogre4j.IVector3 returnValue, org.ogre4j.AxisAlignedBox.CornerEnum cornerToGet) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getCorner__CornerEnumv_const(this.object.pointer, cornerToGet.getValue())), false);
    }

    private native long _getCorner__CornerEnumv_const(long _pointer_, int cornerToGet);

    /** 
    Merges the passed in box into the current box. The result is the box which encompasses both. **/
    public void merge(org.ogre4j.IAxisAlignedBox rhs) {
        _merge__AxisAlignedBoxR(this.object.pointer, rhs.getInstancePointer().pointer);
    }

    private native void _merge__AxisAlignedBoxR(long _pointer_, long rhs);

    /** 
    Extends the box to encompass the specified point (if needed). **/
    public void merge(org.ogre4j.IVector3 point) {
        _merge__Vector3R(this.object.pointer, point.getInstancePointer().pointer);
    }

    private native void _merge__Vector3R(long _pointer_, long point);

    /** 
    Transforms the box according to the matrix supplied. **/
    public void transform(org.ogre4j.IMatrix4 matrix) {
        _transform__Matrix4R(this.object.pointer, matrix.getInstancePointer().pointer);
    }

    private native void _transform__Matrix4R(long _pointer_, long matrix);

    /** 
    Transforms the box according to the affine matrix supplied. **/
    public void transformAffine(org.ogre4j.IMatrix4 m) {
        _transformAffine__Matrix4R(this.object.pointer, m.getInstancePointer().pointer);
    }

    private native void _transformAffine__Matrix4R(long _pointer_, long m);

    /** 
    Sets the box to a 'null' value i.e. not a box. **/
    public void setNull() {
        _setNull(this.object.pointer);
    }

    private native void _setNull(long _pointer_);

    /** 
    Returns true if the box is null i.e. empty. **/
    public boolean isNull() {
         return _isNull_const(this.object.pointer);
    }

    private native boolean _isNull_const(long _pointer_);

    /** 
    Returns true if the box is finite. **/
    public boolean isFinite() {
         return _isFinite_const(this.object.pointer);
    }

    private native boolean _isFinite_const(long _pointer_);

    /** 
    Sets the box to 'infinite' **/
    public void setInfinite() {
        _setInfinite(this.object.pointer);
    }

    private native void _setInfinite(long _pointer_);

    /** 
    Returns true if the box is infinite. **/
    public boolean isInfinite() {
         return _isInfinite_const(this.object.pointer);
    }

    private native boolean _isInfinite_const(long _pointer_);

    /** 
    Returns whether or not this box intersects another. **/
    public boolean intersects(org.ogre4j.IAxisAlignedBox b2) {
         return _intersects__AxisAlignedBoxR_const(this.object.pointer, b2.getInstancePointer().pointer);
    }

    private native boolean _intersects__AxisAlignedBoxR_const(long _pointer_, long b2);

    /** **/
    public void intersection(org.ogre4j.IAxisAlignedBox returnValue, org.ogre4j.IAxisAlignedBox b2) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_intersection__AxisAlignedBoxR_const(this.object.pointer, b2.getInstancePointer().pointer)), false);
    }

    private native long _intersection__AxisAlignedBoxR_const(long _pointer_, long b2);

    /** **/
    public float volume() {
         return _volume_const(this.object.pointer);
    }

    private native float _volume_const(long _pointer_);

    /** 
    Scales the AABB by the vector given. **/
    public void scale(org.ogre4j.IVector3 s) {
        _scale__Vector3R(this.object.pointer, s.getInstancePointer().pointer);
    }

    private native void _scale__Vector3R(long _pointer_, long s);

    /** 
    Tests whether this box intersects a sphere. **/
    public boolean intersects(org.ogre4j.ISphere s) {
         return _intersects__SphereR_const(this.object.pointer, s.getInstancePointer().pointer);
    }

    private native boolean _intersects__SphereR_const(long _pointer_, long s);

    /** 
    Tests whether this box intersects a plane. **/
    public boolean intersects(org.ogre4j.IPlane p) {
         return _intersects__PlaneR_const(this.object.pointer, p.getInstancePointer().pointer);
    }

    private native boolean _intersects__PlaneR_const(long _pointer_, long p);

    /** 
    Tests whether the vector point is within this box. **/
    public boolean intersects(org.ogre4j.IVector3 v) {
         return _intersects__Vector3R_const(this.object.pointer, v.getInstancePointer().pointer);
    }

    private native boolean _intersects__Vector3R_const(long _pointer_, long v);

    /** **/
    public void getCenter(org.ogre4j.IVector3 returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getCenter_const(this.object.pointer)), false);
    }

    private native long _getCenter_const(long _pointer_);

    /** **/
    public void getSize(org.ogre4j.IVector3 returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getSize_const(this.object.pointer)), false);
    }

    private native long _getSize_const(long _pointer_);

    /** **/
    public void getHalfSize(org.ogre4j.IVector3 returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getHalfSize_const(this.object.pointer)), false);
    }

    private native long _getHalfSize_const(long _pointer_);

    /** 
    Tests whether the given point contained by this box. **/
    public boolean contains(org.ogre4j.IVector3 v) {
         return _contains__Vector3R_const(this.object.pointer, v.getInstancePointer().pointer);
    }

    private native boolean _contains__Vector3R_const(long _pointer_, long v);

    /** 
    Tests whether another box contained by this box. **/
    public boolean contains(org.ogre4j.IAxisAlignedBox other) {
         return _contains__AxisAlignedBoxR_const(this.object.pointer, other.getInstancePointer().pointer);
    }

    private native boolean _contains__AxisAlignedBoxR_const(long _pointer_, long other);

    /** 
    Tests 2 boxes for equality. **/
    public boolean operatorEqual(org.ogre4j.IAxisAlignedBox rhs) {
         return _operatorEqual__AxisAlignedBoxR_const(this.object.pointer, rhs.getInstancePointer().pointer);
    }

    private native boolean _operatorEqual__AxisAlignedBoxR_const(long _pointer_, long rhs);

    /** 
    Tests 2 boxes for inequality. **/
    public boolean operatorNotEqual(org.ogre4j.IAxisAlignedBox rhs) {
         return _operatorNotEqual__AxisAlignedBoxR_const(this.object.pointer, rhs.getInstancePointer().pointer);
    }

    private native boolean _operatorNotEqual__AxisAlignedBoxR_const(long _pointer_, long rhs);

    /** **/
    public static org.ogre4j.IAxisAlignedBox getBOX_NULL() {
         return new org.ogre4j.AxisAlignedBox(new InstancePointer(_getBOX_NULL()));
    }

    private native static long _getBOX_NULL();

    /** **/
    public static org.ogre4j.IAxisAlignedBox getBOX_INFINITE() {
         return new org.ogre4j.AxisAlignedBox(new InstancePointer(_getBOX_INFINITE()));
    }

    private native static long _getBOX_INFINITE();

}
