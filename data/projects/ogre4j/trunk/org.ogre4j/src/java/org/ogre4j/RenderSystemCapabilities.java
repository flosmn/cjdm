/**
 *  This source file is generated by XBiG (The XSLT Bindings Generator)
 *  For the latest info, see http://sourceforge.net/projects/xbig/
 * 
 *  Copyright (c) 2004-2008 NetAllied Systems GmbH, Ravensburg. All rights reserved.
 *  Also see acknowledgements in Readme.html
 * 
 *  This program is free software; you can redistribute it and/or modify it under
 *  the terms of the GNU Lesser General Public License as published by the Free Software
 *  Foundation; either version 2 of the License, or (at your option) any later
 *  version.
 * 
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 *  FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 * 
 *  You should have received a copy of the GNU Lesser General Public License along with
 *  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 *  Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 *  http://www.gnu.org/copyleft/lesser.txt.
 * 
 *  Machine generated file
 */

        

package org.ogre4j;


import org.xbig.base.*;
public class RenderSystemCapabilities extends org.xbig.base.NativeObject implements org.ogre4j.IRenderSystemCapabilities {
static { System.loadLibrary("ogre4j");}
public static class ShaderProfiles extends org.xbig.base.NativeObject implements org.ogre4j.IRenderSystemCapabilities.IShaderProfiles {
static { System.loadLibrary("ogre4j");}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public ShaderProfiles(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected ShaderProfiles(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public ShaderProfiles(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public ShaderProfiles() {
         super( new org.xbig.base.InstancePointer(__createShaderProfiles()), false);
    }

    private native static long __createShaderProfiles();

    /** **/
    public void clear() {
        _clear(this.object.pointer);
    }

    private native void _clear(long _pointer_);

    /** **/
    public int count(String key) {
         return _count__sR(this.object.pointer, key);
    }

    private native int _count__sR(long _pointer_, String key);

    /** **/
    public boolean empty() {
         return _empty_const(this.object.pointer);
    }

    private native boolean _empty_const(long _pointer_);

    /** **/
    public int erase(String key) {
         return _erase__sR(this.object.pointer, key);
    }

    private native int _erase__sR(long _pointer_, String key);

    /** **/
    public int max_size() {
         return _max_size_const(this.object.pointer);
    }

    private native int _max_size_const(long _pointer_);

    /** **/
    public int size() {
         return _size_const(this.object.pointer);
    }

    private native int _size_const(long _pointer_);

}
 
        
	/**
	 * 
	 * This constructor is public for internal useage only!
	 * Do not use it!
	 * 
	 */
	public RenderSystemCapabilities(org.xbig.base.InstancePointer p) {
		super(p);
	}

	/**
	 * 
	 * Creates a Java wrapper object for an existing C++ object.
	 * If remote is set to 'true' this object cannot be deleted in Java.
	 * 
	 */
	protected RenderSystemCapabilities(org.xbig.base.InstancePointer p, boolean remote) {
		super(p, remote);
	}

    /**
     * Allows creation of Java objects without C++ objects.
     * 
     * @see org.xbig.base.WithoutNativeObject
     * @see org.xbig.base.INativeObject#disconnectFromNativeObject()
     */
	public RenderSystemCapabilities(org.xbig.base.WithoutNativeObject val) {
		super(val);
	}

	public void delete() {
		if (this.remote) {
	       throw new RuntimeException("can't dispose object created by native library");
	    }

		if(!this.deleted) {
		    __delete(object.pointer);
		    this.deleted = true;
		   	this.object.pointer = 0;
		}
	}

	public void finalize() {
		if(!this.remote && !this.deleted) {
			delete();
		}
	}
	
			
	private final native void __delete(long _pointer_);	



          /** **/
    public RenderSystemCapabilities() {
         super( new org.xbig.base.InstancePointer(__createRenderSystemCapabilities()), false);
    }

    private native static long __createRenderSystemCapabilities();

    /** **/
    public int calculateSize() {
         return _calculateSize_const(this.object.pointer);
    }

    private native int _calculateSize_const(long _pointer_);

    /** 
    Set the driver version. **/
    public void setDriverVersion(org.ogre4j.IDriverVersion version) {
        _setDriverVersion__DriverVersionR(this.object.pointer, version.getInstancePointer().pointer);
    }

    private native void _setDriverVersion__DriverVersionR(long _pointer_, long version);

    /** **/
    public void parseDriverVersionFromString(String versionString) {
        _parseDriverVersionFromString__StringR(this.object.pointer, versionString);
    }

    private native void _parseDriverVersionFromString__StringR(long _pointer_, String versionString);

    /** **/
    public void getDriverVersion(org.ogre4j.IDriverVersion returnValue) {
          returnValue.delete();
  returnValue.setInstancePointer(new InstancePointer(_getDriverVersion_const(this.object.pointer)), false);
    }

    private native long _getDriverVersion_const(long _pointer_);

    /** **/
    public org.ogre4j.GPUVendor getVendor() {
         return org.ogre4j.GPUVendor.toEnum(_getVendor_const(this.object.pointer));
    }

    private native int _getVendor_const(long _pointer_);

    /** **/
    public void setVendor(org.ogre4j.GPUVendor v) {
        _setVendor__GPUVendorv(this.object.pointer, v.getValue());
    }

    private native void _setVendor__GPUVendorv(long _pointer_, int v);

    /** **/
    public void parseVendorFromString(String vendorString) {
        _parseVendorFromString__StringR(this.object.pointer, vendorString);
    }

    private native void _parseVendorFromString__StringR(long _pointer_, String vendorString);

    /** **/
    public boolean isDriverOlderThanVersion(org.ogre4j.IDriverVersion v) {
         return _isDriverOlderThanVersion__DriverVersionv_const(this.object.pointer, v.getInstancePointer().pointer);
    }

    private native boolean _isDriverOlderThanVersion__DriverVersionv_const(long _pointer_, long v);

    /** **/
    public void setNumWorldMatrices(int num) {
        _setNumWorldMatrices__ushortv(this.object.pointer, num);
    }

    private native void _setNumWorldMatrices__ushortv(long _pointer_, int num);

    /** **/
    public void setNumTextureUnits(int num) {
        _setNumTextureUnits__ushortv(this.object.pointer, num);
    }

    private native void _setNumTextureUnits__ushortv(long _pointer_, int num);

    /** **/
    public void setStencilBufferBitDepth(int num) {
        _setStencilBufferBitDepth__ushortv(this.object.pointer, num);
    }

    private native void _setStencilBufferBitDepth__ushortv(long _pointer_, int num);

    /** **/
    public void setNumVertexBlendMatrices(int num) {
        _setNumVertexBlendMatrices__ushortv(this.object.pointer, num);
    }

    private native void _setNumVertexBlendMatrices__ushortv(long _pointer_, int num);

    /** **/
    public void setNumMultiRenderTargets(int num) {
        _setNumMultiRenderTargets__ushortv(this.object.pointer, num);
    }

    private native void _setNumMultiRenderTargets__ushortv(long _pointer_, int num);

    /** **/
    public int getNumWorldMatrices() {
         return _getNumWorldMatrices_const(this.object.pointer);
    }

    private native int _getNumWorldMatrices_const(long _pointer_);

    /** 
    Returns the number of texture units the current output hardware supports.
    For use in rendering, this determines how many texture units the are available for multitexturing (i.e. rendering multiple textures in a single pass). Where a  has multiple texture layers, it will try to use multitexturing where available, and where it is not available, will perform multipass rendering to achieve the same effect. This property only applies to the fixed-function pipeline, the number available to the programmable pipeline depends on the shader model in use. **/
    public int getNumTextureUnits() {
         return _getNumTextureUnits_const(this.object.pointer);
    }

    private native int _getNumTextureUnits_const(long _pointer_);

    /** 
    Determines the bit depth of the hardware accelerated stencil buffer, if supported. **/
    public int getStencilBufferBitDepth() {
         return _getStencilBufferBitDepth_const(this.object.pointer);
    }

    private native int _getStencilBufferBitDepth_const(long _pointer_);

    /** 
    Returns the number of matrices available to hardware vertex blending for this rendering system. **/
    public int getNumVertexBlendMatrices() {
         return _getNumVertexBlendMatrices_const(this.object.pointer);
    }

    private native int _getNumVertexBlendMatrices_const(long _pointer_);

    /** **/
    public int getNumMultiRenderTargets() {
         return _getNumMultiRenderTargets_const(this.object.pointer);
    }

    private native int _getNumMultiRenderTargets_const(long _pointer_);

    /** 
    Returns true if capability is render system specific **/
    public boolean isCapabilityRenderSystemSpecific(org.ogre4j.Capabilities c) {
         return _isCapabilityRenderSystemSpecific__CapabilitiesV(this.object.pointer, c.getValue());
    }

    private native boolean _isCapabilityRenderSystemSpecific__CapabilitiesV(long _pointer_, int c);

    /** 
    Adds a capability flag **/
    public void setCapability(org.ogre4j.Capabilities c) {
        _setCapability__CapabilitiesV(this.object.pointer, c.getValue());
    }

    private native void _setCapability__CapabilitiesV(long _pointer_, int c);

    /** 
    Remove a capability flag **/
    public void unsetCapability(org.ogre4j.Capabilities c) {
        _unsetCapability__CapabilitiesV(this.object.pointer, c.getValue());
    }

    private native void _unsetCapability__CapabilitiesV(long _pointer_, int c);

    /** 
    Checks for a capability **/
    public boolean hasCapability(org.ogre4j.Capabilities c) {
         return _hasCapability__CapabilitiesV_const(this.object.pointer, c.getValue());
    }

    private native boolean _hasCapability__CapabilitiesV_const(long _pointer_, int c);

    /** 
    Adds the profile to the list of supported profiles **/
    public void addShaderProfile(String profile) {
        _addShaderProfile__StringR(this.object.pointer, profile);
    }

    private native void _addShaderProfile__StringR(long _pointer_, String profile);

    /** 
    Remove a given shader profile, if present. **/
    public void removeShaderProfile(String profile) {
        _removeShaderProfile__StringR(this.object.pointer, profile);
    }

    private native void _removeShaderProfile__StringR(long _pointer_, String profile);

    /** 
    Returns true if profile is in the list of supported profiles **/
    public boolean isShaderProfileSupported(String profile) {
         return _isShaderProfileSupported__StringR_const(this.object.pointer, profile);
    }

    private native boolean _isShaderProfileSupported__StringR_const(long _pointer_, String profile);

    /** 
    Returns a set of all supported shader profiles **/
    public org.ogre4j.IRenderSystemCapabilities.IShaderProfiles getSupportedShaderProfiles() {
         return new org.ogre4j.RenderSystemCapabilities.ShaderProfiles(new InstancePointer(_getSupportedShaderProfiles_const(this.object.pointer)));
    }

    private native long _getSupportedShaderProfiles_const(long _pointer_);

    /** **/
    public int getVertexProgramConstantFloatCount() {
         return _getVertexProgramConstantFloatCount_const(this.object.pointer);
    }

    private native int _getVertexProgramConstantFloatCount_const(long _pointer_);

    /** **/
    public int getVertexProgramConstantIntCount() {
         return _getVertexProgramConstantIntCount_const(this.object.pointer);
    }

    private native int _getVertexProgramConstantIntCount_const(long _pointer_);

    /** **/
    public int getVertexProgramConstantBoolCount() {
         return _getVertexProgramConstantBoolCount_const(this.object.pointer);
    }

    private native int _getVertexProgramConstantBoolCount_const(long _pointer_);

    /** **/
    public int getGeometryProgramConstantFloatCount() {
         return _getGeometryProgramConstantFloatCount_const(this.object.pointer);
    }

    private native int _getGeometryProgramConstantFloatCount_const(long _pointer_);

    /** **/
    public int getGeometryProgramConstantIntCount() {
         return _getGeometryProgramConstantIntCount_const(this.object.pointer);
    }

    private native int _getGeometryProgramConstantIntCount_const(long _pointer_);

    /** **/
    public int getGeometryProgramConstantBoolCount() {
         return _getGeometryProgramConstantBoolCount_const(this.object.pointer);
    }

    private native int _getGeometryProgramConstantBoolCount_const(long _pointer_);

    /** **/
    public int getFragmentProgramConstantFloatCount() {
         return _getFragmentProgramConstantFloatCount_const(this.object.pointer);
    }

    private native int _getFragmentProgramConstantFloatCount_const(long _pointer_);

    /** **/
    public int getFragmentProgramConstantIntCount() {
         return _getFragmentProgramConstantIntCount_const(this.object.pointer);
    }

    private native int _getFragmentProgramConstantIntCount_const(long _pointer_);

    /** **/
    public int getFragmentProgramConstantBoolCount() {
         return _getFragmentProgramConstantBoolCount_const(this.object.pointer);
    }

    private native int _getFragmentProgramConstantBoolCount_const(long _pointer_);

    /** **/
    public void setDeviceName(String name) {
        _setDeviceName__StringR(this.object.pointer, name);
    }

    private native void _setDeviceName__StringR(long _pointer_, String name);

    /** **/
    public String getDeviceName() {
         return _getDeviceName_const(this.object.pointer);
    }

    private native String _getDeviceName_const(long _pointer_);

    /** **/
    public void setVertexProgramConstantFloatCount(int c) {
        _setVertexProgramConstantFloatCount__ushortv(this.object.pointer, c);
    }

    private native void _setVertexProgramConstantFloatCount__ushortv(long _pointer_, int c);

    /** **/
    public void setVertexProgramConstantIntCount(int c) {
        _setVertexProgramConstantIntCount__ushortv(this.object.pointer, c);
    }

    private native void _setVertexProgramConstantIntCount__ushortv(long _pointer_, int c);

    /** **/
    public void setVertexProgramConstantBoolCount(int c) {
        _setVertexProgramConstantBoolCount__ushortv(this.object.pointer, c);
    }

    private native void _setVertexProgramConstantBoolCount__ushortv(long _pointer_, int c);

    /** **/
    public void setGeometryProgramConstantFloatCount(int c) {
        _setGeometryProgramConstantFloatCount__ushortv(this.object.pointer, c);
    }

    private native void _setGeometryProgramConstantFloatCount__ushortv(long _pointer_, int c);

    /** **/
    public void setGeometryProgramConstantIntCount(int c) {
        _setGeometryProgramConstantIntCount__ushortv(this.object.pointer, c);
    }

    private native void _setGeometryProgramConstantIntCount__ushortv(long _pointer_, int c);

    /** **/
    public void setGeometryProgramConstantBoolCount(int c) {
        _setGeometryProgramConstantBoolCount__ushortv(this.object.pointer, c);
    }

    private native void _setGeometryProgramConstantBoolCount__ushortv(long _pointer_, int c);

    /** **/
    public void setFragmentProgramConstantFloatCount(int c) {
        _setFragmentProgramConstantFloatCount__ushortv(this.object.pointer, c);
    }

    private native void _setFragmentProgramConstantFloatCount__ushortv(long _pointer_, int c);

    /** **/
    public void setFragmentProgramConstantIntCount(int c) {
        _setFragmentProgramConstantIntCount__ushortv(this.object.pointer, c);
    }

    private native void _setFragmentProgramConstantIntCount__ushortv(long _pointer_, int c);

    /** **/
    public void setFragmentProgramConstantBoolCount(int c) {
        _setFragmentProgramConstantBoolCount__ushortv(this.object.pointer, c);
    }

    private native void _setFragmentProgramConstantBoolCount__ushortv(long _pointer_, int c);

    /** **/
    public void setMaxPointSize(float s) {
        _setMaxPointSize__Realv(this.object.pointer, s);
    }

    private native void _setMaxPointSize__Realv(long _pointer_, float s);

    /** **/
    public float getMaxPointSize() {
         return _getMaxPointSize_const(this.object.pointer);
    }

    private native float _getMaxPointSize_const(long _pointer_);

    /** **/
    public void setNonPOW2TexturesLimited(boolean l) {
        _setNonPOW2TexturesLimited__bv(this.object.pointer, l);
    }

    private native void _setNonPOW2TexturesLimited__bv(long _pointer_, boolean l);

    /** 
    Are non-power of two textures limited in features? **/
    public boolean getNonPOW2TexturesLimited() {
         return _getNonPOW2TexturesLimited_const(this.object.pointer);
    }

    private native boolean _getNonPOW2TexturesLimited_const(long _pointer_);

    /** **/
    public void setNumVertexTextureUnits(int n) {
        _setNumVertexTextureUnits__ushortv(this.object.pointer, n);
    }

    private native void _setNumVertexTextureUnits__ushortv(long _pointer_, int n);

    /** **/
    public int getNumVertexTextureUnits() {
         return _getNumVertexTextureUnits_const(this.object.pointer);
    }

    private native int _getNumVertexTextureUnits_const(long _pointer_);

    /** **/
    public void setVertexTextureUnitsShared(boolean shared) {
        _setVertexTextureUnitsShared__bv(this.object.pointer, shared);
    }

    private native void _setVertexTextureUnitsShared__bv(long _pointer_, boolean shared);

    /** **/
    public boolean getVertexTextureUnitsShared() {
         return _getVertexTextureUnitsShared_const(this.object.pointer);
    }

    private native boolean _getVertexTextureUnitsShared_const(long _pointer_);

    /** **/
    public void setGeometryProgramNumOutputVertices(int numOutputVertices) {
        _setGeometryProgramNumOutputVertices__iv(this.object.pointer, numOutputVertices);
    }

    private native void _setGeometryProgramNumOutputVertices__iv(long _pointer_, int numOutputVertices);

    /** **/
    public int getGeometryProgramNumOutputVertices() {
         return _getGeometryProgramNumOutputVertices_const(this.object.pointer);
    }

    private native int _getGeometryProgramNumOutputVertices_const(long _pointer_);

    /** **/
    public String getRenderSystemName() {
         return _getRenderSystemName_const(this.object.pointer);
    }

    private native String _getRenderSystemName_const(long _pointer_);

    /** **/
    public void setRenderSystemName(String rs) {
        _setRenderSystemName__StringR(this.object.pointer, rs);
    }

    private native void _setRenderSystemName__StringR(long _pointer_, String rs);

    /** **/
    public void setCategoryRelevant(org.ogre4j.CapabilitiesCategory cat, boolean relevant) {
        _setCategoryRelevant__CapabilitiesCategoryvbv(this.object.pointer, cat.getValue(),  relevant);
    }

    private native void _setCategoryRelevant__CapabilitiesCategoryvbv(long _pointer_, int cat, boolean relevant);

    /** **/
    public boolean isCategoryRelevant(org.ogre4j.CapabilitiesCategory cat) {
         return _isCategoryRelevant__CapabilitiesCategoryv(this.object.pointer, cat.getValue());
    }

    private native boolean _isCategoryRelevant__CapabilitiesCategoryv(long _pointer_, int cat);

    /** 
    Write the capabilities to the pass in **/
    public void log(org.ogre4j.ILog pLog) {
        _log__Logp(this.object.pointer, pLog.getInstancePointer().pointer);
    }

    private native void _log__Logp(long _pointer_, long pLog);

    /** **/
    public static org.ogre4j.GPUVendor vendorFromString(String vendorString) {
         return org.ogre4j.GPUVendor.toEnum(_vendorFromString__StringR( vendorString));
    }

    private native static int _vendorFromString__StringR(String vendorString);

    /** **/
    public static String vendorToString(org.ogre4j.GPUVendor v) {
         return _vendorToString__GPUVendorv( v.getValue());
    }

    private native static String _vendorToString__GPUVendorv(int v);

}
